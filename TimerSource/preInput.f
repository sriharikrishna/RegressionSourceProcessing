
      MODULE size_mod
      use w2f__types
      IMPLICIT NONE
      SAVE
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) MAX_OLX
      PARAMETER ( MAX_OLX = 3)
      INTEGER(w2f__i4) MAX_OLY
      PARAMETER ( MAX_OLY = 3)
      INTEGER(w2f__i4) NOBCS
      PARAMETER ( NOBCS = 4)
      INTEGER(w2f__i4) NPX
      PARAMETER ( NPX = 1)
      INTEGER(w2f__i4) NPY
      PARAMETER ( NPY = 1)
      INTEGER(w2f__i4) NR
      PARAMETER ( NR = 15)
      INTEGER(w2f__i4) NSX
      PARAMETER ( NSX = 1)
      INTEGER(w2f__i4) NSY
      PARAMETER ( NSY = 1)
      INTEGER(w2f__i4) NX
      PARAMETER ( NX = 90)
      INTEGER(w2f__i4) NY
      PARAMETER ( NY = 40)
      INTEGER(w2f__i4) OLX
      PARAMETER ( OLX = 3)
      INTEGER(w2f__i4) OLY
      PARAMETER ( OLY = 3)
      INTEGER(w2f__i4) SNX
      PARAMETER ( SNX = 90)
      INTEGER(w2f__i4) SNY
      PARAMETER ( SNY = 40)
C
C     **** Statements ****
C
      END MODULE

      MODULE eeparams_mod
      use w2f__types
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      LOGICAL(w2f__i4) EEBOOTERROR
      INTEGER(w2f__i4) EEDATAUNIT
      LOGICAL(w2f__i4) EEENDERROR
      INTEGER(w2f__i4) ERRORMESSAGEUNIT
      LOGICAL(w2f__i4) FATALERROR
      INTEGER(w2f__i4) IOERRORCOUNT(1 : 4)
      INTEGER(w2f__i4) MAXLENGTHPRT1D
      INTEGER(w2f__i4) MODELDATAUNIT
      INTEGER(w2f__i4) MYBXHI(1 : 4)
      INTEGER(w2f__i4) MYBXLO(1 : 4)
      INTEGER(w2f__i4) MYBYHI(1 : 4)
      INTEGER(w2f__i4) MYBYLO(1 : 4)
      INTEGER(w2f__i4) MYPROCID
      INTEGER(w2f__i4) MYPX
      INTEGER(w2f__i4) MYPY
      INTEGER(w2f__i4) MYXGLOBALLO
      INTEGER(w2f__i4) MYYGLOBALLO
      INTEGER(w2f__i4) NTHREADS
      INTEGER(w2f__i4) NTX
      INTEGER(w2f__i4) NTY
      INTEGER(w2f__i4) NUMBEROFPROCS
      INTEGER(w2f__i4) PIDIO
      LOGICAL(w2f__i4) PRINTMAPINCLUDESZEROS
      INTEGER(w2f__i4) SCRUNIT1
      INTEGER(w2f__i4) SCRUNIT2
      INTEGER(w2f__i4) STANDARDMESSAGEUNIT
      LOGICAL(w2f__i4) USECOUPLER
      LOGICAL(w2f__i4) USECUBEDSPHEREEXCHANGE
      LOGICAL(w2f__i4) USESETRLSTK
      LOGICAL(w2f__i4) USESIGREG
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) CACHELINESIZE
      PARAMETER ( CACHELINESIZE = 256)
      CHARACTER(1) COMMENTCHARACTER
      PARAMETER ( COMMENTCHARACTER = '#')
      INTEGER(w2f__i4) DEBLEVA
      PARAMETER ( DEBLEVA = 1)
      INTEGER(w2f__i4) DEBLEVB
      PARAMETER ( DEBLEVB = 2)
      INTEGER(w2f__i4) DEBLEVZERO
      PARAMETER ( DEBLEVZERO = 0)
      INTEGER(w2f__i4) EXCH_IGNORE_CORNERS
      PARAMETER ( EXCH_IGNORE_CORNERS = 0)
      INTEGER(w2f__i4) EXCH_UPDATE_CORNERS
      PARAMETER ( EXCH_UPDATE_CORNERS = 1)
      INTEGER(w2f__i4) FORWARD_SIMULATION
      PARAMETER ( FORWARD_SIMULATION = 0)
      INTEGER(w2f__i4) INDEX_I
      PARAMETER ( INDEX_I = 1)
      INTEGER(w2f__i4) INDEX_J
      PARAMETER ( INDEX_J = 2)
      INTEGER(w2f__i4) INDEX_K
      PARAMETER ( INDEX_K = 3)
      INTEGER(w2f__i4) INDEX_NONE
      PARAMETER ( INDEX_NONE = 4)
      INTEGER(w2f__i4) LSHARE1
      PARAMETER ( LSHARE1 = 256)
      INTEGER(w2f__i4) LSHARE4
      PARAMETER ( LSHARE4 = 64)
      INTEGER(w2f__i4) LSHARE8
      PARAMETER ( LSHARE8 = 32)
      INTEGER(w2f__i4) MAX_LEN_FNAM
      PARAMETER ( MAX_LEN_FNAM = 512)
      INTEGER(w2f__i4) MAX_LEN_MBUF
      PARAMETER ( MAX_LEN_MBUF = 512)
      INTEGER(w2f__i4) MAX_LEN_PREC
      PARAMETER ( MAX_LEN_PREC = 200)
      INTEGER(w2f__i4) MAX_NO_BARRIERS
      PARAMETER ( MAX_NO_BARRIERS = 1)
      INTEGER(w2f__i4) MAX_NO_PROCS
      PARAMETER ( MAX_NO_PROCS = 2048)
      INTEGER(w2f__i4) MAX_NO_THREADS
      PARAMETER ( MAX_NO_THREADS = 4)
      INTEGER(w2f__i4) MAX_VGS
      PARAMETER ( MAX_VGS = 8192)
      INTEGER(w2f__i4) PRECFLOAT32
      PARAMETER ( PRECFLOAT32 = 32)
      INTEGER(w2f__i4) PRECFLOAT64
      PARAMETER ( PRECFLOAT64 = 64)
      CHARACTER(2) PRINT_MAP_XY
      PARAMETER ( PRINT_MAP_XY = 'XY')
      CHARACTER(2) PRINT_MAP_XZ
      PARAMETER ( PRINT_MAP_XZ = 'XZ')
      CHARACTER(2) PRINT_MAP_YZ
      PARAMETER ( PRINT_MAP_YZ = 'YZ')
      INTEGER(w2f__i4) REVERSE_SIMULATION
      PARAMETER ( REVERSE_SIMULATION = 1)
      CHARACTER(1) SQUEEZE_BOTH
      PARAMETER ( SQUEEZE_BOTH = 'B')
      CHARACTER(1) SQUEEZE_LEFT
      PARAMETER ( SQUEEZE_LEFT = 'L')
      CHARACTER(1) SQUEEZE_RIGHT
      PARAMETER ( SQUEEZE_RIGHT = 'R')
      INTEGER(w2f__i4) TANGENT_SIMULATION
      PARAMETER ( TANGENT_SIMULATION = 2)
      REAL(w2f__4) UNSET_FLOAT4
      PARAMETER ( UNSET_FLOAT4 = 1.2345670312E+05)
      REAL(w2f__8) UNSET_FLOAT8
      PARAMETER ( UNSET_FLOAT8 = 1.2345669999999999709D+05)
      INTEGER(w2f__i4) UNSET_I
      PARAMETER ( UNSET_I = 123456789)
      REAL(w2f__8) UNSET_RL
      PARAMETER ( UNSET_RL = 1.2345669999999999709D+05)
      REAL(w2f__8) UNSET_RS
      PARAMETER ( UNSET_RS = 1.2345669999999999709D+05)
C
C     **** Statements ****
C
      END MODULE

      MODULE params_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) ABEPS
      REAL(w2f__8) ADJDUMPFREQ
      REAL(w2f__8) ADJMONITORFREQ
      REAL(w2f__8) AFFACMOM
      LOGICAL(w2f__i4) ALLOWFREEZING
      REAL(w2f__8) ALPH_AB
      REAL(w2f__8) ATM_CP
      REAL(w2f__8) ATM_KAPPA
      REAL(w2f__8) ATM_PO
      REAL(w2f__8) ATM_RD
      REAL(w2f__8) ATM_RQ
      LOGICAL(w2f__i4) BALANCEEMPMR
      LOGICAL(w2f__i4) BALANCEPRINTMEAN
      LOGICAL(w2f__i4) BALANCEQNET
      REAL(w2f__8) BASETIME
      CHARACTER(512) BATHYFILE
      REAL(w2f__8) BETA
      REAL(w2f__8) BETA_AB
      REAL(w2f__8) BL79LATVARY
      REAL(w2f__8) BOTTOMDRAGLINEAR
      REAL(w2f__8) BOTTOMDRAGQUADRATIC
      CHARACTER(512) BUOYANCYRELATION
      REAL(w2f__8) CADJFREQ
      REAL(w2f__8) CELSIUS2K
      REAL(w2f__8) CFFACMOM
      INTEGER(w2f__i4) CG2DCHKRESFREQ
      INTEGER(w2f__i4) CG2DMAXITERS
      REAL(w2f__8) CG2DPCOFFDFAC
      INTEGER(w2f__i4) CG2DPRECONDFREQ
      REAL(w2f__8) CG2DTARGETRESIDUAL
      REAL(w2f__8) CG2DTARGETRESWUNIT
      INTEGER(w2f__i4) CG3DCHKRESFREQ
      INTEGER(w2f__i4) CG3DMAXITERS
      REAL(w2f__8) CG3DTARGETRESIDUAL
      REAL(w2f__8) CHKPTFREQ
      REAL(w2f__8) CONVERTFW2SALT
      REAL(w2f__8) COSPOWER
      REAL(w2f__8) DBDRREF(1 : 15)
      INTEGER(w2f__i4) DEBUGLEVEL
      LOGICAL(w2f__i4) DEBUGMODE
      LOGICAL(w2f__i4) DEEPATMOSPHERE
      REAL(w2f__8) DELR(1 : 15)
      REAL(w2f__8) DELRC(1 : 16)
      CHARACTER(512) DELRCFILE
      CHARACTER(512) DELRFILE
      REAL(w2f__8) DELT
      REAL(w2f__8) DELTAT
      REAL(w2f__8) DELTATCLOCK
      REAL(w2f__8) DELTATFREESURF
      REAL(w2f__8) DELTATMOM
      REAL(w2f__8) DELX(1 : 90)
      CHARACTER(512) DELXFILE
      REAL(w2f__8) DELY(1 : 40)
      CHARACTER(512) DELYFILE
      REAL(w2f__8) DIAGFREQ
      REAL(w2f__8) DIFFK4S
      REAL(w2f__8) DIFFK4T
      REAL(w2f__8) DIFFKHS
      REAL(w2f__8) DIFFKHT
      REAL(w2f__8) DIFFKRBL79DEEP
      REAL(w2f__8) DIFFKRBL79HO
      REAL(w2f__8) DIFFKRBL79SCL
      REAL(w2f__8) DIFFKRBL79SURF
      REAL(w2f__8) DIFFKRBLEQDEEP
      REAL(w2f__8) DIFFKRBLEQHO
      REAL(w2f__8) DIFFKRBLEQSCL
      REAL(w2f__8) DIFFKRBLEQSURF
      CHARACTER(512) DIFFKRFILE
      REAL(w2f__8) DIFFKRNRS(1 : 15)
      REAL(w2f__8) DIFFKRNRT(1 : 15)
      LOGICAL(w2f__i4) DOAB_ONGTGS
      LOGICAL(w2f__i4) DOSALTCLIMRELAX
      LOGICAL(w2f__i4) DOTHETACLIMRELAX
      CHARACTER(512) DQDTFILE
      REAL(w2f__8) DRHOSMALL
      REAL(w2f__8) DTTRACERLEV(1 : 15)
      REAL(w2f__8) DUMPFREQ
      LOGICAL(w2f__i4) DUMPINITANDLAST
      CHARACTER(512) EDDYPSIXFILE
      CHARACTER(512) EDDYPSIYFILE
      CHARACTER(512) EMPMRFILE
      REAL(w2f__8) ENDTIME
      CHARACTER(6) EOSTYPE
      LOGICAL(w2f__i4) EXACTCONSERV
      REAL(w2f__8) EXTERNFORCINGCYCLE
      REAL(w2f__8) EXTERNFORCINGPERIOD
      REAL(w2f__8) F0
      LOGICAL(w2f__i4) FLUIDISAIR
      LOGICAL(w2f__i4) FLUIDISWATER
      REAL(w2f__8) FOFACMOM
      REAL(w2f__8) FREESURFFAC
      REAL(w2f__8) GBARO
      LOGICAL(w2f__i4) GLOBALFILES
      REAL(w2f__8) GRAVITY
      REAL(w2f__8) HEATCAPACITY_CP
      REAL(w2f__8) HFACINF
      REAL(w2f__8) HFACMIN
      REAL(w2f__8) HFACMINDP
      REAL(w2f__8) HFACMINDR
      REAL(w2f__8) HFACMINDZ
      REAL(w2f__8) HFACSUP
      LOGICAL(w2f__i4) HIGHORDERVORTICITY
      REAL(w2f__8) HMIXCRITERIA
      REAL(w2f__8) HMIXSMOOTH
      CHARACTER(512) HORIZGRIDFILE
      CHARACTER(512) HYDROGSALTFILE
      CHARACTER(512) HYDROGTHETAFILE
      REAL(w2f__8) IMPLICDIV2DFLOW
      LOGICAL(w2f__i4) IMPLICITDIFFUSION
      LOGICAL(w2f__i4) IMPLICITFREESURFACE
      LOGICAL(w2f__i4) IMPLICITINTGRAVWAVE
      LOGICAL(w2f__i4) IMPLICITVISCOSITY
      REAL(w2f__8) IMPLICSURFPRESS
      LOGICAL(w2f__i4) INADEXACT
      LOGICAL(w2f__i4) INADFALSE
      LOGICAL(w2f__i4) INADMODE
      LOGICAL(w2f__i4) INADTRUE
      INTEGER(w2f__i4) INTEGR_GEOPOT
      REAL(w2f__8) IVDC_KAPPA
      CHARACTER(512) LAMBDASALTFILE
      CHARACTER(512) LAMBDATHETAFILE
      REAL(w2f__8) LATBANDCLIMRELAX
      LOGICAL(w2f__i4) LINFSCONSERVETR
      REAL(w2f__8) MASS2RUNIT
      CHARACTER(512) MDSIOLOCALDIR
      CHARACTER(512) MERIDWINDFILE
      LOGICAL(w2f__i4) METRICTERMS
      LOGICAL(w2f__i4) MOMADVECTION
      LOGICAL(w2f__i4) MOMDISSIP_IN_AB
      LOGICAL(w2f__i4) MOMFORCING
      INTEGER(w2f__i4) MOMFORCINGOUTAB
      LOGICAL(w2f__i4) MOMIMPLVERTADV
      LOGICAL(w2f__i4) MOMPRESSUREFORCING
      LOGICAL(w2f__i4) MOMSTEPPING
      LOGICAL(w2f__i4) MOMVISCOSITY
      REAL(w2f__8) MONITORFREQ
      INTEGER(w2f__i4) MONITORSELECT
      LOGICAL(w2f__i4) MONITOR_STDIO
      REAL(w2f__8) MTFACMOM
      LOGICAL(w2f__i4) MULTIDIMADVECTION
      INTEGER(w2f__i4) NENDITER
      REAL(w2f__8) NH_AM2
      INTEGER(w2f__i4) NITER0
      LOGICAL(w2f__i4) NONHYDROSTATIC
      INTEGER(w2f__i4) NONLINFREESURF
      LOGICAL(w2f__i4) NO_SLIP_BOTTOM
      LOGICAL(w2f__i4) NO_SLIP_SIDES
      INTEGER(w2f__i4) NTIMESTEPS
      REAL(w2f__8) OMEGA
      LOGICAL(w2f__i4) OUTPUTTYPESINCLUSIVE
      REAL(w2f__8) PCHKPTFREQ
      LOGICAL(w2f__i4) PERIODICEXTERNALFORCING
      REAL(w2f__8) PFFACMOM
      REAL(w2f__8) PHIEULER
      REAL(w2f__8) PHIREF(1 : 31)
      LOGICAL(w2f__i4) PICKUPSTRICTLYMATCH
      CHARACTER(10) PICKUPSUFF
      LOGICAL(w2f__i4) PICKUP_READ_MDSIO
      LOGICAL(w2f__i4) PICKUP_WRITE_IMMED
      LOGICAL(w2f__i4) PICKUP_WRITE_MDSIO
      CHARACTER(512) PLOADFILE
      REAL(w2f__8) PSIEULER
      CHARACTER(512) PSURFINITFILE
      LOGICAL(w2f__i4) QUASIHYDROSTATIC
      REAL(w2f__8) RCD
      INTEGER(w2f__i4) READBINARYPREC
      REAL(w2f__8) RECIP_CP
      REAL(w2f__8) RECIP_GRAVITY
      REAL(w2f__8) RECIP_RHOCONST
      REAL(w2f__8) RECIP_RHOFACC(1 : 15)
      REAL(w2f__8) RECIP_RHOFACF(1 : 16)
      REAL(w2f__8) RECIP_RHONIL
      REAL(w2f__8) RECIP_RSPHERE
      REAL(w2f__8) RHO1REF(1 : 15)
      REAL(w2f__8) RHOCONST
      REAL(w2f__8) RHOCONSTFRESH
      REAL(w2f__8) RHOFACC(1 : 15)
      REAL(w2f__8) RHOFACF(1 : 16)
      REAL(w2f__8) RHONIL
      CHARACTER(512) RHOREFFILE
      LOGICAL(w2f__i4) RIGIDLID
      LOGICAL(w2f__i4) ROTATEGRID
      REAL(w2f__8) ROTATIONPERIOD
      REAL(w2f__8) RO_SEALEVEL
      REAL(w2f__8) RSPHERE
      REAL(w2f__8) RUNIT2MASS
      REAL(w2f__8) RVEL2WUNIT(1 : 16)
      LOGICAL(w2f__i4) SALTADVECTION
      INTEGER(w2f__i4) SALTADVSCHEME
      CHARACTER(512) SALTCLIMFILE
      CHARACTER(512) SALTFLUXFILE
      LOGICAL(w2f__i4) SALTFORCING
      LOGICAL(w2f__i4) SALTIMPLVERTADV
      LOGICAL(w2f__i4) SALTISACTIVETR
      LOGICAL(w2f__i4) SALTSTEPPING
      INTEGER(w2f__i4) SALTVERTADVSCHEME
      REAL(w2f__8) SALT_EVPRRN
      INTEGER(w2f__i4) SELECTADDFLUID
      INTEGER(w2f__i4) SELECTFINDROSURF
      INTEGER(w2f__i4) SELECTKESCHEME
      INTEGER(w2f__i4) SELECTVORTSCHEME
      INTEGER(w2f__i4) SELECT_RSTAR
      LOGICAL(w2f__i4) SETCENTERDR
      LOGICAL(w2f__i4) SETINTERFDR
      REAL(w2f__8) SIDEDRAGFACTOR
      REAL(w2f__8) SMOOTHABSFUNCRANGE
      LOGICAL(w2f__i4) SNAPSHOT_MDSIO
      REAL(w2f__8) SREF(1 : 15)
      CHARACTER(512) SREFFILE
      LOGICAL(w2f__i4) STAGGERTIMESTEP
      LOGICAL(w2f__i4) STARTFROMPICKUPAB2
      REAL(w2f__8) STARTTIME
      CHARACTER(512) SURFQFILE
      CHARACTER(512) SURFQNETFILE
      CHARACTER(512) SURFQSWFILE
      REAL(w2f__8) TAUCD
      REAL(w2f__8) TAUSALTCLIMRELAX
      REAL(w2f__8) TAUTHETACLIMRELAX
      REAL(w2f__8) TAVEFREQ
      REAL(w2f__8) TAVE_LASTITER
      REAL(w2f__8) TCYLIN
      REAL(w2f__8) TCYLOUT
      LOGICAL(w2f__i4) TEMPADVECTION
      INTEGER(w2f__i4) TEMPADVSCHEME
      LOGICAL(w2f__i4) TEMPFORCING
      LOGICAL(w2f__i4) TEMPIMPLVERTADV
      LOGICAL(w2f__i4) TEMPISACTIVETR
      LOGICAL(w2f__i4) TEMPSTEPPING
      INTEGER(w2f__i4) TEMPVERTADVSCHEME
      REAL(w2f__8) TEMP_EVPRRN
      CHARACTER(512) THETACLIMFILE
      REAL(w2f__8) THETAEULER
      CHARACTER(100) THE_RUN_NAME
      LOGICAL(w2f__i4) TIMEAVE_MDSIO
      CHARACTER(512) TOPOFILE
      INTEGER(w2f__i4) TRACFORCINGOUTAB
      REAL(w2f__8) TREF(1 : 15)
      CHARACTER(512) TREFFILE
      LOGICAL(w2f__i4) UNIFORMLIN_PHISURF
      LOGICAL(w2f__i4) UPWINDSHEAR
      LOGICAL(w2f__i4) UPWINDVORTICITY
      LOGICAL(w2f__i4) USE3DCORIOLIS
      LOGICAL(w2f__i4) USE3DSOLVER
      LOGICAL(w2f__i4) USEABSVORTICITY
      LOGICAL(w2f__i4) USEAIM
      LOGICAL(w2f__i4) USEAREAVISCLENGTH
      LOGICAL(w2f__i4) USEATM2D
      LOGICAL(w2f__i4) USEBETAPLANEF
      LOGICAL(w2f__i4) USEBULKFORCE
      LOGICAL(w2f__i4) USECAL
      LOGICAL(w2f__i4) USECDSCHEME
      LOGICAL(w2f__i4) USECHEAPAML
      LOGICAL(w2f__i4) USECONSTANTF
      LOGICAL(w2f__i4) USECORIOLIS
      LOGICAL(w2f__i4) USEDIAGNOSTICS
      LOGICAL(w2f__i4) USEDOWN_SLOPE
      LOGICAL(w2f__i4) USEDYNP_INEOS_ZC
      LOGICAL(w2f__i4) USEEBM
      LOGICAL(w2f__i4) USEECCO
      LOGICAL(w2f__i4) USEEMBED_FILES
      LOGICAL(w2f__i4) USEENERGYCONSERVINGCORIOLIS
      LOGICAL(w2f__i4) USEEXF
      LOGICAL(w2f__i4) USEFIZHI
      LOGICAL(w2f__i4) USEFLT
      LOGICAL(w2f__i4) USEFULLLEITH
      LOGICAL(w2f__i4) USEGAD
      LOGICAL(w2f__i4) USEGCHEM
      LOGICAL(w2f__i4) USEGGL90
      LOGICAL(w2f__i4) USEGMREDI
      LOGICAL(w2f__i4) USEGRDCHK
      LOGICAL(w2f__i4) USEGRIDALT
      LOGICAL(w2f__i4) USEJAMARTMOMADV
      LOGICAL(w2f__i4) USEJAMARTWETPOINTS
      LOGICAL(w2f__i4) USEKPP
      LOGICAL(w2f__i4) USELAND
      LOGICAL(w2f__i4) USEMATRIX
      LOGICAL(w2f__i4) USEMNC
      LOGICAL(w2f__i4) USEMULTIDIMADVEC
      LOGICAL(w2f__i4) USEMY82
      LOGICAL(w2f__i4) USEMYPACKAGE
      LOGICAL(w2f__i4) USENHMTERMS
      LOGICAL(w2f__i4) USEOBCS
      LOGICAL(w2f__i4) USEOFFLINE
      LOGICAL(w2f__i4) USEOLDFREEZING
      LOGICAL(w2f__i4) USEOPPS
      LOGICAL(w2f__i4) USEPICKUPBEFOREC54
      LOGICAL(w2f__i4) USEPP81
      LOGICAL(w2f__i4) USEPTRACERS
      LOGICAL(w2f__i4) USERBCS
      LOGICAL(w2f__i4) USEREALFRESHWATERFLUX
      LOGICAL(w2f__i4) USEREGRID
      LOGICAL(w2f__i4) USERUNCLOCK
      LOGICAL(w2f__i4) USESALT_PLUME
      LOGICAL(w2f__i4) USESBO
      LOGICAL(w2f__i4) USESEAICE
      LOGICAL(w2f__i4) USESHAP_FILT
      LOGICAL(w2f__i4) USESHELFICE
      LOGICAL(w2f__i4) USESINGLECPUIO
      LOGICAL(w2f__i4) USESPHEREF
      LOGICAL(w2f__i4) USESTRAINTENSIONVISC
      LOGICAL(w2f__i4) USETHSICE
      LOGICAL(w2f__i4) USEZONAL_FILT
      LOGICAL(w2f__i4) USINGCARTESIANGRID
      LOGICAL(w2f__i4) USINGCURVILINEARGRID
      LOGICAL(w2f__i4) USINGCYLINDRICALGRID
      LOGICAL(w2f__i4) USINGPCOORDS
      LOGICAL(w2f__i4) USINGSPHERICALPOLARGRID
      LOGICAL(w2f__i4) USINGZCOORDS
      CHARACTER(512) UVELINITFILE
      LOGICAL(w2f__i4) VECTORINVARIANTMOMENTUM
      REAL(w2f__8) VFFACMOM
      REAL(w2f__8) VISCA4
      REAL(w2f__8) VISCA4D
      REAL(w2f__8) VISCA4GRID
      REAL(w2f__8) VISCA4GRIDMAX
      REAL(w2f__8) VISCA4GRIDMIN
      REAL(w2f__8) VISCA4MAX
      REAL(w2f__8) VISCA4REMAX
      REAL(w2f__8) VISCA4W
      REAL(w2f__8) VISCA4Z
      REAL(w2f__8) VISCAH
      REAL(w2f__8) VISCAHD
      REAL(w2f__8) VISCAHGRID
      REAL(w2f__8) VISCAHGRIDMAX
      REAL(w2f__8) VISCAHGRIDMIN
      REAL(w2f__8) VISCAHMAX
      REAL(w2f__8) VISCAHREMAX
      REAL(w2f__8) VISCAHW
      REAL(w2f__8) VISCAHZ
      REAL(w2f__8) VISCAR
      REAL(w2f__8) VISCC2LEITH
      REAL(w2f__8) VISCC2LEITHD
      REAL(w2f__8) VISCC2SMAG
      REAL(w2f__8) VISCC4LEITH
      REAL(w2f__8) VISCC4LEITHD
      REAL(w2f__8) VISCC4SMAG
      CHARACTER(512) VVELINITFILE
      INTEGER(w2f__i4) WRITEBINARYPREC
      LOGICAL(w2f__i4) WRITEPICKUPATEND
      INTEGER(w2f__i4) WRITESTATEPREC
      REAL(w2f__8) WUNIT2RVEL(1 : 16)
      REAL(w2f__8) XGORIGIN
      REAL(w2f__8) YGORIGIN
      CHARACTER(512) ZONALWINDFILE
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DEG2RAD
      PARAMETER ( DEG2RAD = 1.74532925199432954744D-02)
      REAL(w2f__8) PI
      PARAMETER ( PI = 3.141592653589793116D00)
C
C     **** Statements ****
C
      END MODULE

      MODULE bar2_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      LOGICAL(w2f__i4) BAR2COLLECTSTATISTICS
      INTEGER(w2f__i4) BAR2_BARRIERCOUNT(1 : 64, 1 : 4)
      INTEGER(w2f__i4) BAR2_LEVEL(1 : 64, 1 : 4)
      INTEGER(w2f__i4) BAR2_SPINSCOUNT(1 : 64, 1 : 4)
      INTEGER(w2f__i4) BAR2_SPINSMAX(1 : 64, 1 : 4)
      INTEGER(w2f__i4) BAR2_SPINSMIN(1 : 64, 1 : 4)
C
C     **** Statements ****
C
      END MODULE

      MODULE barrier_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) BCOUNT(1 : 4)
      INTEGER(w2f__i4) DOOR1
      INTEGER(w2f__i4) DOOR2
      INTEGER(w2f__i4) DOOR3
      INTEGER(w2f__i4) KEY1(1 : 64, 1 : 4)
      INTEGER(w2f__i4) KEY2(1 : 64, 1 : 4)
      INTEGER(w2f__i4) KEY3(1 : 64, 1 : 4)
      INTEGER(w2f__i4) MASTERSET(1 : 4)
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) INVALID
      PARAMETER ( INVALID = 0)
      INTEGER(w2f__i4) OPEN
      PARAMETER ( OPEN = 1)
      INTEGER(w2f__i4) SHUT
      PARAMETER ( SHUT = 0)
      INTEGER(w2f__i4) VALID
      PARAMETER ( VALID = 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE cd_code_vars_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) ETANM1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) UNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) UVELD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VVELD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE cg2d_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) AC2D(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) AS2D(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) AW2D(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) CG2DNORM
      LOGICAL(w2f__i4) CG2DNORMALISERHS
      REAL(w2f__8) CG2DTOLERANCE
      REAL(w2f__8) CG2D_Q(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) CG2D_R(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) CG2D_S(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) PC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) PS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) PW(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE cg3d_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Statements ****
C
      END MODULE

      MODULE cost_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) CMEANTHETA(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) CMEANTHETAUVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 :
     >  1)
      REAL(w2f__8) CMEANTHETAVVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 :
     >  1)
      REAL(w2f__8) CMEANUVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) CMEANVVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) FC
      INTEGER(w2f__i4) ILOCOUT
      INTEGER(w2f__i4) JLOCOUT
      INTEGER(w2f__i4) KLOCOUT
      REAL(w2f__8) LASTINTERVAL
      REAL(w2f__8) MULTETAN
      REAL(w2f__8) MULTSALT
      REAL(w2f__8) MULTTHETA
      REAL(w2f__8) MULTUVEL
      REAL(w2f__8) MULTVVEL
      REAL(w2f__8) MULT_ATL
      REAL(w2f__8) MULT_EFLUX
      REAL(w2f__8) MULT_ENTROPY
      REAL(w2f__8) MULT_HFLUX_TUT
      REAL(w2f__8) MULT_TEMP_TUT
      REAL(w2f__8) MULT_TEST
      REAL(w2f__8) MULT_TRACER
      REAL(w2f__8) MULT_T_MISFIT
      REAL(w2f__8) OBJF_ATL(1 : 1, 1 : 1)
      REAL(w2f__8) OBJF_EFLUX(1 : 1, 1 : 1)
      REAL(w2f__8) OBJF_ENTROPY(1 : 1, 1 : 1)
      REAL(w2f__8) OBJF_HFLUX_TUT(1 : 1, 1 : 1)
      REAL(w2f__8) OBJF_TEMP_TUT(1 : 1, 1 : 1)
      REAL(w2f__8) OBJF_TEST(1 : 1, 1 : 1)
      REAL(w2f__8) OBJF_TRACER(1 : 1, 1 : 1)
      REAL(w2f__8) OBJF_T_MISFIT(1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE ctrl_dummy_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) XX_APRESSURE_DUMMY
      REAL(w2f__8) XX_APRESSURE_MEAN_DUMMY
      REAL(w2f__8) XX_AQH_DUMMY
      REAL(w2f__8) XX_AQH_MEAN_DUMMY
      REAL(w2f__8) XX_ATEMP_DUMMY
      REAL(w2f__8) XX_ATEMP_MEAN_DUMMY
      REAL(w2f__8) XX_BOTTOMDRAG_DUMMY
      REAL(w2f__8) XX_BPBAR_MEAN_DUMMY
      REAL(w2f__8) XX_DEPTH_DUMMY
      REAL(w2f__8) XX_DIFFKR_DUMMY
      REAL(w2f__8) XX_EDTAUX_DUMMY
      REAL(w2f__8) XX_EDTAUY_DUMMY
      REAL(w2f__8) XX_EFLUXP_DUMMY
      REAL(w2f__8) XX_EFLUXY_DUMMY
      REAL(w2f__8) XX_ETAN_DUMMY
      REAL(w2f__8) XX_EVAP_DUMMY
      REAL(w2f__8) XX_EVAP_MEAN_DUMMY
      REAL(w2f__8) XX_HFLUXM_DUMMY
      REAL(w2f__8) XX_HFLUX_DUMMY
      REAL(w2f__8) XX_HFLUX_MEAN_DUMMY
      REAL(w2f__8) XX_KAPGM_DUMMY
      REAL(w2f__8) XX_KAPREDI_DUMMY
      REAL(w2f__8) XX_LWDOWN_DUMMY
      REAL(w2f__8) XX_LWDOWN_MEAN_DUMMY
      REAL(w2f__8) XX_LWFLUX_DUMMY
      REAL(w2f__8) XX_LWFLUX_MEAN_DUMMY
      REAL(w2f__8) XX_OBCSE_DUMMY
      REAL(w2f__8) XX_OBCSN_DUMMY
      REAL(w2f__8) XX_OBCSS_DUMMY
      REAL(w2f__8) XX_OBCSW_DUMMY
      REAL(w2f__8) XX_PRECIP_DUMMY
      REAL(w2f__8) XX_PRECIP_MEAN_DUMMY
      REAL(w2f__8) XX_PSBAR_MEAN_DUMMY
      REAL(w2f__8) XX_RELAXSSS_DUMMY
      REAL(w2f__8) XX_RELAXSST_DUMMY
      REAL(w2f__8) XX_RUNOFF_DUMMY
      REAL(w2f__8) XX_RUNOFF_MEAN_DUMMY
      REAL(w2f__8) XX_SALT_DUMMY
      REAL(w2f__8) XX_SALT_INI_FIN_DUMMY
      REAL(w2f__8) XX_SBAR_MEAN_DUMMY
      REAL(w2f__8) XX_SFLUX_DUMMY
      REAL(w2f__8) XX_SFLUX_MEAN_DUMMY
      REAL(w2f__8) XX_SIAREA_DUMMY
      REAL(w2f__8) XX_SIHEFF_DUMMY
      REAL(w2f__8) XX_SIHSNOW_DUMMY
      REAL(w2f__8) XX_SMRAREABAR_MEAN_DUMMY
      REAL(w2f__8) XX_SNOWPRECIP_DUMMY
      REAL(w2f__8) XX_SNOWPRECIP_MEAN_DUMMY
      REAL(w2f__8) XX_SSSBAR_MEAN_DUMMY
      REAL(w2f__8) XX_SSS_DUMMY
      REAL(w2f__8) XX_SSTBAR_MEAN_DUMMY
      REAL(w2f__8) XX_SST_DUMMY
      REAL(w2f__8) XX_SWDOWN_DUMMY
      REAL(w2f__8) XX_SWDOWN_MEAN_DUMMY
      REAL(w2f__8) XX_SWFLUX_DUMMY
      REAL(w2f__8) XX_SWFLUX_MEAN_DUMMY
      REAL(w2f__8) XX_TAUU_DUMMY
      REAL(w2f__8) XX_TAUV_DUMMY
      REAL(w2f__8) XX_TAUX_MEAN_DUMMY
      REAL(w2f__8) XX_TAUY_MEAN_DUMMY
      REAL(w2f__8) XX_TBAR_MEAN_DUMMY
      REAL(w2f__8) XX_THETA_DUMMY
      REAL(w2f__8) XX_THETA_INI_FIN_DUMMY
      REAL(w2f__8) XX_TR1_DUMMY
      REAL(w2f__8) XX_UBAR_MEAN_DUMMY
      REAL(w2f__8) XX_UVEL_DUMMY
      REAL(w2f__8) XX_UWIND_DUMMY
      REAL(w2f__8) XX_UWIND_MEAN_DUMMY
      REAL(w2f__8) XX_VBAR_MEAN_DUMMY
      REAL(w2f__8) XX_VVEL_DUMMY
      REAL(w2f__8) XX_VWIND_DUMMY
      REAL(w2f__8) XX_VWIND_MEAN_DUMMY
      REAL(w2f__8) XX_WBAR_MEAN_DUMMY
C
C     **** Statements ****
C
      END MODULE

      MODULE ctrl_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      CHARACTER(9) COSTNAME
      CHARACTER(9) CTRLNAME
      REAL(w2f__8) DELZEXP
      LOGICAL(w2f__i4) DOADMTLM
      LOGICAL(w2f__i4) DOADMTLMBYPASSAD
      LOGICAL(w2f__i4) DOINITXX
      LOGICAL(w2f__i4) DOMAINPACK
      LOGICAL(w2f__i4) DOMAINUNPACK
      LOGICAL(w2f__i4) DOPACKDIAG
      LOGICAL(w2f__i4) DOSINGLEPRECTAPELEV
      LOGICAL(w2f__i4) DOZSCALEPACK
      LOGICAL(w2f__i4) DOZSCALEUNPACK
      REAL(w2f__8) FILEFC
      INTEGER(w2f__i4) FILEI
      INTEGER(w2f__i4) FILEIG
      INTEGER(w2f__i4) FILEJ
      INTEGER(w2f__i4) FILEJG
      INTEGER(w2f__i4) FILEK
      INTEGER(w2f__i4) FILENCBUFFINDEX
      CHARACTER(1) FILENCVARGRD(1 : 60)
      INTEGER(w2f__i4) FILENCVARINDEX(1 : 60)
      INTEGER(w2f__i4) FILENCVARNRMAX(1 : 60)
      INTEGER(w2f__i4) FILENCVARRECS(1 : 60)
      INTEGER(w2f__i4) FILENCVARXMAX(1 : 60)
      INTEGER(w2f__i4) FILENCVARYMAX(1 : 60)
      INTEGER(w2f__i4) FILENSX
      INTEGER(w2f__i4) FILENSY
      INTEGER(w2f__i4) FILENVARLENGTH
      INTEGER(w2f__i4) FILENVARTYPE
      INTEGER(w2f__i4) FILENWETCGLOBAL(1 : 15)
      INTEGER(w2f__i4) FILENWETSGLOBAL(1 : 15)
      INTEGER(w2f__i4) FILENWETVGLOBAL(1 : 15)
      INTEGER(w2f__i4) FILENWETWGLOBAL(1 : 15)
      INTEGER(w2f__i4) FILEOPTIMCYCLE
      CHARACTER(10) FILEYCTRLID
      CHARACTER(80) FNAME_APRESSURE(1 : 2)
      CHARACTER(80) FNAME_AQH(1 : 2)
      CHARACTER(80) FNAME_ATEMP(1 : 2)
      CHARACTER(80) FNAME_BOTTOMDRAG(1 : 2)
      CHARACTER(80) FNAME_DEPTH(1 : 2)
      CHARACTER(80) FNAME_DIFFKR(1 : 2)
      CHARACTER(80) FNAME_EDTAUX(1 : 2)
      CHARACTER(80) FNAME_EDTAUY(1 : 2)
      CHARACTER(80) FNAME_EFLUXP(1 : 2)
      CHARACTER(80) FNAME_EFLUXY(1 : 2)
      CHARACTER(80) FNAME_ETAN(1 : 2)
      CHARACTER(80) FNAME_EVAP(1 : 2)
      CHARACTER(80) FNAME_HFACC(1 : 2)
      CHARACTER(80) FNAME_HFLUX(1 : 2)
      CHARACTER(80) FNAME_HFLUXM(1 : 2)
      CHARACTER(80) FNAME_KAPGM(1 : 2)
      CHARACTER(80) FNAME_KAPREDI(1 : 2)
      CHARACTER(80) FNAME_LWDOWN(1 : 2)
      CHARACTER(80) FNAME_LWFLUX(1 : 2)
      CHARACTER(80) FNAME_OBCSE(1 : 2)
      CHARACTER(80) FNAME_OBCSN(1 : 2)
      CHARACTER(80) FNAME_OBCSS(1 : 2)
      CHARACTER(80) FNAME_OBCSW(1 : 2)
      CHARACTER(80) FNAME_PRECIP(1 : 2)
      CHARACTER(80) FNAME_RELAXSSS(1 : 2)
      CHARACTER(80) FNAME_RELAXSST(1 : 2)
      CHARACTER(80) FNAME_RUNOFF(1 : 2)
      CHARACTER(80) FNAME_SALT(1 : 2)
      CHARACTER(80) FNAME_SFLUX(1 : 2)
      CHARACTER(80) FNAME_SIAREA(1 : 2)
      CHARACTER(80) FNAME_SIHEFF(1 : 2)
      CHARACTER(80) FNAME_SIHSNOW(1 : 2)
      CHARACTER(80) FNAME_SNOWPRECIP(1 : 2)
      CHARACTER(80) FNAME_SSS(1 : 2)
      CHARACTER(80) FNAME_SST(1 : 2)
      CHARACTER(80) FNAME_SWDOWN(1 : 2)
      CHARACTER(80) FNAME_SWFLUX(1 : 2)
      CHARACTER(80) FNAME_TAUU(1 : 2)
      CHARACTER(80) FNAME_TAUV(1 : 2)
      CHARACTER(80) FNAME_THETA(1 : 2)
      CHARACTER(80) FNAME_TR1(1 : 2)
      CHARACTER(80) FNAME_UVEL(1 : 2)
      CHARACTER(80) FNAME_UWIND(1 : 2)
      CHARACTER(80) FNAME_VVEL(1 : 2)
      CHARACTER(80) FNAME_VWIND(1 : 2)
      REAL(w2f__8) FORCINGPRECOND
      CHARACTER(9) MASKNAME
      CHARACTER(9) METANAME
      INTEGER(w2f__i4) NBUFFGLOBAL
      CHARACTER(1) NCVARGRD(1 : 60)
      INTEGER(w2f__i4) NCVARINDEX(1 : 60)
      INTEGER(w2f__i4) NCVARNRMAX(1 : 60)
      INTEGER(w2f__i4) NCVARRECS(1 : 60)
      INTEGER(w2f__i4) NCVARRECSEND(1 : 60)
      INTEGER(w2f__i4) NCVARRECSTART(1 : 60)
      INTEGER(w2f__i4) NCVARXMAX(1 : 60)
      INTEGER(w2f__i4) NCVARYMAX(1 : 60)
      INTEGER(w2f__i4) NVARLENGTH
      INTEGER(w2f__i4) NVARTYPE
      INTEGER(w2f__i4) NWETCGLOBAL(1 : 15)
      INTEGER(w2f__i4) NWETCTILE(1 : 1, 1 : 1, 1 : 15)
      INTEGER(w2f__i4) NWETSGLOBAL(1 : 15)
      INTEGER(w2f__i4) NWETSTILE(1 : 1, 1 : 1, 1 : 15)
      INTEGER(w2f__i4) NWETVGLOBAL(1 : 15)
      INTEGER(w2f__i4) NWETVTILE(1 : 1, 1 : 1, 1 : 15)
      INTEGER(w2f__i4) NWETWGLOBAL(1 : 15)
      INTEGER(w2f__i4) NWETWTILE(1 : 1, 1 : 1, 1 : 15)
      CHARACTER(9) SCALNAME
      REAL(w2f__8) TMPFLD2D(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TMPFLD3D(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WAPRESSURE(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WAQH(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WAREAUNIT(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WATEMP(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WBP(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WEVAP(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WHFLUX(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WLWDOWN(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WLWFLUX(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WPRECIP(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WRUNOFF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WSFLUX(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WSNOWPRECIP(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WSSS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WSST(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WSWDOWN(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WSWFLUX(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WTAUU(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WTAUV(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WUNIT(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WUWIND(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) WVWIND(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) XX_APRESSUREPERIOD
      INTEGER(w2f__i4) XX_APRESSURESTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_APRESSURESTARTDATE1
      INTEGER(w2f__i4) XX_APRESSURESTARTDATE2
      CHARACTER(512) XX_APRESSURE_FILE
      REAL(w2f__8) XX_APRESSURE_REMO_INTERCEPT
      REAL(w2f__8) XX_APRESSURE_REMO_SLOPE
      REAL(w2f__8) XX_AQHPERIOD
      INTEGER(w2f__i4) XX_AQHSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_AQHSTARTDATE1
      INTEGER(w2f__i4) XX_AQHSTARTDATE2
      CHARACTER(512) XX_AQH_FILE
      REAL(w2f__8) XX_AQH_REMO_INTERCEPT
      REAL(w2f__8) XX_AQH_REMO_SLOPE
      REAL(w2f__8) XX_ATEMPPERIOD
      INTEGER(w2f__i4) XX_ATEMPSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_ATEMPSTARTDATE1
      INTEGER(w2f__i4) XX_ATEMPSTARTDATE2
      CHARACTER(512) XX_ATEMP_FILE
      REAL(w2f__8) XX_ATEMP_REMO_INTERCEPT
      REAL(w2f__8) XX_ATEMP_REMO_SLOPE
      CHARACTER(512) XX_BOTTOMDRAG_FILE
      CHARACTER(512) XX_DEPTH_FILE
      CHARACTER(512) XX_DIFFKR_FILE
      CHARACTER(512) XX_EDTAUX_FILE
      CHARACTER(512) XX_EDTAUY_FILE
      CHARACTER(512) XX_EFLUXP_FILE
      CHARACTER(512) XX_EFLUXY_FILE
      REAL(w2f__8) XX_ETAN(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      CHARACTER(512) XX_ETAN_FILE
      REAL(w2f__8) XX_EVAPPERIOD
      INTEGER(w2f__i4) XX_EVAPSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_EVAPSTARTDATE1
      INTEGER(w2f__i4) XX_EVAPSTARTDATE2
      CHARACTER(512) XX_EVAP_FILE
      REAL(w2f__8) XX_EVAP_REMO_INTERCEPT
      REAL(w2f__8) XX_EVAP_REMO_SLOPE
      CHARACTER(512) XX_HFLUXM_FILE
      REAL(w2f__8) XX_HFLUXPERIOD
      INTEGER(w2f__i4) XX_HFLUXSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_HFLUXSTARTDATE1
      INTEGER(w2f__i4) XX_HFLUXSTARTDATE2
      CHARACTER(512) XX_HFLUX_FILE
      REAL(w2f__8) XX_HFLUX_REMO_INTERCEPT
      REAL(w2f__8) XX_HFLUX_REMO_SLOPE
      CHARACTER(512) XX_KAPGM_FILE
      CHARACTER(512) XX_KAPREDI_FILE
      REAL(w2f__8) XX_LWDOWNPERIOD
      INTEGER(w2f__i4) XX_LWDOWNSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_LWDOWNSTARTDATE1
      INTEGER(w2f__i4) XX_LWDOWNSTARTDATE2
      CHARACTER(512) XX_LWDOWN_FILE
      REAL(w2f__8) XX_LWDOWN_REMO_INTERCEPT
      REAL(w2f__8) XX_LWDOWN_REMO_SLOPE
      REAL(w2f__8) XX_LWFLUXPERIOD
      INTEGER(w2f__i4) XX_LWFLUXSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_LWFLUXSTARTDATE1
      INTEGER(w2f__i4) XX_LWFLUXSTARTDATE2
      CHARACTER(512) XX_LWFLUX_FILE
      REAL(w2f__8) XX_LWFLUX_REMO_INTERCEPT
      REAL(w2f__8) XX_LWFLUX_REMO_SLOPE
      REAL(w2f__8) XX_OBCSEPERIOD
      INTEGER(w2f__i4) XX_OBCSESTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_OBCSESTARTDATE1
      INTEGER(w2f__i4) XX_OBCSESTARTDATE2
      CHARACTER(512) XX_OBCSE_FILE
      REAL(w2f__8) XX_OBCSNPERIOD
      INTEGER(w2f__i4) XX_OBCSNSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_OBCSNSTARTDATE1
      INTEGER(w2f__i4) XX_OBCSNSTARTDATE2
      CHARACTER(512) XX_OBCSN_FILE
      REAL(w2f__8) XX_OBCSSPERIOD
      INTEGER(w2f__i4) XX_OBCSSSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_OBCSSSTARTDATE1
      INTEGER(w2f__i4) XX_OBCSSSTARTDATE2
      CHARACTER(512) XX_OBCSS_FILE
      REAL(w2f__8) XX_OBCSWPERIOD
      INTEGER(w2f__i4) XX_OBCSWSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_OBCSWSTARTDATE1
      INTEGER(w2f__i4) XX_OBCSWSTARTDATE2
      CHARACTER(512) XX_OBCSW_FILE
      REAL(w2f__8) XX_PRECIPPERIOD
      INTEGER(w2f__i4) XX_PRECIPSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_PRECIPSTARTDATE1
      INTEGER(w2f__i4) XX_PRECIPSTARTDATE2
      CHARACTER(512) XX_PRECIP_FILE
      REAL(w2f__8) XX_PRECIP_REMO_INTERCEPT
      REAL(w2f__8) XX_PRECIP_REMO_SLOPE
      CHARACTER(512) XX_RELAXSSS_FILE
      CHARACTER(512) XX_RELAXSST_FILE
      REAL(w2f__8) XX_RUNOFFPERIOD
      INTEGER(w2f__i4) XX_RUNOFFSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_RUNOFFSTARTDATE1
      INTEGER(w2f__i4) XX_RUNOFFSTARTDATE2
      CHARACTER(512) XX_RUNOFF_FILE
      REAL(w2f__8) XX_RUNOFF_REMO_INTERCEPT
      REAL(w2f__8) XX_RUNOFF_REMO_SLOPE
      REAL(w2f__8) XX_SALT(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      CHARACTER(512) XX_SALT_FILE
      CHARACTER(512) XX_SALT_INI_FIN_FILE
      REAL(w2f__8) XX_SFLUXPERIOD
      INTEGER(w2f__i4) XX_SFLUXSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_SFLUXSTARTDATE1
      INTEGER(w2f__i4) XX_SFLUXSTARTDATE2
      CHARACTER(512) XX_SFLUX_FILE
      REAL(w2f__8) XX_SFLUX_REMO_INTERCEPT
      REAL(w2f__8) XX_SFLUX_REMO_SLOPE
      CHARACTER(512) XX_SIAREA_FILE
      CHARACTER(512) XX_SIHEFF_FILE
      CHARACTER(512) XX_SIHSNOW_FILE
      REAL(w2f__8) XX_SNOWPRECIPPERIOD
      INTEGER(w2f__i4) XX_SNOWPRECIPSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_SNOWPRECIPSTARTDATE1
      INTEGER(w2f__i4) XX_SNOWPRECIPSTARTDATE2
      CHARACTER(512) XX_SNOWPRECIP_FILE
      REAL(w2f__8) XX_SNOWPRECIP_REMO_INTERCEPT
      REAL(w2f__8) XX_SNOWPRECIP_REMO_SLOPE
      REAL(w2f__8) XX_SSSPERIOD
      INTEGER(w2f__i4) XX_SSSSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_SSSSTARTDATE1
      INTEGER(w2f__i4) XX_SSSSTARTDATE2
      CHARACTER(512) XX_SSS_FILE
      REAL(w2f__8) XX_SSTPERIOD
      INTEGER(w2f__i4) XX_SSTSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_SSTSTARTDATE1
      INTEGER(w2f__i4) XX_SSTSTARTDATE2
      CHARACTER(512) XX_SST_FILE
      REAL(w2f__8) XX_SWDOWNPERIOD
      INTEGER(w2f__i4) XX_SWDOWNSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_SWDOWNSTARTDATE1
      INTEGER(w2f__i4) XX_SWDOWNSTARTDATE2
      CHARACTER(512) XX_SWDOWN_FILE
      REAL(w2f__8) XX_SWDOWN_REMO_INTERCEPT
      REAL(w2f__8) XX_SWDOWN_REMO_SLOPE
      REAL(w2f__8) XX_SWFLUXPERIOD
      INTEGER(w2f__i4) XX_SWFLUXSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_SWFLUXSTARTDATE1
      INTEGER(w2f__i4) XX_SWFLUXSTARTDATE2
      CHARACTER(512) XX_SWFLUX_FILE
      REAL(w2f__8) XX_SWFLUX_REMO_INTERCEPT
      REAL(w2f__8) XX_SWFLUX_REMO_SLOPE
      REAL(w2f__8) XX_TAUUPERIOD
      INTEGER(w2f__i4) XX_TAUUSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_TAUUSTARTDATE1
      INTEGER(w2f__i4) XX_TAUUSTARTDATE2
      CHARACTER(512) XX_TAUU_FILE
      REAL(w2f__8) XX_TAUU_REMO_INTERCEPT
      REAL(w2f__8) XX_TAUU_REMO_SLOPE
      REAL(w2f__8) XX_TAUVPERIOD
      INTEGER(w2f__i4) XX_TAUVSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_TAUVSTARTDATE1
      INTEGER(w2f__i4) XX_TAUVSTARTDATE2
      CHARACTER(512) XX_TAUV_FILE
      REAL(w2f__8) XX_TAUV_REMO_INTERCEPT
      REAL(w2f__8) XX_TAUV_REMO_SLOPE
      REAL(w2f__8) XX_THETA(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      CHARACTER(512) XX_THETA_FILE
      CHARACTER(512) XX_THETA_INI_FIN_FILE
      CHARACTER(512) XX_TR1_FILE
      REAL(w2f__8) XX_UVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      CHARACTER(512) XX_UVEL_FILE
      REAL(w2f__8) XX_UWINDPERIOD
      INTEGER(w2f__i4) XX_UWINDSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_UWINDSTARTDATE1
      INTEGER(w2f__i4) XX_UWINDSTARTDATE2
      CHARACTER(512) XX_UWIND_FILE
      REAL(w2f__8) XX_UWIND_REMO_INTERCEPT
      REAL(w2f__8) XX_UWIND_REMO_SLOPE
      REAL(w2f__8) XX_VVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      CHARACTER(512) XX_VVEL_FILE
      REAL(w2f__8) XX_VWINDPERIOD
      INTEGER(w2f__i4) XX_VWINDSTARTDATE(1 : 4)
      INTEGER(w2f__i4) XX_VWINDSTARTDATE1
      INTEGER(w2f__i4) XX_VWINDSTARTDATE2
      CHARACTER(512) XX_VWIND_FILE
      REAL(w2f__8) XX_VWIND_REMO_INTERCEPT
      REAL(w2f__8) XX_VWIND_REMO_SLOPE
      CHARACTER(2) YADMARK
      CHARACTER(2) YADPREFIX
      CHARACTER(10) YCTRLID
      CHARACTER(4) YCTRLPOSPACK
      CHARACTER(4) YCTRLPOSUNPACK
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) CTRLPREC
      PARAMETER ( CTRLPREC = 64)
      INTEGER(w2f__i4) MAXCVARS
      PARAMETER ( MAXCVARS = 60)
C
C     **** Statements ****
C
      END MODULE

      MODULE ctrl_weights_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) WDIFFKR(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WEDTAUX(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WEDTAUY(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WETAN(1 : 90, 1 : 40, 1 : 1, 1 : 1)
      REAL(w2f__8) WKAPGM(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WKAPREDI(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WSALT(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WTHETA(1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WUVVEL(1 : 15, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE dfile_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Statements ****
C
      END MODULE

      MODULE dynvars_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) ETAH(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) ETAN(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) GS(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GSNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GT(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GTNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GU(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GUNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GV(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GVNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) HMIXLAYER(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) IVDCONVCOUNT(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) PHIHYDLOW(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RHOINSITU(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) SALT(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) THETA(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) TOTPHIHYD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) UVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE eesupport_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      LOGICAL(w2f__i4) ALLMYEDGESARESHAREDMEMORY(1 : 4)
      CHARACTER(10) COMMNAME(1 : 4)
      INTEGER(w2f__i4) MYPID
      CHARACTER(128) MYPROCESSSTR
      LOGICAL(w2f__i4) NOTUSINGXPERIODICITY
      LOGICAL(w2f__i4) NOTUSINGYPERIODICITY
      INTEGER(w2f__i4) NPROCS
      INTEGER(w2f__i4) PIDE
      INTEGER(w2f__i4) PIDN
      INTEGER(w2f__i4) PIDS
      INTEGER(w2f__i4) PIDW
      LOGICAL(w2f__i4) THERROR(1 : 4)
      LOGICAL(w2f__i4) THREADISCOMPLETE(1 : 4)
      LOGICAL(w2f__i4) THREADISRUNNING(1 : 4)
      INTEGER(w2f__i4) TILEBIE(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEBIN(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEBIS(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEBIW(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEBJE(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEBJN(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEBJS(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEBJW(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILECOMMMODEE(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILECOMMMODEN(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILECOMMMODES(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILECOMMMODEW(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILENO(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILENOE(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILENON(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILENOS(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILENOW(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEPIDE(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEPIDN(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEPIDS(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILEPIDW(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGRECVE(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGRECVN(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGRECVS(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGRECVW(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGSENDE(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGSENDN(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGSENDS(1 : 1, 1 : 1)
      INTEGER(w2f__i4) TILETAGSENDW(1 : 1, 1 : 1)
      LOGICAL(w2f__i4) USINGMPI
      LOGICAL(w2f__i4) USINGSYNCMESSAGES
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) COMM_GET
      PARAMETER ( COMM_GET = 4)
      INTEGER(w2f__i4) COMM_MSG
      PARAMETER ( COMM_MSG = 2)
      INTEGER(w2f__i4) COMM_NONE
      PARAMETER ( COMM_NONE = 1)
      INTEGER(w2f__i4) COMM_PUT
      PARAMETER ( COMM_PUT = 3)
      CHARACTER(14) ERROR_HEADER
      PARAMETER ( ERROR_HEADER = ' *** ERROR ***')
      INTEGER(w2f__i4) MAX_NUM_COMM_MODES
      PARAMETER ( MAX_NUM_COMM_MODES = 4)
      INTEGER(w2f__i4) NULL_TILE
      PARAMETER ( NULL_TILE = -1)
      CHARACTER(7) PROCESS_HEADER
      PARAMETER ( PROCESS_HEADER = 'PID.TID')
C
C     **** Statements ****
C
      END MODULE

      MODULE eos_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) EOSC(1 : 9, 1 : 16)
      REAL(w2f__8) EOSJMDCFW(1 : 6)
      REAL(w2f__8) EOSJMDCKFW(1 : 5)
      REAL(w2f__8) EOSJMDCKP(1 : 14)
      REAL(w2f__8) EOSJMDCKSW(1 : 7)
      REAL(w2f__8) EOSJMDCSW(1 : 9)
      REAL(w2f__8) EOSMDJWFDEN(0 : 12)
      REAL(w2f__8) EOSMDJWFNUM(0 : 11)
      REAL(w2f__8) EOSREFS(1 : 16)
      REAL(w2f__8) EOSREFT(1 : 16)
      REAL(w2f__8) EOSSIG0(1 : 16)
      CHARACTER(6) EQUATIONOFSTATE
      REAL(w2f__8) SBETA
      REAL(w2f__8) TALPHA
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) SITOBAR
      PARAMETER ( SITOBAR = 1.0000000000000000818D-05)
      REAL(w2f__8) SITODBAR
      PARAMETER ( SITODBAR = 1.00000000000000004792D-04)
C
C     **** Statements ****
C
      END MODULE

      MODULE exch_jam_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) EXCHBUF1(1 : 4320)
      REAL(w2f__8) EXCHBUF2(1 : 4320)
C
C     **** Statements ****
C
      END MODULE

      MODULE exch_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) EASTRECVACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) EASTRECVBUF_R4(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) EASTRECVBUF_R8(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) EASTRECVBUF_RL(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) EASTRECVBUF_RS(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EASTSENDACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) EASTSENDBUF_R4(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) EASTSENDBUF_R8(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) EASTSENDBUF_RL(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) EASTSENDBUF_RS(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHANGEBUFLEVEL(1 : 64, 1 : 1, 1 : 1)
      LOGICAL(w2f__i4) EXCHCOLLECTSTATISTICS
      LOGICAL(w2f__i4) EXCHNEEDSMEMSYNC
      INTEGER(w2f__i4) EXCHNREQSX(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHNREQSY(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVXEXCHCOUNT(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVXSPINCOUNT(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVXSPINMAX(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVXSPINMIN(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVYEXCHCOUNT(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVYSPINCOUNT(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVYSPINMAX(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHRECVYSPINMIN(1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHREQIDX(1 : 4, 1 : 64, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) EXCHREQIDY(1 : 4, 1 : 64, 1 : 1, 1 : 1)
      LOGICAL(w2f__i4) EXCHUSESBARRIER
      INTEGER(w2f__i4) NORTHRECVACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) NORTHRECVBUF_R4(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) NORTHRECVBUF_R8(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) NORTHRECVBUF_RL(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) NORTHRECVBUF_RS(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) NORTHSENDACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) NORTHSENDBUF_R4(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) NORTHSENDBUF_R8(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) NORTHSENDBUF_RL(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) NORTHSENDBUF_RS(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) SOUTHRECVACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) SOUTHRECVBUF_R4(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) SOUTHRECVBUF_R8(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) SOUTHRECVBUF_RL(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) SOUTHRECVBUF_RS(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) SOUTHSENDACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) SOUTHSENDBUF_R4(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) SOUTHSENDBUF_R8(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) SOUTHSENDBUF_RL(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) SOUTHSENDBUF_RS(1 : 4608, 1 : 1, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) WESTRECVACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) WESTRECVBUF_R4(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) WESTRECVBUF_R8(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) WESTRECVBUF_RL(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) WESTRECVBUF_RS(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) WESTSENDACK(1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__4) WESTSENDBUF_R4(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) WESTSENDBUF_R8(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) WESTSENDBUF_RL(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
      REAL(w2f__8) WESTSENDBUF_RS(1 : 2208, 1 : 1, 1 : 1, 1 : 1)
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) EXCH_SPIN_LIMIT
      PARAMETER ( EXCH_SPIN_LIMIT = 100000000)
      INTEGER(w2f__i4) L_BUFFERX
      PARAMETER ( L_BUFFERX = 2208)
      INTEGER(w2f__i4) L_BUFFERY
      PARAMETER ( L_BUFFERY = 4608)
      INTEGER(w2f__i4) L_EBUFFER
      PARAMETER ( L_EBUFFER = 2208)
      INTEGER(w2f__i4) L_NBUFFER
      PARAMETER ( L_NBUFFER = 4608)
      INTEGER(w2f__i4) L_SBUFFER
      PARAMETER ( L_SBUFFER = 4608)
      INTEGER(w2f__i4) L_WBUFFER
      PARAMETER ( L_WBUFFER = 2208)
      INTEGER(w2f__i4) MAX_NR_EXCH
      PARAMETER ( MAX_NR_EXCH = 16)
      INTEGER(w2f__i4) MAX_OLX_EXCH
      PARAMETER ( MAX_OLX_EXCH = 3)
      INTEGER(w2f__i4) MAX_OLY_EXCH
      PARAMETER ( MAX_OLY_EXCH = 3)
      INTEGER(w2f__i4) NUMBER_OF_BUFFER_LEVELS
      PARAMETER ( NUMBER_OF_BUFFER_LEVELS = 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE fc_namemangle_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Statements ****
C
      END MODULE

      MODULE ffields_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) DQDT(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) EMPMR(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) EMPMR0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) EMPMR1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) FU(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) FV(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) LAMBDASALTCLIMRELAX(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) LAMBDATHETACLIMRELAX(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) PLOAD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) QNET(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) QNET0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) QNET1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) QSW(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SALTFLUX(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SALTFLUX0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SALTFLUX1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SICELOAD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SSS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SSS0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SSS1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SST(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SST0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SST1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SURFACEFORCINGS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SURFACEFORCINGT(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SURFACEFORCINGTICE(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SURFACEFORCINGU(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SURFACEFORCINGV(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TAUX0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TAUX1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TAUY0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TAUY1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE gad_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      LOGICAL(w2f__i4) ADAMSBASHFORTHGS
      LOGICAL(w2f__i4) ADAMSBASHFORTHGT
      LOGICAL(w2f__i4) ADAMSBASHFORTH_S
      LOGICAL(w2f__i4) ADAMSBASHFORTH_T
      LOGICAL(w2f__i4) SALTMULTIDIMADVEC
      LOGICAL(w2f__i4) SALTSOM_ADVECTION
      CHARACTER(2) SOMSFX(1 : 9)
      LOGICAL(w2f__i4) TEMPMULTIDIMADVEC
      LOGICAL(w2f__i4) TEMPSOM_ADVECTION
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) ENUM_CENTERED_2ND
      PARAMETER ( ENUM_CENTERED_2ND = 2)
      INTEGER(w2f__i4) ENUM_CENTERED_4TH
      PARAMETER ( ENUM_CENTERED_4TH = 4)
      INTEGER(w2f__i4) ENUM_DST2
      PARAMETER ( ENUM_DST2 = 20)
      INTEGER(w2f__i4) ENUM_DST3
      PARAMETER ( ENUM_DST3 = 30)
      INTEGER(w2f__i4) ENUM_DST3_FLUX_LIMIT
      PARAMETER ( ENUM_DST3_FLUX_LIMIT = 33)
      INTEGER(w2f__i4) ENUM_FLUX_LIMIT
      PARAMETER ( ENUM_FLUX_LIMIT = 77)
      INTEGER(w2f__i4) ENUM_OS7MP
      PARAMETER ( ENUM_OS7MP = 7)
      INTEGER(w2f__i4) ENUM_SOM_LIMITER
      PARAMETER ( ENUM_SOM_LIMITER = 81)
      INTEGER(w2f__i4) ENUM_SOM_PRATHER
      PARAMETER ( ENUM_SOM_PRATHER = 80)
      INTEGER(w2f__i4) ENUM_UPWIND_1RST
      PARAMETER ( ENUM_UPWIND_1RST = 1)
      INTEGER(w2f__i4) ENUM_UPWIND_3RD
      PARAMETER ( ENUM_UPWIND_3RD = 3)
      INTEGER(w2f__i4) GAD_SALINITY
      PARAMETER ( GAD_SALINITY = 2)
      INTEGER(w2f__i4) GAD_TEMPERATURE
      PARAMETER ( GAD_TEMPERATURE = 1)
      INTEGER(w2f__i4) GAD_TR1
      PARAMETER ( GAD_TR1 = 3)
      INTEGER(w2f__i4) IMAXADVR
      PARAMETER ( IMAXADVR = 90)
      INTEGER(w2f__i4) IMINADVR
      PARAMETER ( IMINADVR = 1)
      INTEGER(w2f__i4) JMAXADVR
      PARAMETER ( JMAXADVR = 40)
      INTEGER(w2f__i4) JMINADVR
      PARAMETER ( JMINADVR = 1)
      INTEGER(w2f__i4) NSOM
      PARAMETER ( NSOM = 9)
      REAL(w2f__8) ONESIXTH
      PARAMETER ( ONESIXTH = 1.66666666666666657415D-01)
C
C     **** Statements ****
C
      END MODULE

      MODULE g_cost_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) G_FC
C
C     **** Statements ****
C
      END MODULE

      MODULE global_max_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) PHIGMI(1 : 64, 1 : 4)
      REAL(w2f__8) PHIGMRL(1 : 32, 1 : 4)
      REAL(w2f__4) PHIGMRS(1 : 64, 1 : 4)
C
C     **** Statements ****
C
      END MODULE

      MODULE global_sum_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) PHIGSI(1 : 64, 1 : 4)
      REAL(w2f__8) PHIGSRL(1 : 32, 1 : 4)
      REAL(w2f__4) PHIGSRS(1 : 64, 1 : 4)
      REAL(w2f__8) SHAREBUFGSR8(1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE gmredi_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) GM_ADVECT
      LOGICAL(w2f__i4) GM_ADVFORM
      LOGICAL(w2f__i4) GM_ADVSEPARATE
      REAL(w2f__8) GM_BACKGROUND_K
      LOGICAL(w2f__i4) GM_EXTRADIAG
      REAL(w2f__8) GM_FACTRL2DZ
      REAL(w2f__8) GM_FACTRL2ML
      LOGICAL(w2f__i4) GM_INMOMASSTRESS
      REAL(w2f__8) GM_ISOPYCK
      REAL(w2f__8) GM_KMIN_HORIZ
      REAL(w2f__8) GM_MAXSLOPE
      REAL(w2f__8) GM_MAXTRANSLAY
      LOGICAL(w2f__i4) GM_MDSIO
      LOGICAL(w2f__i4) GM_MNC
      REAL(w2f__8) GM_PSIX(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GM_PSIY(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GM_RMAXSLOPE
      REAL(w2f__8) GM_SCRIT
      REAL(w2f__8) GM_SD
      REAL(w2f__8) GM_SKEWFLX
      REAL(w2f__8) GM_SLOPESQCUTOFF
      REAL(w2f__8) GM_SMALL_NUMBER
      CHARACTER(40) GM_TAPER_SCHEME
      REAL(w2f__8) GM_VISBECK_ALPHA
      REAL(w2f__8) GM_VISBECK_DEPTH
      REAL(w2f__8) GM_VISBECK_LENGTH
      REAL(w2f__8) GM_VISBECK_MAXSLOPE
      REAL(w2f__8) GM_VISBECK_MAXVAL_K
      REAL(w2f__8) GM_VISBECK_MINDEPTH
      REAL(w2f__8) GM_VISBECK_MINVAL_K
      REAL(w2f__8) KUX(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KUZ(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KVY(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KVZ(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KWX(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KWY(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KWZ(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) OP25
      PARAMETER ( OP25 = 2.5D-01)
      REAL(w2f__8) OP5
      PARAMETER ( OP5 = 5.0D-01)
C
C     **** Statements ****
C
      END MODULE

      MODULE gmredi_tave_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Statements ****
C
      END MODULE

      MODULE grdchk_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) ADXXMEM(1 : 4000)
      INTEGER(w2f__i4) BIMEM(1 : 4000)
      INTEGER(w2f__i4) BJMEM(1 : 4000)
      REAL(w2f__8) FCPMMEM(1 : 4000)
      REAL(w2f__8) FCPPMEM(1 : 4000)
      REAL(w2f__8) FCRMEM(1 : 4000)
      REAL(w2f__8) FTLXXMEM(1 : 4000)
      REAL(w2f__8) GFDMEM(1 : 4000)
      INTEGER(w2f__i4) GRDCHKVARINDEX
      INTEGER(w2f__i4) GRDCHKWHICHPROC
      REAL(w2f__8) GRDCHK_EPS
      INTEGER(w2f__i4) ICGLOMEM(1 : 4000)
      INTEGER(w2f__i4) ICHKMEM(1 : 4000)
      INTEGER(w2f__i4) ICOMPMEM(1 : 4000)
      INTEGER(w2f__i4) IDEP
      INTEGER(w2f__i4) IERRMEM(1 : 4000)
      INTEGER(w2f__i4) IGLOPOS
      INTEGER(w2f__i4) IGLOTILE
      INTEGER(w2f__i4) ILOCMEM(1 : 4000)
      INTEGER(w2f__i4) IOBCSMEM(1 : 4000)
      INTEGER(w2f__i4) IRECMEM(1 : 4000)
      INTEGER(w2f__i4) ITESTMEM(1 : 4000)
      INTEGER(w2f__i4) IWETSUM(1 : 1, 1 : 1, 0 : 15)
      INTEGER(w2f__i4) JDEP
      INTEGER(w2f__i4) JGLOPOS
      INTEGER(w2f__i4) JGLOTILE
      INTEGER(w2f__i4) JLOCMEM(1 : 4000)
      INTEGER(w2f__i4) KGLOPOS
      INTEGER(w2f__i4) KLOCMEM(1 : 4000)
      INTEGER(w2f__i4) MAXNCVARCOMPS
      INTEGER(w2f__i4) NBEG
      INTEGER(w2f__i4) NCVARCOMP
      INTEGER(w2f__i4) NEND
      INTEGER(w2f__i4) NSTEP
      INTEGER(w2f__i4) NWETTILE(1 : 1, 1 : 1, 1 : 15, 1 : 4)
      INTEGER(w2f__i4) OBCSGLO
      REAL(w2f__8) RATIOADMEM(1 : 4000)
      REAL(w2f__8) RATIOFTLMEM(1 : 4000)
      INTEGER(w2f__i4) RECGLO
      LOGICAL(w2f__i4) USECENTRALDIFF
      REAL(w2f__8) XXMEMPERT(1 : 4000)
      REAL(w2f__8) XXMEMREF(1 : 4000)
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) MAXGRDCHECKS
      PARAMETER ( MAXGRDCHECKS = 4000)
C
C     **** Statements ****
C
      END MODULE

      MODULE grid_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) ANGLECOSC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) ANGLESINC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) COSFACU(-2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) COSFACV(-2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DEEPFAC2C(1 : 15)
      REAL(w2f__8) DEEPFAC2F(1 : 16)
      REAL(w2f__8) DEEPFACC(1 : 15)
      REAL(w2f__8) DEEPFACF(1 : 16)
      REAL(w2f__8) DRC(1 : 15)
      REAL(w2f__8) DRF(1 : 15)
      REAL(w2f__8) DXC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DXF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DXG(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DXV(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DYC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DYF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DYG(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) DYU(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) FCORI(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) FCORICOS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) FCORIG(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) GLOBALAREA
      REAL(w2f__8) GRAVITYSIGN
      REAL(w2f__8) HFACC(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) HFACS(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) HFACW(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) KLOWC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) KSURFC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) KSURFS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) KSURFW(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) MASKC(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MASKH(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) MASKS(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MASKW(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) RA(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RAS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RAW(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RAZ(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RC(1 : 15)
      REAL(w2f__8) RECIP_DEEPFAC2C(1 : 15)
      REAL(w2f__8) RECIP_DEEPFAC2F(1 : 16)
      REAL(w2f__8) RECIP_DEEPFACC(1 : 15)
      REAL(w2f__8) RECIP_DEEPFACF(1 : 16)
      REAL(w2f__8) RECIP_DRC(1 : 15)
      REAL(w2f__8) RECIP_DRF(1 : 15)
      REAL(w2f__8) RECIP_DXC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_DXF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_DXG(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_DXV(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_DYC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_DYF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_DYG(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_DYU(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_HFACC(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_HFACS(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_HFACW(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_RA(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_RAS(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_RAW(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_RAZ(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_RCOL(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RF(1 : 16)
      REAL(w2f__8) RKSIGN
      REAL(w2f__8) RO_SURF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) R_LOW(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SQCOSFACU(-2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SQCOSFACV(-2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TANPHIATU(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TANPHIATV(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) XC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) XC0
      REAL(w2f__8) XG(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) YC(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) YC0
      REAL(w2f__8) YG(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE mpi_info_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) MPI_NORTHID
      INTEGER(w2f__i4) MPI_NP
      INTEGER(w2f__i4) MPI_PID
      INTEGER(w2f__i4) MPI_SOUTHID
C
C     **** Statements ****
C
      END MODULE

      MODULE optim_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      CHARACTER(3) COPT
      REAL(w2f__8) EPS
      REAL(w2f__8) EPSF
      REAL(w2f__8) EPSG
      REAL(w2f__8) EPSX
      REAL(w2f__8) FMIN
      INTEGER(w2f__i4) IPRINT
      INTEGER(w2f__i4) NFUNC
      LOGICAL(w2f__i4) NONDIMCONTROL
      INTEGER(w2f__i4) NUMITER
      INTEGER(w2f__i4) NUPDATE
      INTEGER(w2f__i4) NVARS
      INTEGER(w2f__i4) OPTIMCYCLE
C
C     **** Local Variables and Functions ****
C
      CHARACTER(5) LSOPTVERSION
      PARAMETER ( LSOPTVERSION = '2.1.0')
      CHARACTER(5) OFFLINEVERSION
      PARAMETER ( OFFLINEVERSION = '0.1.1')
C
C     **** Statements ****
C
      END MODULE

      MODULE restart_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      CHARACTER(5) CHECKPTSUFF(1 : 2)
      INTEGER(w2f__i4) MOM_STARTAB
      INTEGER(w2f__i4) NCHECKLEV
      INTEGER(w2f__i4) NHYDSTARTAB
      INTEGER(w2f__i4) SALTSTARTAB
      INTEGER(w2f__i4) TEMPSTARTAB
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) MAXNOCHKPTLEV
      PARAMETER ( MAXNOCHKPTLEV = 2)
C
C     **** Statements ****
C
      END MODULE

      MODULE sigreg_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) I_GOT_SIGNAL
C
C     **** Statements ****
C
      END MODULE

      MODULE solve_for_pressure3d_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Statements ****
C
      END MODULE

      MODULE solve_for_pressure_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) CG2D_B(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) CG2D_X(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      END MODULE

      MODULE surface_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      REAL(w2f__8) BO_SURF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) PHI0SURF(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) RECIP_BO(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) SSURFCOR
      REAL(w2f__8) TOPOZ(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) TSURFCOR
C
C     **** Statements ****
C
      END MODULE

      MODULE tamc_keys_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) IKEY
      INTEGER(w2f__i4) KEY
C
C     **** Statements ****
C
      END MODULE

      MODULE tamc_mod
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
      SAVE
C
C     **** Global Variables & Derived Type Definitions ****
C
      INTEGER(w2f__i4) ACT0
      INTEGER(w2f__i4) ACT1
      INTEGER(w2f__i4) ACT2
      INTEGER(w2f__i4) ACT3
      INTEGER(w2f__i4) ACT4
      INTEGER(w2f__i4) IDYNKEY
      INTEGER(w2f__i4) IGADKEY
      INTEGER(w2f__i4) IGMKEY
      INTEGER(w2f__i4) IIKEY
      INTEGER(w2f__i4) IKEY_DAILY_1
      INTEGER(w2f__i4) IKEY_DAILY_2
      INTEGER(w2f__i4) IKEY_DYNAMICS
      INTEGER(w2f__i4) IKEY_YEARLY
      INTEGER(w2f__i4) ILOOP_DAILY
      INTEGER(w2f__i4) IPTRKEY
      INTEGER(w2f__i4) ITDKEY
      INTEGER(w2f__i4) KKEY
      INTEGER(w2f__i4) MAX0
      INTEGER(w2f__i4) MAX1
      INTEGER(w2f__i4) MAX2
      INTEGER(w2f__i4) MAX3
      INTEGER(w2f__i4) PASSKEY
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) ISBYTE
      PARAMETER ( ISBYTE = 8)
      INTEGER(w2f__i4) MAXCUBE
      PARAMETER ( MAXCUBE = 1)
      INTEGER(w2f__i4) MAXIMPL
      PARAMETER ( MAXIMPL = 6)
      INTEGER(w2f__i4) MAXPASS
      PARAMETER ( MAXPASS = 2)
      INTEGER(w2f__i4) NCHECK_CHKPT
      PARAMETER ( NCHECK_CHKPT = 6)
      INTEGER(w2f__i4) NCHKLEV_1
      PARAMETER ( NCHKLEV_1 = 3)
      INTEGER(w2f__i4) NCHKLEV_2
      PARAMETER ( NCHKLEV_2 = 120)
      INTEGER(w2f__i4) NCHKLEV_3
      PARAMETER ( NCHKLEV_3 = 60)
      INTEGER(w2f__i4) NDAYS_CHKPT
      PARAMETER ( NDAYS_CHKPT = 31)
      INTEGER(w2f__i4) NGEOM_CHKPT
      PARAMETER ( NGEOM_CHKPT = 15)
      INTEGER(w2f__i4) NMONTHS_CHKPT
      PARAMETER ( NMONTHS_CHKPT = 12)
      INTEGER(w2f__i4) NTHREADS_CHKPT
      PARAMETER ( NTHREADS_CHKPT = 1)
      INTEGER(w2f__i4) NYEARS_CHKPT
      PARAMETER ( NYEARS_CHKPT = 1)
C
C     **** Statements ****
C
      END MODULE

      SUBROUTINE do_the_model_io(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      EXTERNAL different_multiple
      LOGICAL(w2f__i4) different_multiple
      EXTERNAL gmredi_output
      EXTERNAL plot_field_xyrl
      EXTERNAL plot_field_xyzrl
      EXTERNAL write_state
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        IF(different_multiple(DUMPFREQ, MYTIME, DELTATCLOCK)) THEN
          CALL barrier(MYTHID)
          CALL plot_field_xyzrl(UVEL, 'Current uVel  ', (15), MYITER,
     >  MYTHID)
          CALL plot_field_xyzrl(VVEL, 'Current vVel  ', (15), MYITER,
     >  MYTHID)
          CALL plot_field_xyzrl(THETA, 'Current theta ', (15), MYITER,
     >  MYTHID)
          CALL plot_field_xyrl(ETAN, 'Current etaN  ', MYITER, MYTHID)
        ENDIF
      ENDIF
      IF(.NOT. USEOFFLINE) THEN
        CALL write_state(MYTIME, MYITER, MYTHID)
      ENDIF
      IF((USEGMREDI .AND.(MYITER .ne. NITER0)) .AND.(.NOT. USEOFFLINE))
     >  THEN
        CALL gmredi_output(MYTIME, MYITER, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE exch_uv_xyz_rl(UPHI, VPHI, WITHSIGNS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use eesupport_mod
      use exch_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) UPHI(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VPHI(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      LOGICAL(w2f__i4) WITHSIGNS
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) TEMP
C
C     **** Statements ****
C
      TEMP = UPHI(1, 1, 1, 1, 1)
      UPHI(1, 1, 1, 1, 1) = VPHI(1, 1, 1, 1, 1)
      VPHI(1, 1, 1, 1, 1) = TEMP
      END SUBROUTINE

      SUBROUTINE exch_xy_rl(PHI, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use eesupport_mod
      use exch_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) PHI(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      PHI(1, 1, 1, 1) = (PHI(1, 1, 1, 1) * 2.0D00)
      END SUBROUTINE

      SUBROUTINE exch_xyz_rl(PHI, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use eesupport_mod
      use exch_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) PHI(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      PHI(1, 1, 1, 1, 1) = (PHI(1, 1, 1, 1, 1) * 2.0D00)
      END SUBROUTINE

      SUBROUTINE global_sum_r8(SUMPHI, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use eesupport_mod
      use exch_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) SUMPHI
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      SUMPHI = SUMPHI * 2.0D00
      END SUBROUTINE

      SUBROUTINE cg2d(CG2D_B, CG2D_X, FIRSTRESIDUAL, LASTRESIDUAL,
     >  NUMITERS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use cg2d_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) CG2D_B(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) CG2D_X(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) FIRSTRESIDUAL
      REAL(w2f__8) LASTRESIDUAL
      INTEGER(w2f__i4) NUMITERS
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      CG2D_X(1, 1, 1, 1) = CG2D_B(1, 1, 1, 1)
      END SUBROUTINE

      SUBROUTINE initialise_fixed(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      EXTERNAL bar_check
      EXTERNAL config_check
      EXTERNAL config_summary
      EXTERNAL ini_eos
      EXTERNAL ini_model_io
      EXTERNAL ini_parms
      EXTERNAL load_ref_files
      EXTERNAL openad_ini_cg2d
      EXTERNAL openad_ini_cori
      EXTERNAL openad_ini_depths
      EXTERNAL openad_ini_grid
      EXTERNAL openad_ini_linear_phisurf
      EXTERNAL openad_ini_masks_etc
      EXTERNAL packages_boot
      EXTERNAL packages_check
      EXTERNAL packages_init_fixed
      EXTERNAL packages_readparms
      EXTERNAL set_grid_factors
      EXTERNAL set_parms
      EXTERNAL set_ref_state
      EXTERNAL write_grid
C
C     **** Statements ****
C
      CALL bar_check((2), MYTHID)
      CALL ini_parms(MYTHID)
      CALL packages_boot(MYTHID)
      CALL packages_readparms(MYTHID)
      CALL set_parms(MYTHID)
      CALL ini_model_io(MYTHID)
      CALL openad_ini_grid(MYTHID)
      CALL load_ref_files(MYTHID)
      CALL ini_eos(MYTHID)
      CALL set_ref_state(MYTHID)
      CALL set_grid_factors(MYTHID)
      CALL openad_ini_depths(MYTHID)
      CALL openad_ini_masks_etc(MYTHID)
      CALL barrier(MYTHID)
      CALL packages_init_fixed(MYTHID)
      CALL openad_ini_linear_phisurf(MYTHID)
      CALL openad_ini_cori(MYTHID)
      CALL openad_ini_cg2d(MYTHID)
      CALL config_summary(MYTHID)
      CALL packages_check(MYTHID)
      CALL config_check(MYTHID)
      IF((DEBUGLEVEL .GE. 1) .OR.(BASETIME .eq. STARTTIME)) THEN
        CALL write_grid(MYTHID)
      ENDIF
      CALL bar_check((3), MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_oce_mxlayer(RHOSURF, SIGMAR, BI, BJ, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) RHOSURF(-2 : 93, -2 : 43)
      REAL(w2f__8) SIGMAR(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      LOGICAL(w2f__i4) CALCMIXLAYERDEPTH
      EXTERNAL find_alpha
      EXTERNAL find_rho_2d
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) METHOD
      REAL(w2f__8) RHOBIGNB
      REAL(w2f__8) RHOKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOLOC(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOMXL(-2 : 93, -2 : 43)
      REAL(w2f__8) SIGMAV
      REAL(w2f__8) TMPFAC
C
C     **** Statements ****
C
      CALCMIXLAYERDEPTH = .FALSE.
      IF(USEGMREDI) THEN
        IF(.NOT. USEKPP) THEN
          CALCMIXLAYERDEPTH = GM_TAPER_SCHEME .EQ. 'fm07'
        ENDIF
      ENDIF
      IF(CALCMIXLAYERDEPTH) THEN
        METHOD = 0
        IF(HMIXCRITERIA .LT. 0.0D00) THEN
          METHOD = 1
        ENDIF
        IF(HMIXCRITERIA .GT. 1.0D00) THEN
          METHOD = 2
        ENDIF
        IF(METHOD .eq. 1) THEN
          RHOBIGNB = RHOCONST * 1.0D+10
          CALL find_alpha(BI, BJ, (-2), (93), (-2), (43), (1), (1),
     >  RHOMXL, MYTHID)
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              RHOKM1(I, J) = RHOSURF(I, J)
              RHOMXL(I, J) = (RHOSURF(I, J) + MAX(DRHOSMALL, RHOMXL(I,
     >  J) * HMIXCRITERIA))
              HMIXLAYER(I, J, BI, BJ) = (RF(1) - R_LOW(I, J, BI, BJ))
            END DO
          END DO
          DO K = 2, 15, 1
            CALL find_rho_2d((-2), (93), (-2), (43), (1), THETA((-2), (
     > -2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOLOC, (K), BI,
     >  BJ, MYTHID)
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IF((KLOWC(I, J, BI, BJ) .GE. K) .AND.(RHOLOC(I, J) .GE.
     >  RHOMXL(I, J))) THEN
                  IF(RHOKM1(I, J) .LT. RHOLOC(I, J)) THEN
                    TMPFAC = (RHOMXL(I, J) - RHOKM1(I, J)) /(RHOLOC(I,
     >  J) - RHOKM1(I, J))
                  ELSE
                    TMPFAC = 0.0D00
                  ENDIF
                  HMIXLAYER(I, J, BI, BJ) = (DRC(K) * TMPFAC + RF(1) -
     >  RC(K + (-1)))
                  RHOMXL(I, J) = RHOBIGNB
                ELSE
                  RHOKM1(I, J) = RHOLOC(I, J)
                ENDIF
              END DO
            END DO
          END DO
        ELSE
          IF(METHOD .eq. 2) THEN
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IF(KLOWC(I, J, BI, BJ) .GT. 0) THEN
                  HMIXLAYER(I, J, BI, BJ) = DRF(1)
                  RHOMXL(I, J) = 1.0D00
                ELSE
                  HMIXLAYER(I, J, BI, BJ) = RF(1)
                  RHOMXL(I, J) = (-1.0D00)
                ENDIF
              END DO
            END DO
            DO K = 2, 14, 1
              CALL find_rho_2d((-2), (93), (-2), (43), (1), THETA((-2),
     >  (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOLOC, (K), BI,
     >  BJ, MYTHID)
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  IF((KLOWC(I, J, BI, BJ) .GT. K) .AND.(RHOMXL(I, J)
     >  .GE. 0.0D00)) THEN
                    SIGMAV = (DRHOSMALL + RHOLOC(I, J) - RHOSURF(I, J))
     >  /(RC(1) - RC(K))
                    IF((SIGMAV * HMIXCRITERIA) .LT.(- SIGMAR(I, J, K +
     >  1))) THEN
                      TMPFAC = 0.0D00
                      IF(SIGMAV .GT. 0.0D00) THEN
                        TMPFAC = (SIGMAR(I, J, K) * HMIXCRITERIA) /
     >  SIGMAR(I, J, K + 1)
                        IF(TMPFAC .GT. 1.0D00) THEN
                          TMPFAC = ((TMPFAC +(-1.0D00)) /(HMIXCRITERIA
     >  +(-1.0D00))) + 1.0D00
                        ENDIF
                        TMPFAC = MAX(MIN(TMPFAC, 2.0D00), 0.0D00)
                      ENDIF
                      HMIXLAYER(I, J, BI, BJ) = (RF(1) - RF(K + 1) -
     >  DRF(K) * TMPFAC * 5.0D-01)
                      RHOMXL(I, J) = (-1.0D00)
                    ENDIF
                  ENDIF
                END DO
              END DO
            END DO
          ELSE
            WRITE(*, *) 'S/R CALC_OCE_MXLAYER: invalid method'
          ENDIF
        ENDIF
        IF(HMIXSMOOTH .GT. 0.0D00) THEN
          TMPFAC = (1.0D00 - HMIXSMOOTH) * 2.5D-01
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              RHOLOC(I, J) = (MASKC(I, J, 1, BI, BJ) *((HMIXLAYER(I, J,
     >  BI, BJ) * HMIXSMOOTH + TMPFAC *(HMIXLAYER(I, J + 1, BI, BJ) +
     >  HMIXLAYER(I, J + (-1), BI, BJ) + HMIXLAYER(I + (-1), J, BI, BJ)
     >  + HMIXLAYER(I + 1, J, BI, BJ))) /(HMIXSMOOTH + TMPFAC *(MASKC(I
     > , J + 1, 1, BI, BJ) + MASKC(I, J + (-1), 1, BI, BJ) + MASKC(I +
     >  (-1), J, 1, BI, BJ) + MASKC(I + 1, J, 1, BI, BJ)))))
            END DO
          END DO
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              HMIXLAYER(I, J, BI, BJ) = RHOLOC(I, J)
            END DO
          END DO
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE the_first_level_loop(ILOOP, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use eos_mod
      use gad_mod
      use cd_code_vars_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) ILOOP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL forward_step
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_FIRST_LEVEL_LOOP', MYTHID)
      ENDIF
      WRITE(STANDARDMESSAGEUNIT, '(2(A,I6))')
     >  'OAD: THE_FIRST_LEVEL_LOOP: iloop=', ILOOP, ' of ', NTIMESTEPS
      IF(DEBUGMODE) THEN
        CALL debug_call('FORWARD_STEP', MYTHID)
      ENDIF
      CALL forward_step(ILOOP, MYTIME, MYITER, MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_FIRST_LEVEL_LOOP', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE the_fourth_level_loop(ILEV_4, UCHECKLEV1, UCHECKLEV2,
     >  UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use eos_mod
      use gad_mod
      use cd_code_vars_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) ILEV_4
      INTEGER(w2f__i4) UCHECKLEV1
      INTEGER(w2f__i4) UCHECKLEV2
      INTEGER(w2f__i4) UCHECKLEV3
      INTEGER(w2f__i4) UCHECKLEV4
      INTEGER(w2f__i4) THECURRENTSTEP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      INTEGER(w2f__i4) ILEV_3
      EXTERNAL the_third_level_loop
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_FOURTH_LEVEL_LOOP', MYTHID)
      ENDIF
      DO ILEV_3 = 1, UCHECKLEV3, 1
        IF(THECURRENTSTEP .LE. NTIMESTEPS) THEN
          IF(DEBUGMODE) THEN
            CALL debug_call('THE_THIRD_LEVEL_LOOP', MYTHID)
          ENDIF
          CALL the_third_level_loop(ILEV_4, (ILEV_3), UCHECKLEV1,
     >  UCHECKLEV2, UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME,
     >  MYITER, MYTHID)
        ENDIF
      END DO
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_FOURTH_LEVEL_LOOP', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE the_fourth_level_plain(UCHECKLEV1, UCHECKLEV2,
     >  UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use eos_mod
      use gad_mod
      use cd_code_vars_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) UCHECKLEV1
      INTEGER(w2f__i4) UCHECKLEV2
      INTEGER(w2f__i4) UCHECKLEV3
      INTEGER(w2f__i4) UCHECKLEV4
      INTEGER(w2f__i4) THECURRENTSTEP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      INTEGER(w2f__i4) ILEV_3
      EXTERNAL the_third_level_loop
      EXTERNAL the_third_level_plain
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_FOURTH_LEVEL_PLAIN', MYTHID)
      ENDIF
      IF(UCHECKLEV3 .GT. 0) THEN
        DO ILEV_3 = 1, UCHECKLEV3, 1
          IF(THECURRENTSTEP .LE. NTIMESTEPS) THEN
            IF(DEBUGMODE) THEN
              CALL debug_call('THE_THIRD_LEVEL_LOOP', MYTHID)
            ENDIF
            CALL the_third_level_loop((1), (ILEV_3), UCHECKLEV1,
     >  UCHECKLEV2, UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME,
     >  MYITER, MYTHID)
          ENDIF
        END DO
      ELSE
        IF(DEBUGMODE) THEN
          CALL debug_call('THE_THIRD_LEVEL_PLAIN', MYTHID)
        ENDIF
        CALL the_third_level_plain(UCHECKLEV1, UCHECKLEV2, UCHECKLEV3,
     >  UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
      ENDIF
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_FOURTH_LEVEL_LOOP', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE the_second_level_loop(ILEV_4, ILEV_3, ILEV_2,
     >  UCHECKLEV1, UCHECKLEV2, UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP,
     >  MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use eos_mod
      use gad_mod
      use cd_code_vars_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) ILEV_4
      INTEGER(w2f__i4) ILEV_3
      INTEGER(w2f__i4) ILEV_2
      INTEGER(w2f__i4) UCHECKLEV1
      INTEGER(w2f__i4) UCHECKLEV2
      INTEGER(w2f__i4) UCHECKLEV3
      INTEGER(w2f__i4) UCHECKLEV4
      INTEGER(w2f__i4) THECURRENTSTEP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      INTEGER(w2f__i4) ILEV_1
      INTEGER(w2f__i4) TESTSTEP
      EXTERNAL the_first_level_loop
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_SECOND_LEVEL_LOOP', MYTHID)
      ENDIF
      DO ILEV_1 = 1, UCHECKLEV1, 1
        TESTSTEP = ILEV_1 + UCHECKLEV1 *(ILEV_2 +(-1)) + UCHECKLEV1 *
     >  UCHECKLEV2 *(ILEV_3 +(-1)) + UCHECKLEV1 * UCHECKLEV2 *
     >  UCHECKLEV3 *(ILEV_4 +(-1))
        IF(TESTSTEP .LE. NTIMESTEPS) THEN
          THECURRENTSTEP = TESTSTEP
          IF(DEBUGMODE) THEN
            CALL debug_call('THE_FIRST_LEVEL_LOOP', MYTHID)
          ENDIF
          CALL the_first_level_loop(THECURRENTSTEP, MYTIME, MYITER,
     >  MYTHID)
        ENDIF
      END DO
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_SECOND_LEVEL_LOOP', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE the_second_level_plain(UCHECKLEV1, UCHECKLEV2,
     >  UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use eos_mod
      use gad_mod
      use cd_code_vars_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) UCHECKLEV1
      INTEGER(w2f__i4) UCHECKLEV2
      INTEGER(w2f__i4) UCHECKLEV3
      INTEGER(w2f__i4) UCHECKLEV4
      INTEGER(w2f__i4) THECURRENTSTEP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      INTEGER(w2f__i4) ILEV_1
      INTEGER(w2f__i4) TESTSTEP
      EXTERNAL the_first_level_loop
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_SECOND_LEVEL_PLAIN', MYTHID)
      ENDIF
      DO ILEV_1 = 1, UCHECKLEV1, 1
        TESTSTEP = ILEV_1
        IF(THECURRENTSTEP .LE. NTIMESTEPS) THEN
          THECURRENTSTEP = TESTSTEP
          IF(DEBUGMODE) THEN
            CALL debug_call('THE_FIRST_LEVEL_LOOP', MYTHID)
          ENDIF
          CALL the_first_level_loop(THECURRENTSTEP, MYTIME, MYITER,
     >  MYTHID)
        ENDIF
      END DO
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_SECOND_LEVEL_PLAIN', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE the_third_level_loop(ILEV_4, ILEV_3, UCHECKLEV1,
     >  UCHECKLEV2, UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use eos_mod
      use gad_mod
      use cd_code_vars_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) ILEV_4
      INTEGER(w2f__i4) ILEV_3
      INTEGER(w2f__i4) UCHECKLEV1
      INTEGER(w2f__i4) UCHECKLEV2
      INTEGER(w2f__i4) UCHECKLEV3
      INTEGER(w2f__i4) UCHECKLEV4
      INTEGER(w2f__i4) THECURRENTSTEP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      INTEGER(w2f__i4) ILEV_2
      EXTERNAL the_second_level_loop
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_THIRD_LEVEL_LOOP', MYTHID)
      ENDIF
      DO ILEV_2 = 1, UCHECKLEV2, 1
        IF(THECURRENTSTEP .LE. NTIMESTEPS) THEN
          IF(DEBUGMODE) THEN
            CALL debug_call('THE_SECOND_LEVEL_LOOP', MYTHID)
          ENDIF
          CALL the_second_level_loop(ILEV_4, ILEV_3, (ILEV_2),
     >  UCHECKLEV1, UCHECKLEV2, UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP,
     >  MYTIME, MYITER, MYTHID)
        ENDIF
      END DO
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_THIRD_LEVEL_LOOP', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE the_third_level_plain(UCHECKLEV1, UCHECKLEV2,
     >  UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use eos_mod
      use gad_mod
      use cd_code_vars_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) UCHECKLEV1
      INTEGER(w2f__i4) UCHECKLEV2
      INTEGER(w2f__i4) UCHECKLEV3
      INTEGER(w2f__i4) UCHECKLEV4
      INTEGER(w2f__i4) THECURRENTSTEP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      INTEGER(w2f__i4) ILEV_2
      EXTERNAL the_second_level_loop
      EXTERNAL the_second_level_plain
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_THIRD_LEVEL_PLAIN', MYTHID)
      ENDIF
      IF(UCHECKLEV2 .GT. 0) THEN
        DO ILEV_2 = 1, UCHECKLEV2, 1
          IF(THECURRENTSTEP .LE. NTIMESTEPS) THEN
            IF(DEBUGMODE) THEN
              CALL debug_call('THE_SECOND_LEVEL_LOOP', MYTHID)
            ENDIF
            CALL the_second_level_loop((1), (1), (ILEV_2), UCHECKLEV1,
     >  UCHECKLEV2, UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME,
     >  MYITER, MYTHID)
          ENDIF
        END DO
      ELSE
        IF(DEBUGMODE) THEN
          CALL debug_call('THE_SECOND_LEVEL_PLAIN', MYTHID)
        ENDIF
        CALL the_second_level_plain(UCHECKLEV1, UCHECKLEV2, UCHECKLEV3,
     >  UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
      ENDIF
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_THIRD_LEVEL_PLAIN', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE cd_code_scheme(BI, BJ, K, DPHIHYDX, DPHIHYDY, GUFLD,
     >  GVFLD, GUCOR, GVCOR, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use cd_code_vars_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) DPHIHYDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DPHIHYDY(-2 : 93, -2 : 43)
      REAL(w2f__8) GUFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) GVFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) GUCOR(-2 : 93, -2 : 43)
      REAL(w2f__8) GVCOR(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) AB05
      REAL(w2f__8) AB15
      REAL(w2f__8) AF(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      PARAMETER ( IMAX = 92)
      INTEGER(w2f__i4) IMIN
      PARAMETER ( IMIN = -1)
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      PARAMETER ( JMAX = 42)
      INTEGER(w2f__i4) JMIN
      PARAMETER ( JMIN = -1)
      REAL(w2f__8) PF(-2 : 93, -2 : 43)
      REAL(w2f__8) PHXFAC
      REAL(w2f__8) PHYFAC
      REAL(w2f__8) VF(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      AB15 = ABEPS + 1.5D00
      AB05 = (-5.0D-01) - ABEPS
      IF(STAGGERTIMESTEP) THEN
        PHXFAC = PFFACMOM
        PHYFAC = PFFACMOM
      ELSE
        PHXFAC = 0.0D00
        PHYFAC = 0.0D00
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          PF(I, J) = (AB05 *(ETANM1(I, J, BI, BJ) * BO_SURF(I, J, BI,
     >  BJ)) + AB15 *(ETAN(I, J, BI, BJ) * BO_SURF(I, J, BI, BJ)))
        END DO
      END DO
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          AF(I, J) = (MASKS(I, J, K, BI, BJ) *(GVFLD(I, J) -(DPHIHYDY(I
     > , J) * PHYFAC + RECIP_DYC(I, J, BI, BJ) *(PF(I, J) - PF(I, J + (
     > -1))))))
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          VF(I, J) = (MASKW(I, J, K, BI, BJ) *((AF(I, J) + AF(I + (-1),
     >  J + 1)) +(AF(I + (-1), J) + AF(I, J + 1))) * 2.5D-01 - UVEL(I,
     >  J, K, BI, BJ) *(FCORI(I, J, BI, BJ) + FCORI(I + (-1), J, BI, BJ
     > )) * 5.0D-01)
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          VVELD(I, J, K, BI, BJ) = (VVELD(I, J, K, BI, BJ) + VF(I, J) *
     >  DELTATMOM)
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          VVELD(I, J, K, BI, BJ) = (MASKW(I, J, K, BI, BJ) *(VVELD(I, J
     > , K, BI, BJ) * RCD +(AB05 *((VNM1(I, J, K, BI, BJ) + VNM1(I + (
     > -1), J + 1, K, BI, BJ)) +(VNM1(I + (-1), J, K, BI, BJ) + VNM1(I,
     >  J + 1, K, BI, BJ))) * 2.5D-01 + AB15 *((VVEL(I, J, K, BI, BJ) +
     >  VVEL(I + (-1), J + 1, K, BI, BJ)) +(VVEL(I + (-1), J, K, BI, BJ
     > ) + VVEL(I, J + 1, K, BI, BJ))) * 2.5D-01) *(1.0D00 - RCD)))
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          GUCOR(I, J) = (CFFACMOM * VVELD(I, J, K, BI, BJ) *(FCORI(I, J
     > , BI, BJ) + FCORI(I + (-1), J, BI, BJ)) * 5.0D-01)
        END DO
      END DO
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          AF(I, J) = (MASKW(I, J, K, BI, BJ) *(GUFLD(I, J) -(DPHIHYDX(I
     > , J) * PHXFAC + RECIP_DXC(I, J, BI, BJ) *(PF(I, J) - PF(I + (-1)
     > , J)))))
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          VF(I, J) = (VVEL(I, J, K, BI, BJ) *(FCORI(I, J, BI, BJ) +
     >  FCORI(I, J + (-1), BI, BJ)) * 5.0D-01 + MASKS(I, J, K, BI, BJ)
     >  *((AF(I, J) + AF(I + 1, J + (-1))) +(AF(I + 1, J) + AF(I, J + (
     > -1)))) * 2.5D-01)
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          UVELD(I, J, K, BI, BJ) = (UVELD(I, J, K, BI, BJ) + VF(I, J) *
     >  DELTATMOM)
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          UVELD(I, J, K, BI, BJ) = (MASKS(I, J, K, BI, BJ) *(UVELD(I, J
     > , K, BI, BJ) * RCD +(AB05 *((UNM1(I, J, K, BI, BJ) + UNM1(I + 1,
     >  J + (-1), K, BI, BJ)) +(UNM1(I + 1, J, K, BI, BJ) + UNM1(I, J +
     >  (-1), K, BI, BJ))) * 2.5D-01 + AB15 *((UVEL(I, J, K, BI, BJ) +
     >  UVEL(I + 1, J + (-1), K, BI, BJ)) +(UVEL(I + 1, J, K, BI, BJ) +
     >  UVEL(I, J + (-1), K, BI, BJ))) * 2.5D-01) *(1.0D00 - RCD)))
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          GVCOR(I, J) = (-(CFFACMOM * UVELD(I, J, K, BI, BJ) *(FCORI(I,
     >  J, BI, BJ) + FCORI(I, J + (-1), BI, BJ)) * 5.0D-01))
        END DO
      END DO
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          UNM1(I, J, K, BI, BJ) = UVEL(I, J, K, BI, BJ)
          VNM1(I, J, K, BI, BJ) = VVEL(I, J, K, BI, BJ)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE cd_code_ini_vars(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use cd_code_vars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL cd_code_read_pickup
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                UNM1(I, J, K, BI, BJ) = 0.0D00
                VNM1(I, J, K, BI, BJ) = 0.0D00
                UVELD(I, J, K, BI, BJ) = 0.0D00
                VVELD(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ETANM1(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      IF(NITER0 .ne. 0) THEN
        CALL cd_code_read_pickup(NITER0, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE cost_accumulate_mean(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          DO K = 1, 15, 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                CMEANTHETA(I, J, K, BI, BJ) = (CMEANTHETA(I, J, K, BI,
     >  BJ) + DELTATCLOCK *(THETA(I, J, K, BI, BJ) / LASTINTERVAL))
                CMEANUVEL(I, J, K, BI, BJ) = (CMEANUVEL(I, J, K, BI, BJ
     > ) + DELTATCLOCK *(UVEL(I, J, K, BI, BJ) / LASTINTERVAL))
                CMEANVVEL(I, J, K, BI, BJ) = (CMEANVVEL(I, J, K, BI, BJ
     > ) + DELTATCLOCK *(VVEL(I, J, K, BI, BJ) / LASTINTERVAL))
                CMEANTHETAUVEL(I, J, K, BI, BJ) = (CMEANTHETAUVEL(I, J,
     >  K, BI, BJ) + DELTATCLOCK *((MASKC(I, J, K, BI, BJ) * MASKW(I, J
     > , K, BI, BJ) * UVEL(I, J, K, BI, BJ) *(THETA(I, J, K, BI, BJ) +
     >  THETA(I + (-1), J, K, BI, BJ)) * 5.0D-01) / LASTINTERVAL))
                CMEANTHETAVVEL(I, J, K, BI, BJ) = (CMEANTHETAVVEL(I, J,
     >  K, BI, BJ) + DELTATCLOCK *((MASKC(I, J, K, BI, BJ) * MASKS(I, J
     > , K, BI, BJ) * VVEL(I, J, K, BI, BJ) *(THETA(I, J, K, BI, BJ) +
     >  THETA(I, J + (-1), K, BI, BJ)) * 5.0D-01) / LASTINTERVAL))
              END DO
            END DO
          END DO
        END DO
      END DO
      END SUBROUTINE

      SUBROUTINE cost_final(MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use cost_mod
      use ctrl_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL cost_test
      EXTERNAL global_sum_r8
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      CALL cost_test(MYTHID)
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          WRITE(STANDARDMESSAGEUNIT, '(A,D22.15)')
     >  ' --> objf_test(bi,bj)   = ', OBJF_TEST(BI, BJ)
          WRITE(STANDARDMESSAGEUNIT, '(A,D22.15)')
     >  ' --> objf_tracer(bi,bj) = ', OBJF_TRACER(BI, BJ)
          WRITE(STANDARDMESSAGEUNIT, '(A,D22.15)')
     >  ' --> objf_atl(bi,bj)    = ', OBJF_ATL(BI, BJ)
          FC = FC + OBJF_TEST(BI, BJ) * MULT_TEST + OBJF_TRACER(BI, BJ)
     >  * MULT_TRACER + OBJF_ATL(BI, BJ) * MULT_ATL
        END DO
      END DO
      WRITE(STANDARDMESSAGEUNIT, '(A,D22.15)') '  local fc = ', FC
      CALL global_sum_r8(FC, MYTHID)
      WRITE(STANDARDMESSAGEUNIT, '(A,D22.15)') ' global fc = ', FC
      TAVEFREQ = 0.0D00
      DUMPFREQ = 0.0D00
      PCHKPTFREQ = 0.0D00
      MONITORFREQ = 0.0D00
      RETURN
      END SUBROUTINE

      SUBROUTINE cost_init_varia(MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          OBJF_ATL(BI, BJ) = 0.0D00
          OBJF_TEST(BI, BJ) = 0.0D00
          OBJF_TRACER(BI, BJ) = 0.0D00
          DO K = 1, 15, 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                CMEANTHETA(I, J, K, BI, BJ) = 0.0D00
                CMEANUVEL(I, J, K, BI, BJ) = 0.0D00
                CMEANVVEL(I, J, K, BI, BJ) = 0.0D00
                CMEANTHETAUVEL(I, J, K, BI, BJ) = 0.0D00
                CMEANTHETAVVEL(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
        END DO
      END DO
      IF(MYTHID .eq. 1) THEN
        FC = 0.0D00
      ENDIF
      CALL barrier(MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE cost_tile(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use cost_mod
      use tamc_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL cost_accumulate_mean
C
C     **** Statements ****
C
      IF(MYTIME .GT.(ENDTIME - LASTINTERVAL)) THEN
        CALL cost_accumulate_mean(MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE cost_test(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IG
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JG
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      INTEGER(w2f__i4) K
      REAL(w2f__8) THETAREF
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      IF(USECUBEDSPHEREEXCHANGE) THEN
        ILOCOUT = 7
        JLOCOUT = 28
        KLOCOUT = 1
      ELSE
        ILOCOUT = 80
        JLOCOUT = 30
        KLOCOUT = 1
      ENDIF
      THETAREF = 2.4D+01
      K = 1
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          DO J = 1, 40, 1
            JG = J + MYYGLOBALLO + BJ * 40 +(-41)
            DO I = 1, 90, 1
              IG = I + MYXGLOBALLO + BI * 90 +(-91)
              OBJF_TEST(BI, BJ) = (OBJF_TEST(BI, BJ) +(THETA(I, J,
     >  KLOCOUT, BI, BJ) ** 2))
            END DO
          END DO
        END DO
      END DO
      END SUBROUTINE

      SUBROUTINE cost_tracer(BI, BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE cost_atlantic_heat(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE cost_vector(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE cost_state_final(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE ctrl_depth_ini(MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use grid_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_get_gen(XX_GEN_FILE, XX_GENSTARTDATE,
     >  XX_GENPERIOD, GENMASK, GENFLD, XX_GEN0, XX_GEN1, XX_GEN_DUMMY,
     >  XX_GEN_REMO_INTERCEPT, XX_GEN_REMO_SLOPE, MYTIME, MYITER,
     >  MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(512) XX_GEN_FILE
      INTEGER(w2f__i4) XX_GENSTARTDATE(1 : 4)
      REAL(w2f__8) XX_GENPERIOD
      REAL(w2f__8) GENMASK(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GENFLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) XX_GEN0(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) XX_GEN1(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) XX_GEN_DUMMY
      REAL(w2f__8) XX_GEN_REMO_INTERCEPT
      REAL(w2f__8) XX_GEN_REMO_SLOPE
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE ctrl_get_gen_rec(XX_GENSTARTDATE, XX_GENPERIOD, FAC,
     >  FIRST, CHANGED, COUNT0, COUNT1, MYTIME, MYITER, MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use ctrl_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) XX_GENSTARTDATE(1 : 4)
      REAL(w2f__8) XX_GENPERIOD
      REAL(w2f__8) FAC
      LOGICAL(w2f__i4) FIRST
      LOGICAL(w2f__i4) CHANGED
      INTEGER(w2f__i4) COUNT0
      INTEGER(w2f__i4) COUNT1
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_init_variables(MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use ctrl_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      JMIN = -2
      JMAX = 43
      IMIN = -2
      IMAX = 93
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_map_ini(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL active_read_xyz
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      LOGICAL(w2f__i4) DOGLOBALREAD
      LOGICAL(w2f__i4) EQUAL
      EXTERNAL exch_xyz_rl
      REAL(w2f__8) FAC
      CHARACTER(80) FNAMEGENERIC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IL
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) LADINIT
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      JMIN = 1
      JMAX = 40
      IMIN = 1
      IMAX = 90
      DOGLOBALREAD = .FALSE.
      LADINIT = .FALSE.
      EQUAL = .TRUE.
      IF(EQUAL) THEN
        FAC = 1.0D00
      ELSE
        FAC = 0.0D00
      ENDIF
      IL = ilnblnk(XX_THETA_FILE)
      WRITE(FNAMEGENERIC, '(2a,i10.10)') XX_THETA_FILE(1_w2f__i8 : IL),
     >  '.', OPTIMCYCLE
      CALL active_read_xyz(FNAMEGENERIC, TMPFLD3D, (1), DOGLOBALREAD,
     >  LADINIT, OPTIMCYCLE, MYTHID, XX_THETA_DUMMY)
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          DO K = 1, 15, 1
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                THETA(I, J, K, BI, BJ) = (THETA(I, J, K, BI, BJ) +
     >  XX_THETA(I, J, K, BI, BJ) * FAC + TMPFLD3D(I, J, K, BI, BJ) *
     >  FAC)
              END DO
            END DO
          END DO
        END DO
      END DO
      IL = ilnblnk(XX_SALT_FILE)
      WRITE(FNAMEGENERIC, '(2a,i10.10)') XX_SALT_FILE(1_w2f__i8 : IL),
     >  '.', OPTIMCYCLE
      CALL active_read_xyz(FNAMEGENERIC, TMPFLD3D, (1), DOGLOBALREAD,
     >  LADINIT, OPTIMCYCLE, MYTHID, XX_SALT_DUMMY)
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          DO K = 1, 15, 1
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                SALT(I, J, K, BI, BJ) = (SALT(I, J, K, BI, BJ) +
     >  XX_SALT(I, J, K, BI, BJ) * FAC + TMPFLD3D(I, J, K, BI, BJ) *
     >  FAC)
              END DO
            END DO
          END DO
        END DO
      END DO
      CALL exch_xyz_rl(THETA, MYTHID)
      CALL exch_xyz_rl(SALT, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_map_ini_ecco(MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_map_ini_gen3d(XXFILECUR, WFILECUR, XXDUMMYCUR,
     >  BOUNDSVEC, PARAMFLD3D, MASKFLD3D, PARAMSMOOTH, MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) XXFILECUR
      CHARACTER(*) WFILECUR
      REAL(w2f__8) XXDUMMYCUR
      REAL(w2f__8) BOUNDSVEC(1 : 5)
      REAL(w2f__8) PARAMFLD3D(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MASKFLD3D(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) PARAMSMOOTH
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL active_read_xyz
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL ctrl_bound_3d
      LOGICAL(w2f__i4) DOGLOBALREAD
      EXTERNAL exch_xyz_rl
      CHARACTER(80) FNAMEGENERIC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IL
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) LADINIT
      EXTERNAL mdsreadfield
      REAL(w2f__8) TMPMAX
      REAL(w2f__8) WFLD3D(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) XXFLD3D(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = 0
      IKEY = ACT3 + ACT4 * MAX3 + 1
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      JMIN = 1
      JMAX = 40
      IMIN = 1
      IMAX = 90
      DOGLOBALREAD = .FALSE.
      LADINIT = .FALSE.
      CALL mdsreadfield(WFILECUR(1_w2f__i8 : INT(LEN(WFILECUR))), (32),
     >  'RL', (15), WFLD3D, (1), MYTHID)
      CALL exch_xyz_rl(WFLD3D, MYTHID)
      IL = ilnblnk(XXFILECUR(1_w2f__i8 : INT(LEN(XXFILECUR))))
      WRITE(FNAMEGENERIC, '(2a,i10.10)') XXFILECUR(1_w2f__i8 : IL), '.'
     > , OPTIMCYCLE
      CALL active_read_xyz(FNAMEGENERIC, XXFLD3D, (1), DOGLOBALREAD,
     >  LADINIT, OPTIMCYCLE, MYTHID, XXDUMMYCUR)
      IF(BOUNDSVEC(5) .GT. 0.0D00) THEN
        DO BJ = JTLO, JTHI, 1
          DO BI = ITLO, ITHI, 1
            DO K = 1, 15, 1
              DO J = JMIN, JMAX, 1
                DO I = IMIN, IMAX, 1
                  IF((WFLD3D(I, J, K, BI, BJ) .GT. 0.0D00) .AND.(
     > MASKFLD3D(I, J, K, BI, BJ) .ne. 0.0D00)) THEN
                    TMPMAX = BOUNDSVEC(5) / SQRT(WFLD3D(I, J, K, BI, BJ
     > ))
                    IF(TMPMAX .LT. ABS(XXFLD3D(I, J, K, BI, BJ))) THEN
                      XXFLD3D(I, J, K, BI, BJ) = SIGN(TMPMAX, XXFLD3D(I
     > , J, K, BI, BJ))
                    ELSE
                    ENDIF
                  ENDIF
                END DO
              END DO
            END DO
          END DO
        END DO
      ENDIF
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          DO K = 1, 15, 1
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                PARAMFLD3D(I, J, K, BI, BJ) = (PARAMFLD3D(I, J, K, BI,
     >  BJ) + XXFLD3D(I, J, K, BI, BJ))
              END DO
            END DO
          END DO
        END DO
      END DO
      CALL ctrl_bound_3d(PARAMFLD3D, MASKFLD3D, BOUNDSVEC, MYTHID)
      END SUBROUTINE

      SUBROUTINE ctrl_map_ini_gen2d(XXFILECUR, WFILECUR, XXDUMMYCUR,
     >  BOUNDSVEC, PARAMFLD2D, MASKFLD3D, PARAMSMOOTH, MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) XXFILECUR
      CHARACTER(*) WFILECUR
      REAL(w2f__8) XXDUMMYCUR
      REAL(w2f__8) BOUNDSVEC(1 : 5)
      REAL(w2f__8) PARAMFLD2D(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) MASKFLD3D(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) PARAMSMOOTH
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL active_read_xy
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL ctrl_bound_2d
      LOGICAL(w2f__i4) DOGLOBALREAD
      EXTERNAL exch_xy_rl
      CHARACTER(80) FNAMEGENERIC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IL
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      LOGICAL(w2f__i4) LADINIT
      EXTERNAL mdsreadfield
      REAL(w2f__8) TMPMAX
      REAL(w2f__8) WFLD2D(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) XXFLD2D(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = 0
      IKEY = ACT3 + ACT4 * MAX3 + 1
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      JMIN = 1
      JMAX = 40
      IMIN = 1
      IMAX = 90
      DOGLOBALREAD = .FALSE.
      LADINIT = .FALSE.
      CALL mdsreadfield(WFILECUR(1_w2f__i8 : INT(LEN(WFILECUR))), (32),
     >  'RL', (1), WFLD2D, (1), MYTHID)
      CALL exch_xy_rl(WFLD2D, MYTHID)
      IL = ilnblnk(XXFILECUR(1_w2f__i8 : INT(LEN(XXFILECUR))))
      WRITE(FNAMEGENERIC, '(2a,i10.10)') XXFILECUR(1_w2f__i8 : IL), '.'
     > , OPTIMCYCLE
      CALL active_read_xy(FNAMEGENERIC, XXFLD2D, (1), DOGLOBALREAD,
     >  LADINIT, OPTIMCYCLE, MYTHID, XXDUMMYCUR)
      IF(BOUNDSVEC(5) .GT. 0.0D00) THEN
        DO BJ = JTLO, JTHI, 1
          DO BI = ITLO, ITHI, 1
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                IF((WFLD2D(I, J, BI, BJ) .GT. 0.0D00) .AND.(MASKFLD3D(I
     > , J, 1, BI, BJ) .ne. 0.0D00)) THEN
                  TMPMAX = BOUNDSVEC(5) / SQRT(WFLD2D(I, J, BI, BJ))
                  IF(TMPMAX .LT. ABS(XXFLD2D(I, J, BI, BJ))) THEN
                    XXFLD2D(I, J, BI, BJ) = SIGN(TMPMAX, XXFLD2D(I, J,
     >  BI, BJ))
                  ELSE
                  ENDIF
                ENDIF
              END DO
            END DO
          END DO
        END DO
      ENDIF
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              PARAMFLD2D(I, J, BI, BJ) = (PARAMFLD2D(I, J, BI, BJ) +
     >  XXFLD2D(I, J, BI, BJ))
            END DO
          END DO
        END DO
      END DO
      CALL ctrl_bound_2d(PARAMFLD2D, MASKFLD3D, BOUNDSVEC, MYTHID)
      END SUBROUTINE

      SUBROUTINE ctrl_map_forcing(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use ffields_mod
      use dynvars_mod
      use grid_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      LOGICAL(w2f__i4) DOGLOBALREAD
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      LOGICAL(w2f__i4) LADINIT
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      JMIN = 1
      JMAX = 40
      IMIN = 1
      IMAX = 90
      DOGLOBALREAD = .FALSE.
      LADINIT = .FALSE.
      END SUBROUTINE

      SUBROUTINE ctrl_smooth(FLD, MASK)
      use w2f__types
      use size_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) FLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) MASK(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) FLD_TMP(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IM1
      INTEGER(w2f__i4) IMAX
      PARAMETER ( IMAX = 92)
      INTEGER(w2f__i4) IMIN
      PARAMETER ( IMIN = -1)
      INTEGER(w2f__i4) IP1
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JM1
      INTEGER(w2f__i4) JMAX
      PARAMETER ( JMAX = 42)
      INTEGER(w2f__i4) JMIN
      PARAMETER ( JMIN = -1)
      INTEGER(w2f__i4) JP1
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
      INTEGER(w2f__i4) K
      REAL(w2f__8) P0
      PARAMETER ( P0 = 0.0D00)
      REAL(w2f__8) P0625
      PARAMETER ( P0625 = 6.25D-02)
      REAL(w2f__8) P125
      PARAMETER ( P125 = 1.25D-01)
      REAL(w2f__8) P25
      PARAMETER ( P25 = 2.5D-01)
      REAL(w2f__8) P5
      PARAMETER ( P5 = 5.0D-01)
      REAL(w2f__8) TEMPVAR
C
C     **** Statements ****
C
      JTLO = 1
      JTHI = 1
      ITLO = 1
      ITHI = 1
      K = 1
      DO BJ = JTLO, JTHI, 1
        DO BI = ITLO, ITHI, 1
          DO J = -1, 42, 1
            JM1 = J +(-1)
            JP1 = J + 1
            DO I = -1, 92, 1
              IM1 = I +(-1)
              IP1 = I + 1
              TEMPVAR = MASK(I, J, K, BI, BJ) * 2.5D-01 +(MASK(I, JP1,
     >  K, BI, BJ) + MASK(I, JM1, K, BI, BJ) + MASK(IM1, J, K, BI, BJ)
     >  + MASK(IP1, J, K, BI, BJ)) * 1.25D-01 +(MASK(IP1, JP1, K, BI,
     >  BJ) + MASK(IP1, JM1, K, BI, BJ) + MASK(IM1, JM1, K, BI, BJ) +
     >  MASK(IM1, JP1, K, BI, BJ)) * 6.25D-02
              IF(TEMPVAR .GE. 2.5D-01) THEN
                FLD_TMP(I, J) = ((MASK(I, J, K, BI, BJ) * FLD(I, J, BI,
     >  BJ) * 2.5D-01 +(FLD(IM1, J, BI, BJ) * MASK(IM1, J, K, BI, BJ) +
     >  FLD(IP1, J, BI, BJ) * MASK(IP1, J, K, BI, BJ) + FLD(I, JM1, BI,
     >  BJ) * MASK(I, JM1, K, BI, BJ) + FLD(I, JP1, BI, BJ) * MASK(I,
     >  JP1, K, BI, BJ)) * 1.25D-01 +(FLD(IM1, JM1, BI, BJ) * MASK(IM1,
     >  JM1, K, BI, BJ) + FLD(IM1, JP1, BI, BJ) * MASK(IM1, JP1, K, BI,
     >  BJ) + FLD(IP1, JM1, BI, BJ) * MASK(IP1, JM1, K, BI, BJ) + FLD(
     > IP1, JP1, BI, BJ) * MASK(IP1, JP1, K, BI, BJ)) * 6.25D-02) /
     >  TEMPVAR)
              ELSE
                FLD_TMP(I, J) = FLD(I, J, BI, BJ)
              ENDIF
            END DO
          END DO
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              FLD(I, J, BI, BJ) = FLD_TMP(I, J)
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_getobcse(MYTIME, MYITER, MYTHID)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE ctrl_getobcsn(MYTIME, MYITER, MYTHID)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE ctrl_getobcss(MYTIME, MYITER, MYTHID)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE ctrl_getobcsw(MYTIME, MYITER, MYTHID)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE ctrl_obcsbal(MYTIME, MYITER, MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ctrl_mod
      use ctrl_dummy_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_init_obcs_variables(MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use ctrl_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) ITHI
      INTEGER(w2f__i4) ITLO
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JTHI
      INTEGER(w2f__i4) JTLO
C
C     **** Statements ****
C
      JTLO = MYBYLO(MYTHID)
      JTHI = MYBYHI(MYTHID)
      ITLO = MYBXLO(MYTHID)
      ITHI = MYBXHI(MYTHID)
      JMIN = -2
      JMAX = 43
      IMIN = -2
      IMAX = 93
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_getrec(THEFIELD, FAC, FIRST, CHANGED, COUNT0,
     >  COUNT1, MYTIME, MYITER, MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use ctrl_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) THEFIELD
      REAL(w2f__8) FAC
      LOGICAL(w2f__i4) FIRST
      LOGICAL(w2f__i4) CHANGED
      INTEGER(w2f__i4) COUNT0
      INTEGER(w2f__i4) COUNT1
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ctrl_volflux(OBCSNCOUNT, SUMAREA, SUMFLUX, MYTHID)
      use w2f__types
      use eeparams_mod
      use size_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use optim_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) OBCSNCOUNT
      REAL(w2f__8) SUMAREA
      REAL(w2f__8) SUMFLUX
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_advection(IMPLICITADVECTION, ADVECTIONSCHEME,
     >  VERTADVECSCHEME, TRACERIDENTITY, UVEL, VVEL, WVEL, TRACER,
     >  GTRACER, BI, BJ, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gad_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      LOGICAL(w2f__i4) IMPLICITADVECTION
      INTEGER(w2f__i4) ADVECTIONSCHEME
      INTEGER(w2f__i4) VERTADVECSCHEME
      INTEGER(w2f__i4) TRACERIDENTITY
      REAL(w2f__8) UVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GTRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) AF(-2 : 93, -2 : 43)
      REAL(w2f__8) AFX(-2 : 93, -2 : 43)
      REAL(w2f__8) AFY(-2 : 93, -2 : 43)
      EXTERNAL calc_common_factors
      LOGICAL(w2f__i4) CALC_FLUXES_X
      LOGICAL(w2f__i4) CALC_FLUXES_Y
      EXTERNAL debug_cs_corner_uv
      LOGICAL(w2f__i4) E_EDGE
      EXTERNAL fill_cs_corner_tr_rl
      EXTERNAL fill_cs_corner_uv_rs
      REAL(w2f__8) FVERT(-2 : 93, -2 : 43, 1 : 2)
      EXTERNAL gad_dst2u1_adv_r
      EXTERNAL gad_dst2u1_adv_x
      EXTERNAL gad_dst2u1_adv_y
      EXTERNAL gad_dst3fl_adv_r
      EXTERNAL gad_dst3fl_adv_x
      EXTERNAL gad_dst3fl_adv_y
      EXTERNAL gad_dst3_adv_r
      EXTERNAL gad_dst3_adv_x
      EXTERNAL gad_dst3_adv_y
      EXTERNAL gad_fluxlimit_adv_r
      EXTERNAL gad_fluxlimit_adv_x
      EXTERNAL gad_fluxlimit_adv_y
      EXTERNAL gmredi_calc_uvflow
      EXTERNAL gmredi_calc_wflow
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAXUPD
      INTEGER(w2f__i4) IMINUPD
      LOGICAL(w2f__i4) INTERIORONLY
      INTEGER(w2f__i4) IPASS
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAXUPD
      INTEGER(w2f__i4) JMINUPD
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KDOWN
      REAL(w2f__8) KP1MSK
      INTEGER(w2f__i4) KUP
      REAL(w2f__8) LOCALTIJ(-2 : 93, -2 : 43)
      REAL(w2f__8) LOCALTIJK(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) MASKLOCS(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCW(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) NCFACE
      INTEGER(w2f__i4) NPASS
      LOGICAL(w2f__i4) N_EDGE
      LOGICAL(w2f__i4) OVERLAPONLY
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANSKP1(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) S_EDGE
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) WITHSIGNS
      LOGICAL(w2f__i4) W_EDGE
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT0 = TRACERIDENTITY
      MAX0 = 2
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IGADKEY = ACT0 + ACT1 * MAX0 + MAX1 * ACT2 * MAX0 + MAX2 * MAX1 *
     >  ACT3 * MAX0 + MAX3 * MAX2 * MAX1 * ACT4 * MAX0
      IF(TRACERIDENTITY .GT. 2) THEN
        WRITE(*, *) 'ph-pass gad_advection ', 2, TRACERIDENTITY
        WRITE(*, *) 'maxpass seems smaller than tracerIdentity'
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          XA(I, J) = 0.0D00
          YA(I, J) = 0.0D00
          UTRANS(I, J) = 0.0D00
          VTRANS(I, J) = 0.0D00
          RTRANS(I, J) = 0.0D00
          FVERT(I, J, 1) = 0.0D00
          FVERT(I, J, 2) = 0.0D00
          RTRANSKP1(I, J) = 0.0D00
          LOCALTIJ(I, J) = 0.0D00
          WFLD(I, J) = 0.0D00
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE) THEN
        NPASS = 3
        IF(NPASS .GT. 1) THEN
C         IF ( npass.GT.maxcube ) PRINT *,'maxcube needs to be = 3'
          WRITE(*, *) 'maxcube needs to be = 3'
        ENDIF
        NCFACE = BI
        N_EDGE = .TRUE.
        S_EDGE = .TRUE.
        E_EDGE = .TRUE.
        W_EDGE = .TRUE.
      ELSE
        NPASS = 2
        NCFACE = 0
        N_EDGE = .FALSE.
        S_EDGE = .FALSE.
        E_EDGE = .FALSE.
        W_EDGE = .FALSE.
      ENDIF
      DO K = 1, 15, 1
        KKEY = K + IGADKEY * 15 +(-15)
        CALL calc_common_factors(UVEL, VVEL, UFLD, VFLD, UTRANS, VTRANS
     > , XA, YA, (K), BI, BJ, MYTHID)
        IF(USEGMREDI) THEN
          CALL gmredi_calc_uvflow(UFLD, VFLD, UTRANS, VTRANS, (K), BI,
     >  BJ, MYTHID)
        ENDIF
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            LOCALTIJ(I, J) = TRACER(I, J, K, BI, BJ)
            MASKLOCW(I, J) = MASKW(I, J, K, BI, BJ)
            MASKLOCS(I, J) = MASKS(I, J, K, BI, BJ)
          END DO
        END DO
        IF(USECUBEDSPHEREEXCHANGE) THEN
          WITHSIGNS = .FALSE.
          CALL fill_cs_corner_uv_rs(WITHSIGNS, MASKLOCW, MASKLOCS, BI,
     >  BJ, MYTHID)
        ENDIF
        DO IPASS = 1, NPASS, 1
          PASSKEY = IPASS + K * 2 + IGADKEY * 30 +(-32)
          IF(NPASS .GT. 2) THEN
            WRITE(*, *) 'GAD_ADVECTION: npass > maxcube. check tamc.h'
          ENDIF
          INTERIORONLY = .FALSE.
          OVERLAPONLY = .FALSE.
          IF(USECUBEDSPHEREEXCHANGE) THEN
            IF(IPASS .eq. 1) THEN
              OVERLAPONLY = MOD(NCFACE, 3) .eq. 0
              INTERIORONLY = MOD(NCFACE, 3) .ne. 0
              CALC_FLUXES_X = (NCFACE .eq. 2) .OR.((NCFACE .eq. 1) .OR.
     > (NCFACE .eq. 6))
              CALC_FLUXES_Y = (NCFACE .eq. 5) .OR.((NCFACE .eq. 3) .OR.
     > (NCFACE .eq. 4))
            ELSE
              IF(IPASS .eq. 2) THEN
                OVERLAPONLY = MOD(NCFACE, 3) .eq. 2
                INTERIORONLY = MOD(NCFACE, 3) .eq. 1
                CALC_FLUXES_X = (NCFACE .eq. 4) .OR.((NCFACE .eq. 2)
     >  .OR.(NCFACE .eq. 3))
                CALC_FLUXES_Y = (NCFACE .eq. 1) .OR.((NCFACE .eq. 5)
     >  .OR.(NCFACE .eq. 6))
              ELSE
                INTERIORONLY = .TRUE.
                CALC_FLUXES_X = (NCFACE .eq. 5) .OR.(NCFACE .eq. 6)
                CALC_FLUXES_Y = (NCFACE .eq. 2) .OR.(NCFACE .eq. 3)
              ENDIF
            ENDIF
          ELSE
            CALC_FLUXES_X = MOD(IPASS, 2) .eq. 1
            CALC_FLUXES_Y = .NOT. CALC_FLUXES_X
          ENDIF
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              AF(I, J) = 0.0D00
            END DO
          END DO
          IF(CALC_FLUXES_X) THEN
            IF(S_EDGE .OR.(N_EDGE .OR.(.NOT. OVERLAPONLY))) THEN
              IF(OVERLAPONLY) THEN
                CALL fill_cs_corner_tr_rl((1), (.FALSE.), LOCALTIJ, BI,
     >  BJ, MYTHID)
              ENDIF
              IF((ADVECTIONSCHEME .eq. 1) .OR.(ADVECTIONSCHEME .eq. 20)
     > ) THEN
                CALL gad_dst2u1_adv_x(BI, BJ, (K), ADVECTIONSCHEME, (
     > .TRUE.), DTTRACERLEV(K), UTRANS, UFLD, LOCALTIJ, AF, MYTHID)
              ELSE
                IF(ADVECTIONSCHEME .eq. 77) THEN
                  CALL gad_fluxlimit_adv_x(BI, BJ, (K), (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, MASKLOCW, LOCALTIJ, AF, MYTHID)
                ELSE
                  IF(ADVECTIONSCHEME .eq. 30) THEN
                    CALL gad_dst3_adv_x(BI, BJ, (K), (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, MASKLOCW, LOCALTIJ, AF, MYTHID)
                  ELSE
                    IF(ADVECTIONSCHEME .eq. 33) THEN
                      CALL gad_dst3fl_adv_x(BI, BJ, (K), (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, MASKLOCW, LOCALTIJ, AF, MYTHID)
                    ELSE
                      WRITE(*, *)
     >  'GAD_ADVECTION: adv. scheme incompatibale with mu' // 'lti-dim'
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
              IF((IPASS .eq. 1) .AND. OVERLAPONLY) THEN
                CALL fill_cs_corner_tr_rl((2), (.FALSE.), LOCALTIJ, BI,
     >  BJ, MYTHID)
              ENDIF
            ENDIF
            IF(OVERLAPONLY) THEN
              IMINUPD = -1
              IMAXUPD = 92
              IF(W_EDGE) THEN
                IMINUPD = 1
              ENDIF
              IF(E_EDGE) THEN
                IMAXUPD = 90
              ENDIF
              IF(S_EDGE) THEN
                DO J = -2, 0, 1
                  DO I = IMINUPD, IMAXUPD, 1
                    LOCALTIJ(I, J) = (LOCALTIJ(I, J) - RECIP_DEEPFAC2C(
     > K) * RECIP_RA(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACC(I, J, K
     > , BI, BJ) * DTTRACERLEV(K) * RECIP_RHOFACC(K) *(AF(I + 1, J) -
     >  AF(I, J) - TRACER(I, J, K, BI, BJ) *(UTRANS(I + 1, J) - UTRANS(
     > I, J))))
                  END DO
                END DO
              ENDIF
              IF(N_EDGE) THEN
                DO J = 41, 43, 1
                  DO I = IMINUPD, IMAXUPD, 1
                    LOCALTIJ(I, J) = (LOCALTIJ(I, J) - RECIP_DEEPFAC2C(
     > K) * RECIP_RA(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACC(I, J, K
     > , BI, BJ) * DTTRACERLEV(K) * RECIP_RHOFACC(K) *(AF(I + 1, J) -
     >  AF(I, J) - TRACER(I, J, K, BI, BJ) *(UTRANS(I + 1, J) - UTRANS(
     > I, J))))
                  END DO
                END DO
              ENDIF
            ELSE
              JMINUPD = -2
              JMAXUPD = 43
              IF(INTERIORONLY .AND. S_EDGE) THEN
                JMINUPD = 1
              ENDIF
              IF(INTERIORONLY .AND. N_EDGE) THEN
                JMAXUPD = 40
              ENDIF
              DO J = JMINUPD, JMAXUPD, 1
                DO I = -1, 92, 1
                  LOCALTIJ(I, J) = (LOCALTIJ(I, J) - RECIP_DEEPFAC2C(K)
     >  * RECIP_RA(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACC(I, J, K,
     >  BI, BJ) * DTTRACERLEV(K) * RECIP_RHOFACC(K) *(AF(I + 1, J) - AF
     > (I, J) - TRACER(I, J, K, BI, BJ) *(UTRANS(I + 1, J) - UTRANS(I,
     >  J))))
                END DO
              END DO
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  AFX(I, J) = AF(I, J)
                END DO
              END DO
            ENDIF
          ENDIF
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              AF(I, J) = 0.0D00
            END DO
          END DO
          IF(CALC_FLUXES_Y) THEN
            IF(W_EDGE .OR.(E_EDGE .OR.(.NOT. OVERLAPONLY))) THEN
              IF(OVERLAPONLY) THEN
                CALL fill_cs_corner_tr_rl((2), (.FALSE.), LOCALTIJ, BI,
     >  BJ, MYTHID)
              ENDIF
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  AF(I, J) = 0.0D00
                END DO
              END DO
              IF((ADVECTIONSCHEME .eq. 1) .OR.(ADVECTIONSCHEME .eq. 20)
     > ) THEN
                CALL gad_dst2u1_adv_y(BI, BJ, (K), ADVECTIONSCHEME, (
     > .TRUE.), DTTRACERLEV(K), VTRANS, VFLD, LOCALTIJ, AF, MYTHID)
              ELSE
                IF(ADVECTIONSCHEME .eq. 77) THEN
                  CALL gad_fluxlimit_adv_y(BI, BJ, (K), (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, MASKLOCS, LOCALTIJ, AF, MYTHID)
                ELSE
                  IF(ADVECTIONSCHEME .eq. 30) THEN
                    CALL gad_dst3_adv_y(BI, BJ, (K), (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, MASKLOCS, LOCALTIJ, AF, MYTHID)
                  ELSE
                    IF(ADVECTIONSCHEME .eq. 33) THEN
                      CALL gad_dst3fl_adv_y(BI, BJ, (K), (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, MASKLOCS, LOCALTIJ, AF, MYTHID)
                    ELSE
                      WRITE(*, *)
     >  'GAD_ADVECTION: adv. scheme incompatibale with mu' // 'tli-dim'
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
              IF((IPASS .eq. 1) .AND. OVERLAPONLY) THEN
                CALL fill_cs_corner_tr_rl((1), (.FALSE.), LOCALTIJ, BI,
     >  BJ, MYTHID)
              ENDIF
            ENDIF
            IF(OVERLAPONLY) THEN
              JMINUPD = -1
              JMAXUPD = 42
              IF(S_EDGE) THEN
                JMINUPD = 1
              ENDIF
              IF(N_EDGE) THEN
                JMAXUPD = 40
              ENDIF
              IF(W_EDGE) THEN
                DO J = JMINUPD, JMAXUPD, 1
                  DO I = -2, 0, 1
                    LOCALTIJ(I, J) = (LOCALTIJ(I, J) - RECIP_DEEPFAC2C(
     > K) * RECIP_RA(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACC(I, J, K
     > , BI, BJ) * DTTRACERLEV(K) * RECIP_RHOFACC(K) *(AF(I, J + 1) -
     >  AF(I, J) - TRACER(I, J, K, BI, BJ) *(VTRANS(I, J + 1) - VTRANS(
     > I, J))))
                  END DO
                END DO
              ENDIF
              IF(E_EDGE) THEN
                DO J = JMINUPD, JMAXUPD, 1
                  DO I = 91, 93, 1
                    LOCALTIJ(I, J) = (LOCALTIJ(I, J) - RECIP_DEEPFAC2C(
     > K) * RECIP_RA(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACC(I, J, K
     > , BI, BJ) * DTTRACERLEV(K) * RECIP_RHOFACC(K) *(AF(I, J + 1) -
     >  AF(I, J) - TRACER(I, J, K, BI, BJ) *(VTRANS(I, J + 1) - VTRANS(
     > I, J))))
                  END DO
                END DO
              ENDIF
            ELSE
              IMINUPD = -2
              IMAXUPD = 93
              IF(INTERIORONLY .AND. W_EDGE) THEN
                IMINUPD = 1
              ENDIF
              IF(E_EDGE .AND. INTERIORONLY) THEN
                IMAXUPD = 90
              ENDIF
              DO J = -1, 42, 1
                DO I = IMINUPD, IMAXUPD, 1
                  LOCALTIJ(I, J) = (LOCALTIJ(I, J) - RECIP_DEEPFAC2C(K)
     >  * RECIP_RA(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACC(I, J, K,
     >  BI, BJ) * DTTRACERLEV(K) * RECIP_RHOFACC(K) *(AF(I, J + 1) - AF
     > (I, J) - TRACER(I, J, K, BI, BJ) *(VTRANS(I, J + 1) - VTRANS(I,
     >  J))))
                END DO
              END DO
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  AFY(I, J) = AF(I, J)
                END DO
              END DO
            ENDIF
          ENDIF
        END DO
        IF(IMPLICITADVECTION) THEN
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              GTRACER(I, J, K, BI, BJ) = ((LOCALTIJ(I, J) - TRACER(I, J
     > , K, BI, BJ)) / DTTRACERLEV(K))
            END DO
          END DO
        ELSE
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LOCALTIJK(I, J, K) = LOCALTIJ(I, J)
            END DO
          END DO
        ENDIF
        IF(USECUBEDSPHEREEXCHANGE .AND.((MYITER .eq.(NITER0 + 1)) .AND.
     > ((K .LE. 3) .AND.((TRACERIDENTITY .eq. 1) .AND.(DEBUGLEVEL .GE.
     >  2))))) THEN
          CALL debug_cs_corner_uv(' afx,afy from GAD_ADVECTION', AFX,
     >  AFY, (K), STANDARDMESSAGEUNIT, BI, BJ, MYTHID)
        ENDIF
      END DO
      IF(.NOT. IMPLICITADVECTION) THEN
        DO K = 15, 1, (-1)
          KKEY = IGADKEY * 15 - K + 1
          KUP = MOD(K + 1, 2) + 1
          KDOWN = MOD(K, 2) + 1
          KP1MSK = 1.0D00
          IF(K .eq. 15) THEN
            KP1MSK = 0.0D00
          ENDIF
          IF(K .eq. 1) THEN
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                RTRANSKP1(I, J) = (RTRANS(I, J) * KP1MSK)
                WFLD(I, J) = 0.0D00
                RTRANS(I, J) = 0.0D00
                FVERT(I, J, KUP) = 0.0D00
              END DO
            END DO
          ELSE
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                RTRANSKP1(I, J) = (RTRANS(I, J) * KP1MSK)
                WFLD(I, J) = WVEL(I, J, K, BI, BJ)
                RTRANS(I, J) = (MASKC(I, J, K + (-1), BI, BJ) * RHOFACF
     > (K) * DEEPFAC2F(K) * RA(I, J, BI, BJ) * WVEL(I, J, K, BI, BJ))
                FVERT(I, J, KUP) = 0.0D00
              END DO
            END DO
            IF(USEGMREDI) THEN
              CALL gmredi_calc_wflow(WFLD, RTRANS, (K), BI, BJ, MYTHID)
            ENDIF
            IF((VERTADVECSCHEME .eq. 1) .OR.(VERTADVECSCHEME .eq. 20))
     >  THEN
              CALL gad_dst2u1_adv_r(BI, BJ, (K), ADVECTIONSCHEME,
     >  DTTRACERLEV(K), RTRANS, WFLD, LOCALTIJK, FVERT((-2), (-2), KUP)
     > , MYTHID)
            ELSE
              IF(VERTADVECSCHEME .eq. 77) THEN
                CALL gad_fluxlimit_adv_r(BI, BJ, (K), DTTRACERLEV(K),
     >  RTRANS, WFLD, LOCALTIJK, FVERT((-2), (-2), KUP), MYTHID)
              ELSE
                IF(VERTADVECSCHEME .eq. 30) THEN
                  CALL gad_dst3_adv_r(BI, BJ, (K), DTTRACERLEV(K),
     >  RTRANS, WFLD, LOCALTIJK, FVERT((-2), (-2), KUP), MYTHID)
                ELSE
                  IF(VERTADVECSCHEME .eq. 33) THEN
                    CALL gad_dst3fl_adv_r(BI, BJ, (K), DTTRACERLEV(K),
     >  RTRANS, WFLD, LOCALTIJK, FVERT((-2), (-2), KUP), MYTHID)
                  ELSE
                    WRITE(*, *)
     >  'GAD_ADVECTION: adv. scheme incompatibale with mu' // 'tli-dim'
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LOCALTIJ(I, J) = (LOCALTIJK(I, J, K) - RKSIGN *
     >  RECIP_DEEPFAC2C(K) * RECIP_RA(I, J, BI, BJ) * RECIP_DRF(K) *
     >  RECIP_HFACC(I, J, K, BI, BJ) * DTTRACERLEV(K) * RECIP_RHOFACC(K
     > ) *(FVERT(I, J, KDOWN) - FVERT(I, J, KUP) - TRACER(I, J, K, BI,
     >  BJ) *(RTRANSKP1(I, J) - RTRANS(I, J))))
              GTRACER(I, J, K, BI, BJ) = ((LOCALTIJ(I, J) - TRACER(I, J
     > , K, BI, BJ)) / DTTRACERLEV(K))
            END DO
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_biharm_x(BI, BJ, K, XA, DEL2T, DIFFK4, DFX, MYTHID
     > )
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2T(-2 : 93, -2 : 43)
      REAL(w2f__8) DIFFK4
      REAL(w2f__8) DFX(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          DFX(I, J) = (DFX(I, J) + SQCOSFACU(J, BI, BJ) *
     >  RECIP_DEEPFACC(K) * RECIP_DXC(I, J, BI, BJ) * XA(I, J) * DIFFK4
     >  *(DEL2T(I, J) - DEL2T(I + (-1), J)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_biharm_y(BI, BJ, K, YA, DEL2T, DIFFK4, DFY, MYTHID
     > )
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2T(-2 : 93, -2 : 43)
      REAL(w2f__8) DIFFK4
      REAL(w2f__8) DFY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          DFY(I, J) = (DFY(I, J) + RECIP_DEEPFACC(K) * RECIP_DYC(I, J,
     >  BI, BJ) * YA(I, J) * DIFFK4 *(DEL2T(I, J) - DEL2T(I, J + (-1)))
     > )
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_c2_adv_r(BI, BJ, K, RTRANS, TRACER, WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
C
C     **** Statements ****
C
      KM1 = MAX(K +(-1), 1)
      IF((K .eq. 1) .OR.(K .GT. 15)) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WT(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WT(I, J) = (RTRANS(I, J) * MASKC(I, J, KM1, BI, BJ) *(
     > TRACER(I, J, K, BI, BJ) + TRACER(I, J, KM1, BI, BJ)) * 5.0D-01)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_c2_adv_x(BI, BJ, K, UTRANS, TRACER, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          UT(I, J) = (UTRANS(I, J) *(TRACER(I, J) + TRACER(I + (-1), J)
     > ) * 5.0D-01)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_c2_adv_y(BI, BJ, K, VTRANS, TRACER, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
      END DO
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          VT(I, J) = (VTRANS(I, J) *(TRACER(I, J) + TRACER(I, J + (-1))
     > ) * 5.0D-01)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_c4_adv_r(BI, BJ, K, RTRANS, TRACER, WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KM2
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) MASKBOUND
      REAL(w2f__8) MASKPM
      REAL(w2f__8) RJ
      REAL(w2f__8) RJJM
      REAL(w2f__8) RJJP
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
C
C     **** Statements ****
C
      KM2 = MAX(K +(-2), 1)
      KM1 = MAX(K +(-1), 1)
      KP1 = MIN(K + 1, 15)
      MASKPM = 1.0D00
      IF((K .GE. 15) .OR.(K .LE. 2)) THEN
        MASKPM = 0.0D00
      ENDIF
      IF((K .eq. 1) .OR.(K .GT. 15)) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WT(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            MASKBOUND = MASKC(I, J, KP1, BI, BJ) * MASKC(I, J, KM2, BI,
     >  BJ) * MASKPM
            RJP = MASKC(I, J, KP1, BI, BJ) *(TRACER(I, J, KP1, BI, BJ)
     >  - TRACER(I, J, K, BI, BJ))
            RJ = (TRACER(I, J, K, BI, BJ) - TRACER(I, J, KM1, BI, BJ))
            RJM = MASKC(I, J, KM1, BI, BJ) *(TRACER(I, J, KM1, BI, BJ)
     >  - TRACER(I, J, KM2, BI, BJ))
            RJJP = (RJP - RJ)
            RJJM = (RJ - RJM)
            WT(I, J) = (MASKC(I, J, KM1, BI, BJ) *(RTRANS(I, J) *((
     > TRACER(I, J, K, BI, BJ) + TRACER(I, J, KM1, BI, BJ)) * 5.0D-01 -
     > (RJJM + RJJP) * 1.66666666666666657415D-01 * 5.0D-01) + ABS(
     > RTRANS(I, J)) * 1.66666666666666657415D-01 *(RJJM - RJJP) *
     >  5.0D-01 *(1.0D00 - MASKBOUND)))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_c4_adv_x(BI, BJ, K, UTRANS, TRACER, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJJM
      REAL(w2f__8) RJJP
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
        UT((-1), J) = 0.0D00
        UT(93, J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = 0, 92, 1
          RJP = MASKW(I + 1, J, K, BI, BJ) *(TRACER(I + 1, J) - TRACER(
     > I, J))
          RJ = MASKW(I, J, K, BI, BJ) *(TRACER(I, J) - TRACER(I + (-1),
     >  J))
          RJM = MASKW(I + (-1), J, K, BI, BJ) *(TRACER(I + (-1), J) -
     >  TRACER(I + (-2), J))
          RJJP = (RJP - RJ)
          RJJM = (RJ - RJM)
          UT(I, J) = (UTRANS(I, J) *(TRACER(I, J) + TRACER(I + (-1), J)
     >  -(RJJM + RJJP) * 1.66666666666666657415D-01) * 5.0D-01 + ABS(
     > UTRANS(I, J)) * 5.0D-01 * 1.66666666666666657415D-01 *(RJJP -
     >  RJJM) *(1.0D00 - MASKW(I + (-1), J, K, BI, BJ) * MASKW(I + 1, J
     > , K, BI, BJ)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_c4_adv_y(BI, BJ, K, VTRANS, TRACER, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJJM
      REAL(w2f__8) RJJP
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
        VT(I, (-1)) = 0.0D00
        VT(I, 43) = 0.0D00
      END DO
      DO J = 0, 42, 1
        DO I = -2, 93, 1
          RJP = MASKS(I, J + 1, K, BI, BJ) *(TRACER(I, J + 1) - TRACER(
     > I, J))
          RJ = MASKS(I, J, K, BI, BJ) *(TRACER(I, J) - TRACER(I, J + (
     > -1)))
          RJM = MASKS(I, J + (-1), K, BI, BJ) *(TRACER(I, J + (-1)) -
     >  TRACER(I, J + (-2)))
          RJJP = (RJP - RJ)
          RJJM = (RJ - RJM)
          VT(I, J) = (VTRANS(I, J) *(TRACER(I, J) + TRACER(I, J + (-1))
     >  -(RJJM + RJJP) * 1.66666666666666657415D-01) * 5.0D-01 + ABS(
     > VTRANS(I, J)) * 5.0D-01 * 1.66666666666666657415D-01 *(RJJP -
     >  RJJM) *(1.0D00 - MASKS(I, J + (-1), K, BI, BJ) * MASKS(I, J + 1
     > , K, BI, BJ)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_calc_rhs(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KM1,
     >  KUP, KDOWN, XA, YA, MASKUP, UFLD, VFLD, WFLD, UTRANS, VTRANS,
     >  RTRANS, RTRANSKP1, DIFFKH, DIFFK4, KAPPAR, TRACERN, TRACAB,
     >  TRACERIDENTITY, ADVECTIONSCHEME, VERTADVECSCHEME, CALCADVECTION
     > , IMPLICITADVECTION, APPLYAB_ONTRACER, TRUSEGMREDI, TRUSEKPP,
     >  FVERT, GTRACER, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use gad_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KUP
      INTEGER(w2f__i4) KDOWN
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKUP(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANSKP1(-2 : 93, -2 : 43)
      REAL(w2f__8) DIFFKH
      REAL(w2f__8) DIFFK4
      REAL(w2f__8) KAPPAR(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACERN(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) TRACAB(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) TRACERIDENTITY
      INTEGER(w2f__i4) ADVECTIONSCHEME
      INTEGER(w2f__i4) VERTADVECSCHEME
      LOGICAL(w2f__i4) CALCADVECTION
      LOGICAL(w2f__i4) IMPLICITADVECTION
      LOGICAL(w2f__i4) APPLYAB_ONTRACER
      LOGICAL(w2f__i4) TRUSEGMREDI
      LOGICAL(w2f__i4) TRUSEKPP
      REAL(w2f__8) FVERT(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) GTRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) ADVFAC
      REAL(w2f__8) AF(-2 : 93, -2 : 43)
      EXTERNAL debug_cs_corner_uv
      REAL(w2f__8) DF(-2 : 93, -2 : 43)
      REAL(w2f__8) DF4(-2 : 93, -2 : 43)
      REAL(w2f__8) FMER(-2 : 93, -2 : 43)
      REAL(w2f__8) FZON(-2 : 93, -2 : 43)
      EXTERNAL gad_biharm_x
      EXTERNAL gad_biharm_y
      EXTERNAL gad_c2_adv_r
      EXTERNAL gad_c2_adv_x
      EXTERNAL gad_c2_adv_y
      EXTERNAL gad_c4_adv_r
      EXTERNAL gad_c4_adv_x
      EXTERNAL gad_c4_adv_y
      EXTERNAL gad_del2
      EXTERNAL gad_diff_r
      EXTERNAL gad_diff_x
      EXTERNAL gad_diff_y
      EXTERNAL gad_dst2u1_adv_r
      EXTERNAL gad_dst2u1_adv_x
      EXTERNAL gad_dst2u1_adv_y
      EXTERNAL gad_dst3fl_adv_r
      EXTERNAL gad_dst3fl_adv_x
      EXTERNAL gad_dst3fl_adv_y
      EXTERNAL gad_dst3_adv_r
      EXTERNAL gad_dst3_adv_x
      EXTERNAL gad_dst3_adv_y
      EXTERNAL gad_fluxlimit_adv_r
      EXTERNAL gad_fluxlimit_adv_x
      EXTERNAL gad_fluxlimit_adv_y
      EXTERNAL gad_grad_x
      EXTERNAL gad_grad_y
      EXTERNAL gad_os7mp_adv_r
      EXTERNAL gad_os7mp_adv_x
      EXTERNAL gad_os7mp_adv_y
      EXTERNAL gad_u3_adv_r
      EXTERNAL gad_u3_adv_x
      EXTERNAL gad_u3_adv_y
      EXTERNAL gmredi_rtransport
      EXTERNAL gmredi_xtransport
      EXTERNAL gmredi_ytransport
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) LOCABT(-2 : 93, -2 : 43)
      REAL(w2f__8) LOCALT(-2 : 93, -2 : 43)
      REAL(w2f__8) RADVFAC
C
C     **** Statements ****
C
      ADVFAC = 0.0D00
      IF(CALCADVECTION) THEN
        ADVFAC = 1.0D00
      ENDIF
      RADVFAC = ADVFAC * RKSIGN
      IF(IMPLICITADVECTION) THEN
        RADVFAC = 0.0D00
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          FZON(I, J) = 0.0D00
          FMER(I, J) = 0.0D00
          FVERT(I, J, KUP) = 0.0D00
          DF(I, J) = 0.0D00
          DF4(I, J) = 0.0D00
        END DO
      END DO
      IF(APPLYAB_ONTRACER) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            LOCALT(I, J) = TRACERN(I, J, K, BI, BJ)
            LOCABT(I, J) = TRACAB(I, J, K, BI, BJ)
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            LOCALT(I, J) = TRACAB(I, J, K, BI, BJ)
            LOCABT(I, J) = TRACAB(I, J, K, BI, BJ)
          END DO
        END DO
      ENDIF
      IF(DIFFK4 .ne. 0.0D00) THEN
        CALL gad_grad_x(BI, BJ, K, XA, LOCALT, FZON, MYTHID)
        CALL gad_grad_y(BI, BJ, K, YA, LOCALT, FMER, MYTHID)
        CALL gad_del2(BI, BJ, K, FZON, FMER, DF4, MYTHID)
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          FZON(I, J) = 0.0D00
        END DO
      END DO
      IF(CALCADVECTION) THEN
        IF(ADVECTIONSCHEME .eq. 2) THEN
          CALL gad_c2_adv_x(BI, BJ, K, UTRANS, LOCABT, AF, MYTHID)
        ELSE
          IF((ADVECTIONSCHEME .eq. 1) .OR.(ADVECTIONSCHEME .eq. 20))
     >  THEN
            CALL gad_dst2u1_adv_x(BI, BJ, K, ADVECTIONSCHEME, (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, LOCABT, AF, MYTHID)
          ELSE
            IF(ADVECTIONSCHEME .eq. 77) THEN
              CALL gad_fluxlimit_adv_x(BI, BJ, K, (.TRUE.), DTTRACERLEV
     > (K), UTRANS, UFLD, MASKW((-2), (-2), K, BI, BJ), LOCABT, AF,
     >  MYTHID)
            ELSE
              IF(ADVECTIONSCHEME .eq. 3) THEN
                CALL gad_u3_adv_x(BI, BJ, K, UTRANS, LOCABT, AF, MYTHID
     > )
              ELSE
                IF(ADVECTIONSCHEME .eq. 4) THEN
                  CALL gad_c4_adv_x(BI, BJ, K, UTRANS, LOCABT, AF,
     >  MYTHID)
                ELSE
                  IF(ADVECTIONSCHEME .eq. 30) THEN
                    CALL gad_dst3_adv_x(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, MASKW((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                  ELSE
                    IF(ADVECTIONSCHEME .eq. 33) THEN
                      IF(INADMODE) THEN
                        CALL gad_dst3_adv_x(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, MASKW((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                      ELSE
                        CALL gad_dst3fl_adv_x(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, MASKW((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                      ENDIF
                    ELSE
                      IF(ADVECTIONSCHEME .eq. 7) THEN
                        CALL gad_os7mp_adv_x(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), UTRANS, UFLD, MASKW((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                      ELSE
                        WRITE(*, *)
     >  'GAD_CALC_RHS: Bad advectionScheme (X)'
                      ENDIF
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            FZON(I, J) = (AF(I, J) + FZON(I, J))
          END DO
        END DO
      ENDIF
      IF(DIFFKH .ne. 0.0D00) THEN
        CALL gad_diff_x(BI, BJ, K, XA, DIFFKH, LOCALT, DF, MYTHID)
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DF(I, J) = 0.0D00
          END DO
        END DO
      ENDIF
      IF(DIFFK4 .ne. 0.0D00) THEN
        CALL gad_biharm_x(BI, BJ, K, XA, DF4, DIFFK4, DF, MYTHID)
      ENDIF
      IF(TRUSEGMREDI) THEN
        IF(APPLYAB_ONTRACER) THEN
          CALL gmredi_xtransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K, XA,
     >  TRACERN, TRACERIDENTITY, DF, MYTHID)
        ELSE
          CALL gmredi_xtransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K, XA,
     >  TRACAB, TRACERIDENTITY, DF, MYTHID)
        ENDIF
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          FZON(I, J) = (FZON(I, J) + RHOFACC(K) * DF(I, J))
        END DO
      END DO
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          FMER(I, J) = 0.0D00
        END DO
      END DO
      IF(CALCADVECTION) THEN
        IF(ADVECTIONSCHEME .eq. 2) THEN
          CALL gad_c2_adv_y(BI, BJ, K, VTRANS, LOCABT, AF, MYTHID)
        ELSE
          IF((ADVECTIONSCHEME .eq. 1) .OR.(ADVECTIONSCHEME .eq. 20))
     >  THEN
            CALL gad_dst2u1_adv_y(BI, BJ, K, ADVECTIONSCHEME, (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, LOCABT, AF, MYTHID)
          ELSE
            IF(ADVECTIONSCHEME .eq. 77) THEN
              CALL gad_fluxlimit_adv_y(BI, BJ, K, (.TRUE.), DTTRACERLEV
     > (K), VTRANS, VFLD, MASKS((-2), (-2), K, BI, BJ), LOCABT, AF,
     >  MYTHID)
            ELSE
              IF(ADVECTIONSCHEME .eq. 3) THEN
                CALL gad_u3_adv_y(BI, BJ, K, VTRANS, LOCABT, AF, MYTHID
     > )
              ELSE
                IF(ADVECTIONSCHEME .eq. 4) THEN
                  CALL gad_c4_adv_y(BI, BJ, K, VTRANS, LOCABT, AF,
     >  MYTHID)
                ELSE
                  IF(ADVECTIONSCHEME .eq. 30) THEN
                    CALL gad_dst3_adv_y(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, MASKS((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                  ELSE
                    IF(ADVECTIONSCHEME .eq. 33) THEN
                      IF(INADMODE) THEN
                        CALL gad_dst3_adv_y(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, MASKS((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                      ELSE
                        CALL gad_dst3fl_adv_y(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, MASKS((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                      ENDIF
                    ELSE
                      IF(ADVECTIONSCHEME .eq. 7) THEN
                        CALL gad_os7mp_adv_y(BI, BJ, K, (.TRUE.),
     >  DTTRACERLEV(K), VTRANS, VFLD, MASKS((-2), (-2), K, BI, BJ),
     >  LOCABT, AF, MYTHID)
                      ELSE
                        WRITE(*, *)
     >  'GAD_CALC_RHS: Bad advectionScheme (Y)'
                      ENDIF
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            FMER(I, J) = (AF(I, J) + FMER(I, J))
          END DO
        END DO
      ENDIF
      IF(DIFFKH .ne. 0.0D00) THEN
        CALL gad_diff_y(BI, BJ, K, YA, DIFFKH, LOCALT, DF, MYTHID)
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DF(I, J) = 0.0D00
          END DO
        END DO
      ENDIF
      IF(DIFFK4 .ne. 0.0D00) THEN
        CALL gad_biharm_y(BI, BJ, K, YA, DF4, DIFFK4, DF, MYTHID)
      ENDIF
      IF(TRUSEGMREDI) THEN
        IF(APPLYAB_ONTRACER) THEN
          CALL gmredi_ytransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K, YA,
     >  TRACERN, TRACERIDENTITY, DF, MYTHID)
        ELSE
          CALL gmredi_ytransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K, YA,
     >  TRACAB, TRACERIDENTITY, DF, MYTHID)
        ENDIF
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          FMER(I, J) = (FMER(I, J) + RHOFACC(K) * DF(I, J))
        END DO
      END DO
      IF((K .GE. 2) .AND.(CALCADVECTION .AND.(.NOT. IMPLICITADVECTION))
     > ) THEN
        IF(VERTADVECSCHEME .eq. 2) THEN
          CALL gad_c2_adv_r(BI, BJ, K, RTRANS, TRACAB, AF, MYTHID)
        ELSE
          IF((VERTADVECSCHEME .eq. 1) .OR.(VERTADVECSCHEME .eq. 20))
     >  THEN
            CALL gad_dst2u1_adv_r(BI, BJ, K, VERTADVECSCHEME,
     >  DTTRACERLEV(K), RTRANS, WFLD, TRACAB((-2), (-2), 1, BI, BJ), AF
     > , MYTHID)
          ELSE
            IF(VERTADVECSCHEME .eq. 77) THEN
              CALL gad_fluxlimit_adv_r(BI, BJ, K, DTTRACERLEV(K),
     >  RTRANS, WFLD, TRACAB((-2), (-2), 1, BI, BJ), AF, MYTHID)
            ELSE
              IF(VERTADVECSCHEME .eq. 3) THEN
                CALL gad_u3_adv_r(BI, BJ, K, RTRANS, TRACAB, AF, MYTHID
     > )
              ELSE
                IF(VERTADVECSCHEME .eq. 4) THEN
                  CALL gad_c4_adv_r(BI, BJ, K, RTRANS, TRACAB, AF,
     >  MYTHID)
                ELSE
                  IF(VERTADVECSCHEME .eq. 30) THEN
                    CALL gad_dst3_adv_r(BI, BJ, K, DTTRACERLEV(K),
     >  RTRANS, WFLD, TRACAB((-2), (-2), 1, BI, BJ), AF, MYTHID)
                  ELSE
                    IF(VERTADVECSCHEME .eq. 33) THEN
                      IF(INADMODE) THEN
                        CALL gad_dst3_adv_r(BI, BJ, K, DTTRACERLEV(K),
     >  RTRANS, WFLD, TRACAB((-2), (-2), 1, BI, BJ), AF, MYTHID)
                      ELSE
                        CALL gad_dst3fl_adv_r(BI, BJ, K, DTTRACERLEV(K)
     > , RTRANS, WFLD, TRACAB((-2), (-2), 1, BI, BJ), AF, MYTHID)
                      ENDIF
                    ELSE
                      IF(VERTADVECSCHEME .eq. 7) THEN
                        CALL gad_os7mp_adv_r(BI, BJ, K, DTTRACERLEV(K),
     >  RTRANS, WFLD, TRACAB((-2), (-2), 1, BI, BJ), AF, MYTHID)
                      ELSE
                        WRITE(*, *)
     >  'GAD_CALC_RHS: Bad vertAdvecScheme (R)'
                      ENDIF
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            FVERT(I, J, KUP) = (AF(I, J) + FVERT(I, J, KUP))
          END DO
        END DO
      ENDIF
      IF(IMPLICITDIFFUSION) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DF(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        IF(APPLYAB_ONTRACER) THEN
          CALL gad_diff_r(BI, BJ, K, KAPPAR, TRACERN, DF, MYTHID)
        ELSE
          CALL gad_diff_r(BI, BJ, K, KAPPAR, TRACAB, DF, MYTHID)
        ENDIF
      ENDIF
      IF(TRUSEGMREDI) THEN
        IF(APPLYAB_ONTRACER) THEN
          CALL gmredi_rtransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  TRACERN, TRACERIDENTITY, DF, MYTHID)
        ELSE
          CALL gmredi_rtransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  TRACAB, TRACERIDENTITY, DF, MYTHID)
        ENDIF
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          FVERT(I, J, KUP) = (FVERT(I, J, KUP) + MASKUP(I, J) * DF(I, J
     > ))
        END DO
      END DO
      DO J = -2, 42, 1
        DO I = -2, 92, 1
          GTRACER(I, J, K, BI, BJ) = (GTRACER(I, J, K, BI, BJ) -
     >  RECIP_RHOFACC(K) * RECIP_DEEPFAC2C(K) * RECIP_RA(I, J, BI, BJ)
     >  * RECIP_DRF(K) * RECIP_HFACC(I, J, K, BI, BJ) *((FMER(I, J + 1)
     >  - FMER(I, J)) +(FZON(I + 1, J) - FZON(I, J)) + RKSIGN *(FVERT(I
     > , J, KDOWN) - FVERT(I, J, KUP)) - ADVFAC * LOCALT(I, J) *((
     > UTRANS(I + 1, J) - UTRANS(I, J)) +(VTRANS(I, J + 1) - VTRANS(I,
     >  J)) + RADVFAC *(RTRANSKP1(I, J) - RTRANS(I, J)))))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE .AND.((MYITER .eq.(NITER0 + 1)) .AND.((
     > K .eq. 2) .AND.((TRACERIDENTITY .eq. 1) .AND.(DEBUGLEVEL .GE. 2)
     > )))) THEN
        CALL debug_cs_corner_uv(' fZon,fMer from GAD_CALC_RHS', FZON,
     >  FMER, K, STANDARDMESSAGEUNIT, BI, BJ, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_del2(BI, BJ, K, DTDX, DTDY, DEL2, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) DTDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DTDY(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          DEL2(I, J) = 0.0D00
        END DO
      END DO
      DO J = -2, 42, 1
        DO I = -2, 92, 1
          DEL2(I, J) = (RECIP_HFACC(I, J, K, BI, BJ) * RECIP_DRF(K) *
     >  RECIP_DEEPFAC2C(K) * RECIP_RA(I, J, BI, BJ) *((DTDX(I + 1, J) -
     >  DTDX(I, J)) +(DTDY(I, J + 1) - DTDY(I, J))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_diff_r(BI, BJ, K, KAPPAR, TRACER, DFR, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) KAPPAR(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) DFR(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
C
C     **** Statements ****
C
      KM1 = MAX(K +(-1), 1)
      IF((K .eq. 1) .OR.(K .GT. 15)) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DFR(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DFR(I, J) = (-(RKSIGN * RECIP_DRC(K) * RHOFACF(K) *
     >  DEEPFAC2F(K) * KAPPAR(I, J) * RA(I, J, BI, BJ) *(TRACER(I, J, K
     > , BI, BJ) - TRACER(I, J, KM1, BI, BJ))))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_diff_x(BI, BJ, K, XA, DIFFKH, TRACER, DFX, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) DIFFKH
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) DFX(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DFX((-2), J) = 0.0D00
        DO I = -1, 93, 1
          DFX(I, J) = (-(COSFACU(J, BI, BJ) * RECIP_DEEPFACC(K) *
     >  RECIP_DXC(I, J, BI, BJ) * XA(I, J) * DIFFKH *(TRACER(I, J) -
     >  TRACER(I + (-1), J))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_diff_y(BI, BJ, K, YA, DIFFKH, TRACER, DFY, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      REAL(w2f__8) DIFFKH
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) DFY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        DFY(I, (-2)) = 0.0D00
      END DO
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          DFY(I, J) = (-(RECIP_DEEPFACC(K) * RECIP_DYC(I, J, BI, BJ) *
     >  YA(I, J) * DIFFKH *(TRACER(I, J) - TRACER(I, J + (-1)))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst2u1_adv_r(BI, BJ, K, ADVECTIONSCHEME, DELTATLOC
     > , RTRANS, WFLD, TRACER, WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) ADVECTIONSCHEME
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      REAL(w2f__8) RLIMIT
      REAL(w2f__8) WABS
      REAL(w2f__8) WCFL
      REAL(w2f__8) WLOC
C
C     **** Statements ****
C
      RLIMIT = 0.0D00
      IF(ADVECTIONSCHEME .eq. 20) THEN
        RLIMIT = 1.0D00
      ENDIF
      KM1 = MAX(K +(-1), 1)
      IF((K .GT. 15) .OR.(K .LE. 1)) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WT(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WLOC = WFLD(I, J)
            WCFL = ABS(RECIP_DRC(K) * DELTATLOC * WLOC)
            WABS = RKSIGN * ABS(RTRANS(I, J)) *(1.0D00 - RLIMIT *(
     > 1.0D00 - WCFL))
            WT(I, J) = (MASKC(I, J, KM1, BI, BJ) *(TRACER(I, J, K) *(
     > RTRANS(I, J) - WABS) * 5.0D-01 + TRACER(I, J, KM1) *(RTRANS(I, J
     > ) + WABS) * 5.0D-01))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst2u1_adv_x(BI, BJ, K, ADVECTIONSCHEME, CALCCFL,
     >  DELTATLOC, UTRANS, UFLD, TRACER, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) ADVECTIONSCHEME
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) UABS
      REAL(w2f__8) UCFL
      REAL(w2f__8) XLIMIT
C
C     **** Statements ****
C
      XLIMIT = 0.0D00
      IF(ADVECTIONSCHEME .eq. 20) THEN
        XLIMIT = 1.0D00
      ENDIF
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          UCFL = UFLD(I, J)
          IF(CALCCFL) THEN
            UCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DXC(I, J, BI, BJ) *
     >  UFLD(I, J) * DELTATLOC)
          ENDIF
          UABS = ABS(UTRANS(I, J)) *(1.0D00 - XLIMIT *(1.0D00 - UCFL))
          UT(I, J) = (TRACER(I, J) *(UTRANS(I, J) - UABS) * 5.0D-01 +
     >  TRACER(I + (-1), J) *(UTRANS(I, J) + UABS) * 5.0D-01)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst2u1_adv_y(BI, BJ, K, ADVECTIONSCHEME, CALCCFL,
     >  DELTATLOC, VTRANS, VFLD, TRACER, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) ADVECTIONSCHEME
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) VABS
      REAL(w2f__8) VCFL
      REAL(w2f__8) YLIMIT
C
C     **** Statements ****
C
      YLIMIT = 0.0D00
      IF(ADVECTIONSCHEME .eq. 20) THEN
        YLIMIT = 1.0D00
      ENDIF
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
      END DO
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          VCFL = VFLD(I, J)
          IF(CALCCFL) THEN
            VCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DYC(I, J, BI, BJ) *
     >  VFLD(I, J) * DELTATLOC)
          ENDIF
          VABS = ABS(VTRANS(I, J)) *(1.0D00 - YLIMIT *(1.0D00 - VCFL))
          VT(I, J) = (TRACER(I, J) *(VTRANS(I, J) - VABS) * 5.0D-01 +
     >  TRACER(I, J + (-1)) *(VTRANS(I, J) + VABS) * 5.0D-01)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst3_adv_x(BI, BJ, K, CALCCFL, DELTATLOC, UTRANS,
     >  UFLD, MASKLOCW, TRACER, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCW(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) D0
      REAL(w2f__8) D1
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) UCFL
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
        UT((-1), J) = 0.0D00
        UT(93, J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = 0, 92, 1
          RJP = MASKLOCW(I + 1, J) *(TRACER(I + 1, J) - TRACER(I, J))
          RJ = MASKLOCW(I, J) *(TRACER(I, J) - TRACER(I + (-1), J))
          RJM = MASKLOCW(I + (-1), J) *(TRACER(I + (-1), J) - TRACER(I
     >  + (-2), J))
          UCFL = UFLD(I, J)
          IF(CALCCFL) THEN
            UCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DXC(I, J, BI, BJ) *
     >  UFLD(I, J) * DELTATLOC)
          ENDIF
          D0 = (2.0D00 - UCFL) *(1.0D00 - UCFL) *
     >  1.66666666666666657415D-01
          D1 = (1.0D00 - UCFL * UCFL) * 1.66666666666666657415D-01
          UT(I, J) = ((UTRANS(I, J) + ABS(UTRANS(I, J))) * 5.0D-01 *(
     > TRACER(I + (-1), J) +(D0 * RJ + D1 * RJM)) +(UTRANS(I, J) - ABS(
     > UTRANS(I, J))) * 5.0D-01 *(TRACER(I, J) -(D0 * RJ + D1 * RJP)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst3_adv_y(BI, BJ, K, CALCCFL, DELTATLOC, VTRANS,
     >  VFLD, MASKLOCS, TRACER, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) D0
      REAL(w2f__8) D1
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) VCFL
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
        VT(I, (-1)) = 0.0D00
        VT(I, 43) = 0.0D00
      END DO
      DO J = 0, 42, 1
        DO I = -2, 93, 1
          RJP = MASKLOCS(I, J + 1) *(TRACER(I, J + 1) - TRACER(I, J))
          RJ = MASKLOCS(I, J) *(TRACER(I, J) - TRACER(I, J + (-1)))
          RJM = MASKLOCS(I, J + (-1)) *(TRACER(I, J + (-1)) - TRACER(I,
     >  J + (-2)))
          VCFL = VFLD(I, J)
          IF(CALCCFL) THEN
            VCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DYC(I, J, BI, BJ) *
     >  VFLD(I, J) * DELTATLOC)
          ENDIF
          D0 = (2.0D00 - VCFL) *(1.0D00 - VCFL) *
     >  1.66666666666666657415D-01
          D1 = (1.0D00 - VCFL * VCFL) * 1.66666666666666657415D-01
          VT(I, J) = ((VTRANS(I, J) + ABS(VTRANS(I, J))) * 5.0D-01 *(
     > TRACER(I, J + (-1)) +(D0 * RJ + D1 * RJM)) +(VTRANS(I, J) - ABS(
     > VTRANS(I, J))) * 5.0D-01 *(TRACER(I, J) -(D0 * RJ + D1 * RJP)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst3_adv_r(BI, BJ, K, DTARG, RTRANS, WFLD, TRACER,
     >  WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) DTARG
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) CFL
      REAL(w2f__8) D0
      REAL(w2f__8) D1
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KM2
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) WLOC
C
C     **** Statements ****
C
      KM2 = MAX(K +(-2), 1)
      KM1 = MAX(K +(-1), 1)
      KP1 = MIN(K + 1, 15)
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          RJP = MASKC(I, J, KP1, BI, BJ) *(TRACER(I, J, K) - TRACER(I,
     >  J, KP1))
          RJ = MASKC(I, J, KM1, BI, BJ) * MASKC(I, J, K, BI, BJ) *(
     > TRACER(I, J, KM1) - TRACER(I, J, K))
          RJM = MASKC(I, J, KM1, BI, BJ) *(TRACER(I, J, KM2) - TRACER(I
     > , J, KM1))
          WLOC = WFLD(I, J)
          CFL = ABS(RECIP_DRC(K) * DTARG * WLOC)
          D0 = (2.0D00 - CFL) *(1.0D00 - CFL) *
     >  1.66666666666666657415D-01
          D1 = (1.0D00 - CFL * CFL) * 1.66666666666666657415D-01
          WT(I, J) = ((RTRANS(I, J) + ABS(RTRANS(I, J))) * 5.0D-01 *(
     > TRACER(I, J, K) +(D0 * RJ + D1 * RJP)) +(RTRANS(I, J) - ABS(
     > RTRANS(I, J))) * 5.0D-01 *(TRACER(I, J, KM1) -(D0 * RJ + D1 *
     >  RJM)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst3fl_adv_x(BI, BJ, K, CALCCFL, DELTATLOC, UTRANS
     > , UFLD, MASKLOCW, TRACER, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCW(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) D0
      REAL(w2f__8) D1
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) PSIM
      REAL(w2f__8) PSIP
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) THETAM
      REAL(w2f__8) THETAMAX
      PARAMETER ( THETAMAX = 1.0D+20)
      REAL(w2f__8) THETAP
      REAL(w2f__8) UCFL
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
        UT((-1), J) = 0.0D00
        UT(93, J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = 0, 92, 1
          RJP = MASKLOCW(I + 1, J) *(TRACER(I + 1, J) - TRACER(I, J))
          RJ = MASKLOCW(I, J) *(TRACER(I, J) - TRACER(I + (-1), J))
          RJM = MASKLOCW(I + (-1), J) *(TRACER(I + (-1), J) - TRACER(I
     >  + (-2), J))
          UCFL = UFLD(I, J)
          IF(CALCCFL) THEN
            UCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DXC(I, J, BI, BJ) *
     >  UFLD(I, J) * DELTATLOC)
          ENDIF
          D0 = (2.0D00 - UCFL) *(1.0D00 - UCFL) *
     >  1.66666666666666657415D-01
          D1 = (1.0D00 - UCFL * UCFL) * 1.66666666666666657415D-01
          IF(ABS(RJM) .GE.(ABS(RJ) * 1.0D+20)) THEN
            THETAP = SIGN(1.0D+20, RJ * RJM)
          ELSE
            THETAP = RJM / RJ
          ENDIF
          IF(ABS(RJP) .GE.(ABS(RJ) * 1.0D+20)) THEN
            THETAM = SIGN(1.0D+20, RJ * RJP)
          ELSE
            THETAM = RJP / RJ
          ENDIF
          PSIP = D0 + D1 * THETAP
          PSIP = MAX(MIN(MIN(PSIP, (THETAP *(1.0D00 - UCFL)) /(UCFL +
     >  9.99999999999999945153D-21)), 1.0D00), 0.0D00)
          PSIM = D0 + D1 * THETAM
          PSIM = MAX(MIN(MIN(PSIM, (THETAM *(1.0D00 - UCFL)) /(UCFL +
     >  9.99999999999999945153D-21)), 1.0D00), 0.0D00)
          UT(I, J) = ((UTRANS(I, J) + ABS(UTRANS(I, J))) * 5.0D-01 *(
     > TRACER(I + (-1), J) + PSIP * RJ) +(UTRANS(I, J) - ABS(UTRANS(I,
     >  J))) * 5.0D-01 *(TRACER(I, J) - PSIM * RJ))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst3fl_adv_y(BI, BJ, K, CALCCFL, DELTATLOC, VTRANS
     > , VFLD, MASKLOCS, TRACER, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) D0
      REAL(w2f__8) D1
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) PSIM
      REAL(w2f__8) PSIP
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) THETAM
      REAL(w2f__8) THETAMAX
      PARAMETER ( THETAMAX = 1.0D+20)
      REAL(w2f__8) THETAP
      REAL(w2f__8) VCFL
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
        VT(I, (-1)) = 0.0D00
        VT(I, 43) = 0.0D00
      END DO
      DO J = 0, 42, 1
        DO I = -2, 93, 1
          RJP = MASKLOCS(I, J + 1) *(TRACER(I, J + 1) - TRACER(I, J))
          RJ = MASKLOCS(I, J) *(TRACER(I, J) - TRACER(I, J + (-1)))
          RJM = MASKLOCS(I, J + (-1)) *(TRACER(I, J + (-1)) - TRACER(I,
     >  J + (-2)))
          VCFL = VFLD(I, J)
          IF(CALCCFL) THEN
            VCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DYC(I, J, BI, BJ) *
     >  VFLD(I, J) * DELTATLOC)
          ENDIF
          D0 = (2.0D00 - VCFL) *(1.0D00 - VCFL) *
     >  1.66666666666666657415D-01
          D1 = (1.0D00 - VCFL * VCFL) * 1.66666666666666657415D-01
          IF(ABS(RJM) .GE.(ABS(RJ) * 1.0D+20)) THEN
            THETAP = SIGN(1.0D+20, RJ * RJM)
          ELSE
            THETAP = RJM / RJ
          ENDIF
          IF(ABS(RJP) .GE.(ABS(RJ) * 1.0D+20)) THEN
            THETAM = SIGN(1.0D+20, RJ * RJP)
          ELSE
            THETAM = RJP / RJ
          ENDIF
          PSIP = D0 + D1 * THETAP
          PSIP = MAX(MIN(MIN(PSIP, (THETAP *(1.0D00 - VCFL)) /(VCFL +
     >  9.99999999999999945153D-21)), 1.0D00), 0.0D00)
          PSIM = D0 + D1 * THETAM
          PSIM = MAX(MIN(MIN(PSIM, (THETAM *(1.0D00 - VCFL)) /(VCFL +
     >  9.99999999999999945153D-21)), 1.0D00), 0.0D00)
          VT(I, J) = ((VTRANS(I, J) + ABS(VTRANS(I, J))) * 5.0D-01 *(
     > TRACER(I, J + (-1)) + PSIP * RJ) +(VTRANS(I, J) - ABS(VTRANS(I,
     >  J))) * 5.0D-01 *(TRACER(I, J) - PSIM * RJ))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_dst3fl_adv_r(BI, BJ, K, DTARG, RTRANS, WFLD,
     >  TRACER, WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) DTARG
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) D0
      REAL(w2f__8) D1
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KM2
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) PSIM
      REAL(w2f__8) PSIP
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) THETAM
      REAL(w2f__8) THETAMAX
      PARAMETER ( THETAMAX = 1.0D+20)
      REAL(w2f__8) THETAP
      REAL(w2f__8) WCFL
      REAL(w2f__8) WLOC
C
C     **** Statements ****
C
      KM2 = MAX(K +(-2), 1)
      KM1 = MAX(K +(-1), 1)
      KP1 = MIN(K + 1, 15)
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          RJP = MASKC(I, J, KP1, BI, BJ) *(TRACER(I, J, K) - TRACER(I,
     >  J, KP1))
          RJ = MASKC(I, J, KM1, BI, BJ) * MASKC(I, J, K, BI, BJ) *(
     > TRACER(I, J, KM1) - TRACER(I, J, K))
          RJM = MASKC(I, J, KM1, BI, BJ) *(TRACER(I, J, KM2) - TRACER(I
     > , J, KM1))
          WLOC = WFLD(I, J)
          WCFL = ABS(RECIP_DRC(K) * DTARG * WLOC)
          D0 = (2.0D00 - WCFL) *(1.0D00 - WCFL) *
     >  1.66666666666666657415D-01
          D1 = (1.0D00 - WCFL * WCFL) * 1.66666666666666657415D-01
          IF(ABS(RJM) .GE.(ABS(RJ) * 1.0D+20)) THEN
            THETAP = SIGN(1.0D+20, RJ * RJM)
          ELSE
            THETAP = RJM / RJ
          ENDIF
          IF(ABS(RJP) .GE.(ABS(RJ) * 1.0D+20)) THEN
            THETAM = SIGN(1.0D+20, RJ * RJP)
          ELSE
            THETAM = RJP / RJ
          ENDIF
          PSIP = D0 + D1 * THETAP
          PSIP = MAX(MIN(MIN(PSIP, (THETAP *(1.0D00 - WCFL)) /(WCFL +
     >  9.99999999999999945153D-21)), 1.0D00), 0.0D00)
          PSIM = D0 + D1 * THETAM
          PSIM = MAX(MIN(MIN(PSIM, (THETAM *(1.0D00 - WCFL)) /(WCFL +
     >  9.99999999999999945153D-21)), 1.0D00), 0.0D00)
          WT(I, J) = ((RTRANS(I, J) + ABS(RTRANS(I, J))) * 5.0D-01 *(
     > TRACER(I, J, K) + PSIM * RJ) +(RTRANS(I, J) - ABS(RTRANS(I, J)))
     >  * 5.0D-01 *(TRACER(I, J, KM1) - PSIP * RJ))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_fluxlimit_adv_r(BI, BJ, K, DTARG, RTRANS, WFLD,
     >  TRACER, WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) DTARG
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) CR
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KM2
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) WCFL
      REAL(w2f__8) WLOC
C
C     **** Statements ****
C
      KM2 = MAX(K +(-2), 1)
      KM1 = MAX(K +(-1), 1)
      KP1 = MIN(K + 1, 15)
      IF(K .GT. 15) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WT(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WLOC = WFLD(I, J)
            WCFL = ABS(RECIP_DRC(K) * DTARG * WLOC)
            RJP = MASKC(I, J, KP1, BI, BJ) *(TRACER(I, J, KP1) - TRACER
     > (I, J, K))
            RJ = (TRACER(I, J, K) - TRACER(I, J, KM1))
            RJM = MASKC(I, J, KM2, BI, BJ) *(TRACER(I, J, KM1) - TRACER
     > (I, J, KM2))
            IF(RJ .ne. 0.0D00) THEN
              IF(RTRANS(I, J) .LT. 0.0D00) THEN
                CR = RJM / RJ
              ELSE
                CR = RJP / RJ
              ENDIF
            ELSE
              IF(RTRANS(I, J) .LT. 0.0D00) THEN
                CR = RJM * 1.0D+20
              ELSE
                CR = RJP * 1.0D+20
              ENDIF
            ENDIF
            CR = (MAX(MAX(MIN(CR, 2.0D00), MIN(CR * 2.0D00, 1.0D00)),
     >  0.0D00))
            WT(I, J) = (MASKC(I, J, KM1, BI, BJ) *(RTRANS(I, J) *(
     > TRACER(I, J, K) + TRACER(I, J, KM1)) * 5.0D-01 + RJ * ABS(RTRANS
     > (I, J)) *(CR * WCFL +(1.0D00 - CR)) * 5.0D-01))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_fluxlimit_adv_x(BI, BJ, K, CALCCFL, DELTATLOC,
     >  UTRANS, UFLD, MASKLOCW, TRACER, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCW(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) CR
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) UCFL
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
        UT((-1), J) = 0.0D00
        UT(93, J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = 0, 92, 1
          UCFL = UFLD(I, J)
          IF(CALCCFL) THEN
            UCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DXC(I, J, BI, BJ) *
     >  UFLD(I, J) * DELTATLOC)
          ENDIF
          RJP = MASKLOCW(I + 1, J) *(TRACER(I + 1, J) - TRACER(I, J))
          RJ = MASKLOCW(I, J) *(TRACER(I, J) - TRACER(I + (-1), J))
          RJM = MASKLOCW(I + (-1), J) *(TRACER(I + (-1), J) - TRACER(I
     >  + (-2), J))
          IF(RJ .ne. 0.0D00) THEN
            IF(UTRANS(I, J) .GT. 0.0D00) THEN
              CR = RJM / RJ
            ELSE
              CR = RJP / RJ
            ENDIF
          ELSE
            IF(UTRANS(I, J) .GT. 0.0D00) THEN
              CR = RJM * 1.0D+20
            ELSE
              CR = RJP * 1.0D+20
            ENDIF
          ENDIF
          CR = (MAX(MAX(MIN(CR, 2.0D00), MIN(CR * 2.0D00, 1.0D00)),
     >  0.0D00))
          UT(I, J) = (UTRANS(I, J) *(TRACER(I, J) + TRACER(I + (-1), J)
     > ) * 5.0D-01 - RJ * ABS(UTRANS(I, J)) *(CR * UCFL +(1.0D00 - CR))
     >  * 5.0D-01)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_fluxlimit_adv_y(BI, BJ, K, CALCCFL, DELTATLOC,
     >  VTRANS, VFLD, MASKLOCS, TRACER, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) CR
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      REAL(w2f__8) VCFL
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
        VT(I, (-1)) = 0.0D00
        VT(I, 43) = 0.0D00
      END DO
      DO J = 0, 42, 1
        DO I = -2, 93, 1
          VCFL = VFLD(I, J)
          IF(CALCCFL) THEN
            VCFL = ABS(RECIP_DEEPFACC(K) * RECIP_DYC(I, J, BI, BJ) *
     >  VFLD(I, J) * DELTATLOC)
          ENDIF
          RJP = MASKLOCS(I, J + 1) *(TRACER(I, J + 1) - TRACER(I, J))
          RJ = MASKLOCS(I, J) *(TRACER(I, J) - TRACER(I, J + (-1)))
          RJM = MASKLOCS(I, J + (-1)) *(TRACER(I, J + (-1)) - TRACER(I,
     >  J + (-2)))
          IF(RJ .ne. 0.0D00) THEN
            IF(VTRANS(I, J) .GT. 0.0D00) THEN
              CR = RJM / RJ
            ELSE
              CR = RJP / RJ
            ENDIF
          ELSE
            IF(VTRANS(I, J) .GT. 0.0D00) THEN
              CR = RJM * 1.0D+20
            ELSE
              CR = RJP * 1.0D+20
            ENDIF
          ENDIF
          CR = (MAX(MAX(MIN(CR, 2.0D00), MIN(CR * 2.0D00, 1.0D00)),
     >  0.0D00))
          VT(I, J) = (VTRANS(I, J) *(TRACER(I, J) + TRACER(I, J + (-1))
     > ) * 5.0D-01 - RJ * ABS(VTRANS(I, J)) *(CR * VCFL +(1.0D00 - CR))
     >  * 5.0D-01)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_grad_x(BI, BJ, K, XA, TRACER, DTDX, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) DTDX(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL fill_cs_corner_tr_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(USECUBEDSPHEREEXCHANGE) THEN
        CALL fill_cs_corner_tr_rl((1), (.FALSE.), TRACER, BI, BJ,
     >  MYTHID)
      ENDIF
      DO J = -2, 43, 1
        DTDX((-2), J) = 0.0D00
        DO I = -1, 93, 1
          DTDX(I, J) = (SQCOSFACU(J, BI, BJ) * RECIP_DEEPFACC(K) * XA(I
     > , J) * RECIP_DXC(I, J, BI, BJ) *(TRACER(I, J) - TRACER(I + (-1),
     >  J)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_grad_y(BI, BJ, K, YA, TRACER, DTDY, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) DTDY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL fill_cs_corner_tr_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(USECUBEDSPHEREEXCHANGE) THEN
        CALL fill_cs_corner_tr_rl((2), (.FALSE.), TRACER, BI, BJ,
     >  MYTHID)
      ENDIF
      DO I = -2, 93, 1
        DTDY(I, (-2)) = 0.0D00
      END DO
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          DTDY(I, J) = (RECIP_DEEPFACC(K) * YA(I, J) * RECIP_DYC(I, J,
     >  BI, BJ) *(TRACER(I, J) - TRACER(I, J + (-1))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_init_varia(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_os7mp_adv_x(BI, BJ, K, CALCCFL, DELTATLOC, UTRANS,
     >  UFLD, MASKLOCW, Q, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCW(-2 : 93, -2 : 43)
      REAL(w2f__8) Q(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A
      REAL(w2f__8) B
      REAL(w2f__8) C
      REAL(w2f__8) CFL
      REAL(w2f__8) D
      REAL(w2f__8) D2
      REAL(w2f__8) D2M1
      REAL(w2f__8) D2P1
      REAL(w2f__8) DEL2
      REAL(w2f__8) DEL2M
      REAL(w2f__8) DEL2MM
      REAL(w2f__8) DEL2P
      REAL(w2f__8) DEL2PP
      REAL(w2f__8) DEL3M
      REAL(w2f__8) DEL3MM
      REAL(w2f__8) DEL3P
      REAL(w2f__8) DEL3PP
      REAL(w2f__8) DEL4
      REAL(w2f__8) DEL4M
      REAL(w2f__8) DEL4P
      REAL(w2f__8) DEL5M
      REAL(w2f__8) DEL5P
      REAL(w2f__8) DEL6
      REAL(w2f__8) DELI
      REAL(w2f__8) DELIP
      REAL(w2f__8) DELM
      REAL(w2f__8) DELMM
      REAL(w2f__8) DELMMM
      REAL(w2f__8) DELP
      REAL(w2f__8) DELPP
      REAL(w2f__8) DELPPP
      REAL(w2f__8) DM1H
      REAL(w2f__8) DP1H
      REAL(w2f__8) EPS
      REAL(w2f__8) FAC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) MSKI
      REAL(w2f__8) MSKIM
      REAL(w2f__8) MSKIMM
      REAL(w2f__8) MSKIMMM
      REAL(w2f__8) MSKIP
      REAL(w2f__8) MSKIPP
      REAL(w2f__8) PHI
      REAL(w2f__8) PHILC
      REAL(w2f__8) PHIMAX
      REAL(w2f__8) PHIMD
      REAL(w2f__8) PHIMIN
      REAL(w2f__8) PSI
      REAL(w2f__8) QI
      REAL(w2f__8) QIM
      REAL(w2f__8) QIMM
      REAL(w2f__8) QIMMM
      REAL(w2f__8) QIP
      REAL(w2f__8) QIPP
      REAL(w2f__8) QIPPP
      REAL(w2f__8) RECIP_DELI
      REAL(w2f__8) RECIP_DELIP
      REAL(w2f__8) RP1H
      REAL(w2f__8) RP1H_CFL
      REAL(w2f__8) ULOC
C
C     **** Statements ****
C
      EPS = 9.99999999999999945153D-21
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
        UT((-1), J) = 0.0D00
        UT(0, J) = 0.0D00
        UT(1, J) = 0.0D00
        UT(91, J) = 0.0D00
        UT(92, J) = 0.0D00
        UT(93, J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = 2, 90, 1
          ULOC = UFLD(I, J)
          CFL = ULOC
          IF(CALCCFL) THEN
            CFL = ABS(RECIP_DXC(I, J, BI, BJ) * DELTATLOC * ULOC)
          ENDIF
          IF(UTRANS(I, J) .GT. 0.0D00) THEN
            QIPPP = Q(I + 2, J)
            QIPP = Q(I + 1, J)
            QIP = Q(I, J)
            QI = Q(I + (-1), J)
            QIM = Q(I + (-2), J)
            QIMM = Q(I + (-3), J)
            QIMMM = Q(I + (-4), J)
            MSKIPP = MASKLOCW(I + 2, J)
            MSKIP = MASKLOCW(I + 1, J)
            MSKI = MASKLOCW(I, J)
            MSKIM = MASKLOCW(I + (-1), J)
            MSKIMM = MASKLOCW(I + (-2), J)
            MSKIMMM = MASKLOCW(I + (-3), J)
          ELSE
            IF(UTRANS(I, J) .LT. 0.0D00) THEN
              QIPPP = Q(I + (-3), J)
              QIPP = Q(I + (-2), J)
              QIP = Q(I + (-1), J)
              QI = Q(I, J)
              QIM = Q(I + 1, J)
              QIMM = Q(I + 2, J)
              QIMMM = Q(I + 3, J)
              MSKIPP = MASKLOCW(I + (-2), J)
              MSKIP = MASKLOCW(I + (-1), J)
              MSKI = MASKLOCW(I, J)
              MSKIM = MASKLOCW(I + 1, J)
              MSKIMM = MASKLOCW(I + 2, J)
              MSKIMMM = MASKLOCW(I + 3, J)
            ELSE
              QIPPP = 0.0D00
              QIPP = 0.0D00
              QIP = 0.0D00
              QI = 0.0D00
              QIM = 0.0D00
              QIMM = 0.0D00
              QIMMM = 0.0D00
              MSKIPP = 0.0D00
              MSKIP = 0.0D00
              MSKI = 0.0D00
              MSKIM = 0.0D00
              MSKIMM = 0.0D00
              MSKIMMM = 0.0D00
            ENDIF
          ENDIF
          IF(UTRANS(I, J) .ne. 0.0D00) THEN
            FAC = 1.0D00
            DELP = MSKI *(QIP - QI)
            PHI = DELP * FAC
            FAC = (FAC *(CFL + 1.0D00)) / 3.0D00
            DELM = MSKIM *(QI - QIM)
            DEL2 = DELP - DELM
            PHI = PHI - DEL2 * FAC
            FAC = FAC *(CFL +(-2.0D00)) * 2.5D-01
            DELPP = MSKI * MSKIP *(QIPP - QIP)
            DEL2P = DELPP - DELP
            DEL3P = DEL2P - DEL2
            PHI = PHI + DEL3P * FAC
            FAC = (FAC *(CFL +(-3.0D00))) / 5.0D00
            DELMM = MSKIM * MSKIMM *(QIM - QIMM)
            DEL2M = DELM - DELMM
            DEL3M = DEL2 - DEL2M
            DEL4 = DEL3P - DEL3M
            PHI = PHI + DEL4 * FAC
            FAC = (FAC *(CFL + 2.0D00)) / 6.0D00
            DELPPP = MSKI * MSKIP * MSKIPP *(QIPPP - QIPP)
            DEL2PP = DELPP - DELP
            DEL3PP = DEL2PP - DEL2P
            DEL4P = DEL3PP - DEL3P
            DEL5P = DEL4P - DEL4
            PHI = PHI + DEL5P * FAC
            FAC = (FAC *(CFL + 2.0D00)) / 7.0D00
            DELMMM = MSKIM * MSKIMM * MSKIMMM *(QIMM - QIMMM)
            DEL2MM = DELMM - DELMMM
            DEL3MM = DEL2M - DEL2MM
            DEL4M = DEL3M - DEL3MM
            DEL5M = DEL4 - DEL4M
            DEL6 = DEL5P - DEL5M
            PHI = PHI - DEL6 * FAC
            DELIP = MSKI *(QIP - QI)
            RECIP_DELIP = SIGN(1.0D00, DELIP) / MAX(EPS, ABS(DELIP))
            PHI = PHI * RECIP_DELIP
            DELI = MSKIM *(QI - QIM)
            RECIP_DELI = SIGN(1.0D00, DELI) / MAX(EPS, ABS(DELI))
            RP1H = DELI * RECIP_DELIP
            RP1H_CFL = RP1H /(CFL + EPS)
            D2 = DEL2
            D2P1 = DEL2P
            D2M1 = DEL2M
            A = D2 * 4.0D00 - D2P1
            B = D2P1 * 4.0D00 - D2
            C = D2
            D = D2P1
            DP1H = MAX(MIN(A, MIN(B, MIN(C, D))), 0.0D00) + MIN(MAX(A,
     >  MAX(B, MAX(C, D))), 0.0D00)
            A = D2M1 * 4.0D00 - D2
            B = D2 * 4.0D00 - D2M1
            C = D2M1
            D = D2
            DM1H = MAX(MIN(A, MIN(B, MIN(C, D))), 0.0D00) + MIN(MAX(A,
     >  MAX(B, MAX(C, D))), 0.0D00)
            PHIMD = RECIP_DELIP *(DELIP - DP1H) * 1D00 / (1.0D00 - CFL)
            PHILC = RP1H_CFL *(DM1H * RECIP_DELI + 1.0D00)
            PHIMIN = MAX(MIN(PHIMD, 0.0D00), MIN(MIN(PHILC, RP1H_CFL *
     >  2.0D00), 0.0D00))
            PHIMAX = MIN(MAX(PHIMD, 2.0D00 /(1.0D00 - CFL)), MAX(MAX(
     > PHILC, RP1H_CFL * 2.0D00), 0.0D00))
            PHI = MAX(PHIMIN, MIN(PHI, PHIMAX))
            PSI = PHI * 5.0D-01 *(1.0D00 - CFL)
            UT(I, J) = (UTRANS(I, J) *(QI + DELIP * PSI))
          ELSE
            UT(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_os7mp_adv_y(BI, BJ, K, CALCCFL, DELTATLOC, VTRANS,
     >  VFLD, MASKLOCS, Q, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      LOGICAL(w2f__i4) CALCCFL
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKLOCS(-2 : 93, -2 : 43)
      REAL(w2f__8) Q(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A
      REAL(w2f__8) B
      REAL(w2f__8) C
      REAL(w2f__8) CFL
      REAL(w2f__8) D
      REAL(w2f__8) D2
      REAL(w2f__8) D2M1
      REAL(w2f__8) D2P1
      REAL(w2f__8) DEL2
      REAL(w2f__8) DEL2M
      REAL(w2f__8) DEL2MM
      REAL(w2f__8) DEL2P
      REAL(w2f__8) DEL2PP
      REAL(w2f__8) DEL3M
      REAL(w2f__8) DEL3MM
      REAL(w2f__8) DEL3P
      REAL(w2f__8) DEL3PP
      REAL(w2f__8) DEL4
      REAL(w2f__8) DEL4M
      REAL(w2f__8) DEL4P
      REAL(w2f__8) DEL5M
      REAL(w2f__8) DEL5P
      REAL(w2f__8) DEL6
      REAL(w2f__8) DELI
      REAL(w2f__8) DELIP
      REAL(w2f__8) DELM
      REAL(w2f__8) DELMM
      REAL(w2f__8) DELMMM
      REAL(w2f__8) DELP
      REAL(w2f__8) DELPP
      REAL(w2f__8) DELPPP
      REAL(w2f__8) DM1H
      REAL(w2f__8) DP1H
      REAL(w2f__8) EPS
      REAL(w2f__8) FAC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) MSKI
      REAL(w2f__8) MSKIM
      REAL(w2f__8) MSKIMM
      REAL(w2f__8) MSKIMMM
      REAL(w2f__8) MSKIP
      REAL(w2f__8) MSKIPP
      REAL(w2f__8) PHI
      REAL(w2f__8) PHILC
      REAL(w2f__8) PHIMAX
      REAL(w2f__8) PHIMD
      REAL(w2f__8) PHIMIN
      REAL(w2f__8) PSI
      REAL(w2f__8) QI
      REAL(w2f__8) QIM
      REAL(w2f__8) QIMM
      REAL(w2f__8) QIMMM
      REAL(w2f__8) QIP
      REAL(w2f__8) QIPP
      REAL(w2f__8) QIPPP
      REAL(w2f__8) RECIP_DELI
      REAL(w2f__8) RECIP_DELIP
      REAL(w2f__8) RP1H
      REAL(w2f__8) RP1H_CFL
      REAL(w2f__8) VLOC
C
C     **** Statements ****
C
      EPS = 9.99999999999999945153D-21
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
        VT(I, (-1)) = 0.0D00
        VT(I, 0) = 0.0D00
        VT(I, 1) = 0.0D00
        VT(I, 41) = 0.0D00
        VT(I, 42) = 0.0D00
        VT(I, 43) = 0.0D00
      END DO
      DO J = 2, 40, 1
        DO I = -2, 93, 1
          VLOC = VFLD(I, J)
          CFL = VLOC
          IF(CALCCFL) THEN
            CFL = ABS(RECIP_DYC(I, J, BI, BJ) * DELTATLOC * VLOC)
          ENDIF
          IF(VTRANS(I, J) .GT. 0.0D00) THEN
            QIPPP = Q(I, J + 2)
            QIPP = Q(I, J + 1)
            QIP = Q(I, J)
            QI = Q(I, J + (-1))
            QIM = Q(I, J + (-2))
            QIMM = Q(I, J + (-3))
            QIMMM = Q(I, J + (-4))
            MSKIPP = MASKLOCS(I, J + 2)
            MSKIP = MASKLOCS(I, J + 1)
            MSKI = MASKLOCS(I, J)
            MSKIM = MASKLOCS(I, J + (-1))
            MSKIMM = MASKLOCS(I, J + (-2))
            MSKIMMM = MASKLOCS(I, J + (-3))
          ELSE
            IF(VTRANS(I, J) .LT. 0.0D00) THEN
              QIPPP = Q(I, J + (-3))
              QIPP = Q(I, J + (-2))
              QIP = Q(I, J + (-1))
              QI = Q(I, J)
              QIM = Q(I, J + 1)
              QIMM = Q(I, J + 2)
              QIMMM = Q(I, J + 3)
              MSKIPP = MASKLOCS(I, J + (-2))
              MSKIP = MASKLOCS(I, J + (-1))
              MSKI = MASKLOCS(I, J)
              MSKIM = MASKLOCS(I, J + 1)
              MSKIMM = MASKLOCS(I, J + 2)
              MSKIMMM = MASKLOCS(I, J + 3)
            ELSE
              QIPPP = 0.0D00
              QIPP = 0.0D00
              QIP = 0.0D00
              QI = 0.0D00
              QIM = 0.0D00
              QIMM = 0.0D00
              QIMMM = 0.0D00
              MSKIPP = 0.0D00
              MSKIP = 0.0D00
              MSKI = 0.0D00
              MSKIM = 0.0D00
              MSKIMM = 0.0D00
              MSKIMMM = 0.0D00
            ENDIF
          ENDIF
          IF(VTRANS(I, J) .ne. 0.0D00) THEN
            FAC = 1.0D00
            DELP = MSKI *(QIP - QI)
            PHI = DELP * FAC
            FAC = (FAC *(CFL + 1.0D00)) / 3.0D00
            DELM = MSKIM *(QI - QIM)
            DEL2 = DELP - DELM
            PHI = PHI - DEL2 * FAC
            FAC = FAC *(CFL +(-2.0D00)) * 2.5D-01
            DELPP = MSKI * MSKIP *(QIPP - QIP)
            DEL2P = DELPP - DELP
            DEL3P = DEL2P - DEL2
            PHI = PHI + DEL3P * FAC
            FAC = (FAC *(CFL +(-3.0D00))) / 5.0D00
            DELMM = MSKIM * MSKIMM *(QIM - QIMM)
            DEL2M = DELM - DELMM
            DEL3M = DEL2 - DEL2M
            DEL4 = DEL3P - DEL3M
            PHI = PHI + DEL4 * FAC
            FAC = (FAC *(CFL + 2.0D00)) / 6.0D00
            DELPPP = MSKI * MSKIP * MSKIPP *(QIPPP - QIPP)
            DEL2PP = DELPP - DELP
            DEL3PP = DEL2PP - DEL2P
            DEL4P = DEL3PP - DEL3P
            DEL5P = DEL4P - DEL4
            PHI = PHI + DEL5P * FAC
            FAC = (FAC *(CFL + 2.0D00)) / 7.0D00
            DELMMM = MSKIM * MSKIMM * MSKIMMM *(QIMM - QIMMM)
            DEL2MM = DELMM - DELMMM
            DEL3MM = DEL2M - DEL2MM
            DEL4M = DEL3M - DEL3MM
            DEL5M = DEL4 - DEL4M
            DEL6 = DEL5P - DEL5M
            PHI = PHI - DEL6 * FAC
            DELIP = MSKI *(QIP - QI)
            RECIP_DELIP = SIGN(1.0D00, DELIP) / MAX(EPS, ABS(DELIP))
            PHI = PHI * RECIP_DELIP
            DELI = MSKIM *(QI - QIM)
            RECIP_DELI = SIGN(1.0D00, DELI) / MAX(EPS, ABS(DELI))
            RP1H = DELI * RECIP_DELIP
            RP1H_CFL = RP1H /(CFL + EPS)
            D2 = DEL2
            D2P1 = DEL2P
            D2M1 = DEL2M
            A = D2 * 4.0D00 - D2P1
            B = D2P1 * 4.0D00 - D2
            C = D2
            D = D2P1
            DP1H = MAX(MIN(A, MIN(B, MIN(C, D))), 0.0D00) + MIN(MAX(A,
     >  MAX(B, MAX(C, D))), 0.0D00)
            A = D2M1 * 4.0D00 - D2
            B = D2 * 4.0D00 - D2M1
            C = D2M1
            D = D2
            DM1H = MAX(MIN(A, MIN(B, MIN(C, D))), 0.0D00) + MIN(MAX(A,
     >  MAX(B, MAX(C, D))), 0.0D00)
            PHIMD = RECIP_DELIP *(DELIP - DP1H) * 1D00 / (1.0D00 - CFL)
            PHILC = RP1H_CFL *(DM1H * RECIP_DELI + 1.0D00)
            PHIMIN = MAX(MIN(PHIMD, 0.0D00), MIN(MIN(PHILC, RP1H_CFL *
     >  2.0D00), 0.0D00))
            PHIMAX = MIN(MAX(PHIMD, 2.0D00 /(1.0D00 - CFL)), MAX(MAX(
     > PHILC, RP1H_CFL * 2.0D00), 0.0D00))
            PHI = MAX(PHIMIN, MIN(PHI, PHIMAX))
            PSI = PHI * 5.0D-01 *(1.0D00 - CFL)
            VT(I, J) = (VTRANS(I, J) *(QI + DELIP * PSI))
          ELSE
            VT(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_os7mp_adv_r(BI, BJ, K, DELTATLOC, WTRANS, WFLD, Q,
     >  WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) DELTATLOC
      REAL(w2f__8) WTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) Q(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A
      REAL(w2f__8) B
      REAL(w2f__8) C
      REAL(w2f__8) CFL
      REAL(w2f__8) D
      REAL(w2f__8) D2
      REAL(w2f__8) D2M1
      REAL(w2f__8) D2P1
      REAL(w2f__8) DEL2
      REAL(w2f__8) DEL2M
      REAL(w2f__8) DEL2MM
      REAL(w2f__8) DEL2P
      REAL(w2f__8) DEL2PP
      REAL(w2f__8) DEL3M
      REAL(w2f__8) DEL3MM
      REAL(w2f__8) DEL3P
      REAL(w2f__8) DEL3PP
      REAL(w2f__8) DEL4
      REAL(w2f__8) DEL4M
      REAL(w2f__8) DEL4P
      REAL(w2f__8) DEL5M
      REAL(w2f__8) DEL5P
      REAL(w2f__8) DEL6
      REAL(w2f__8) DELI
      REAL(w2f__8) DELIP
      REAL(w2f__8) DELM
      REAL(w2f__8) DELMM
      REAL(w2f__8) DELMMM
      REAL(w2f__8) DELP
      REAL(w2f__8) DELPP
      REAL(w2f__8) DELPPP
      REAL(w2f__8) DM1H
      REAL(w2f__8) DP1H
      REAL(w2f__8) EPS
      REAL(w2f__8) FAC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KM2
      INTEGER(w2f__i4) KM3
      INTEGER(w2f__i4) KM4
      INTEGER(w2f__i4) KP1
      INTEGER(w2f__i4) KP2
      INTEGER(w2f__i4) KP3
      REAL(w2f__8) MSKI
      REAL(w2f__8) MSKIM
      REAL(w2f__8) MSKIMM
      REAL(w2f__8) MSKIMMM
      REAL(w2f__8) MSKIP
      REAL(w2f__8) MSKIPP
      REAL(w2f__8) PHI
      REAL(w2f__8) PHILC
      REAL(w2f__8) PHIMAX
      REAL(w2f__8) PHIMD
      REAL(w2f__8) PHIMIN
      REAL(w2f__8) PSI
      REAL(w2f__8) QI
      REAL(w2f__8) QIM
      REAL(w2f__8) QIMM
      REAL(w2f__8) QIMMM
      REAL(w2f__8) QIP
      REAL(w2f__8) QIPP
      REAL(w2f__8) QIPPP
      REAL(w2f__8) RECIP_DELI
      REAL(w2f__8) RECIP_DELIP
      REAL(w2f__8) RP1H
      REAL(w2f__8) RP1H_CFL
      REAL(w2f__8) WLOC
C
C     **** Statements ****
C
      EPS = 9.99999999999999945153D-21
      KM4 = MAX(K +(-4), 1)
      KM3 = MAX(K +(-3), 1)
      KM2 = MAX(K +(-2), 1)
      KM1 = MAX(K +(-1), 1)
      KP1 = MIN(K + 1, 15)
      KP2 = MIN(K + 2, 15)
      KP3 = MIN(K + 3, 15)
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          WLOC = WFLD(I, J)
          CFL = ABS(RECIP_DRC(K) * DELTATLOC * WLOC)
          IF(WTRANS(I, J) .LT. 0.0D00) THEN
            QIPPP = Q(I, J, KP2)
            QIPP = Q(I, J, KP1)
            QIP = Q(I, J, K)
            QI = Q(I, J, KM1)
            QIM = Q(I, J, KM2)
            QIMM = Q(I, J, KM3)
            QIMMM = Q(I, J, KM4)
            MSKIPP = MASKC(I, J, KP2, BI, BJ) * FLOAT(KP2 - KP1)
            MSKIP = MASKC(I, J, KP1, BI, BJ) * FLOAT(KP1 - K)
            MSKI = MASKC(I, J, K, BI, BJ) * FLOAT(K - KM1)
            MSKIM = MASKC(I, J, KM1, BI, BJ) * FLOAT(KM1 - KM2)
            MSKIMM = MASKC(I, J, KM2, BI, BJ) * FLOAT(KM2 - KM3)
            MSKIMMM = MASKC(I, J, KM3, BI, BJ) * FLOAT(KM3 - KM4)
          ELSE
            IF(WTRANS(I, J) .GT. 0.0D00) THEN
              QIPPP = Q(I, J, KM3)
              QIPP = Q(I, J, KM2)
              QIP = Q(I, J, KM1)
              QI = Q(I, J, K)
              QIM = Q(I, J, KP1)
              QIMM = Q(I, J, KP2)
              QIMMM = Q(I, J, KP3)
              MSKIPP = MASKC(I, J, KM2, BI, BJ) * FLOAT(KM2 - KM3)
              MSKIP = MASKC(I, J, KM1, BI, BJ) * FLOAT(KM1 - KM2)
              MSKI = MASKC(I, J, K, BI, BJ) * FLOAT(K - KM1)
              MSKIM = MASKC(I, J, KP1, BI, BJ) * FLOAT(KP1 - K)
              MSKIMM = MASKC(I, J, KP2, BI, BJ) * FLOAT(KP2 - KP1)
              MSKIMMM = MASKC(I, J, KP3, BI, BJ) * FLOAT(KP3 - KP2)
            ELSE
              QIPPP = 0.0D00
              QIPP = 0.0D00
              QIP = 0.0D00
              QI = 0.0D00
              QIM = 0.0D00
              QIMM = 0.0D00
              QIMMM = 0.0D00
              MSKIPP = 0.0D00
              MSKIP = 0.0D00
              MSKI = 0.0D00
              MSKIM = 0.0D00
              MSKIMM = 0.0D00
              MSKIMMM = 0.0D00
            ENDIF
          ENDIF
          IF(WTRANS(I, J) .ne. 0.0D00) THEN
            FAC = 1.0D00
            DELP = MSKI *(QIP - QI)
            PHI = DELP * FAC
            FAC = (FAC *(CFL + 1.0D00)) / 3.0D00
            DELM = MSKIM *(QI - QIM)
            DEL2 = DELP - DELM
            PHI = PHI - DEL2 * FAC
            FAC = FAC *(CFL +(-2.0D00)) * 2.5D-01
            DELPP = MSKI * MSKIP *(QIPP - QIP)
            DEL2P = DELPP - DELP
            DEL3P = DEL2P - DEL2
            PHI = PHI + DEL3P * FAC
            FAC = (FAC *(CFL +(-3.0D00))) / 5.0D00
            DELMM = MSKIM * MSKIMM *(QIM - QIMM)
            DEL2M = DELM - DELMM
            DEL3M = DEL2 - DEL2M
            DEL4 = DEL3P - DEL3M
            PHI = PHI + DEL4 * FAC
            FAC = (FAC *(CFL + 2.0D00)) / 6.0D00
            DELPPP = MSKI * MSKIP * MSKIPP *(QIPPP - QIPP)
            DEL2PP = DELPP - DELP
            DEL3PP = DEL2PP - DEL2P
            DEL4P = DEL3PP - DEL3P
            DEL5P = DEL4P - DEL4
            PHI = PHI + DEL5P * FAC
            FAC = (FAC *(CFL + 2.0D00)) / 7.0D00
            DELMMM = MSKIM * MSKIMM * MSKIMMM *(QIMM - QIMMM)
            DEL2MM = DELMM - DELMMM
            DEL3MM = DEL2M - DEL2MM
            DEL4M = DEL3M - DEL3MM
            DEL5M = DEL4 - DEL4M
            DEL6 = DEL5P - DEL5M
            PHI = PHI - DEL6 * FAC
            DELIP = MSKI *(QIP - QI)
            RECIP_DELIP = SIGN(1.0D00, DELIP) / MAX(EPS, ABS(DELIP))
            PHI = PHI * RECIP_DELIP
            DELI = MSKIM *(QI - QIM)
            RECIP_DELI = SIGN(1.0D00, DELI) / MAX(EPS, ABS(DELI))
            RP1H = DELI * RECIP_DELIP
            RP1H_CFL = RP1H /(CFL + EPS)
            D2 = DEL2
            D2P1 = DEL2P
            D2M1 = DEL2M
            A = D2 * 4.0D00 - D2P1
            B = D2P1 * 4.0D00 - D2
            C = D2
            D = D2P1
            DP1H = MAX(MIN(A, MIN(B, MIN(C, D))), 0.0D00) + MIN(MAX(A,
     >  MAX(B, MAX(C, D))), 0.0D00)
            A = D2M1 * 4.0D00 - D2
            B = D2 * 4.0D00 - D2M1
            C = D2M1
            D = D2
            DM1H = MAX(MIN(A, MIN(B, MIN(C, D))), 0.0D00) + MIN(MAX(A,
     >  MAX(B, MAX(C, D))), 0.0D00)
            PHIMD = RECIP_DELIP *(DELIP - DP1H) * 1D00 / (1.0D00 - CFL)
            PHILC = RP1H_CFL *(DM1H * RECIP_DELI + 1.0D00)
            PHIMIN = MAX(MIN(PHIMD, 0.0D00), MIN(MIN(PHILC, RP1H_CFL *
     >  2.0D00), 0.0D00))
            PHIMAX = MIN(MAX(PHIMD, 2.0D00 /(1.0D00 - CFL)), MAX(MAX(
     > PHILC, RP1H_CFL * 2.0D00), 0.0D00))
            PHI = MAX(PHIMIN, MIN(PHI, PHIMAX))
            PSI = PHI * 5.0D-01 *(1.0D00 - CFL)
            WT(I, J) = (WTRANS(I, J) *(QI + DELIP * PSI))
          ELSE
            WT(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_u3_adv_r(BI, BJ, K, RTRANS, TRACER, WT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KM2
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) RJ
      REAL(w2f__8) RJJM
      REAL(w2f__8) RJJP
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
C
C     **** Statements ****
C
      KM2 = MAX(K +(-2), 1)
      KM1 = MAX(K +(-1), 1)
      KP1 = MIN(K + 1, 15)
      IF((K .eq. 1) .OR.(K .GT. 15)) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            WT(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            RJP = MASKC(I, J, KP1, BI, BJ) *(TRACER(I, J, KP1, BI, BJ)
     >  - TRACER(I, J, K, BI, BJ))
            RJ = (TRACER(I, J, K, BI, BJ) - TRACER(I, J, KM1, BI, BJ))
            RJM = MASKC(I, J, KM2, BI, BJ) *(TRACER(I, J, KM1, BI, BJ)
     >  - TRACER(I, J, KM2, BI, BJ))
            RJJP = RJP - RJ
            RJJM = RJ - RJM
            WT(I, J) = (MASKC(I, J, KM1, BI, BJ) *(RTRANS(I, J) *((
     > TRACER(I, J, K, BI, BJ) + TRACER(I, J, KM1, BI, BJ)) * 5.0D-01 -
     > (RJJM + RJJP) * 1.66666666666666657415D-01 * 5.0D-01) + ABS(
     > RTRANS(I, J)) * 1.66666666666666657415D-01 *(RJJM - RJJP) *
     >  5.0D-01))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_u3_adv_x(BI, BJ, K, UTRANS, TRACER, UT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) UT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJJM
      REAL(w2f__8) RJJP
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        UT((-2), J) = 0.0D00
        UT((-1), J) = 0.0D00
        UT(93, J) = 0.0D00
      END DO
      DO J = -2, 43, 1
        DO I = 0, 92, 1
          RJP = MASKW(I + 1, J, K, BI, BJ) *(TRACER(I + 1, J) - TRACER(
     > I, J))
          RJ = MASKW(I, J, K, BI, BJ) *(TRACER(I, J) - TRACER(I + (-1),
     >  J))
          RJM = MASKW(I + (-1), J, K, BI, BJ) *(TRACER(I + (-1), J) -
     >  TRACER(I + (-2), J))
          RJJP = RJP - RJ
          RJJM = RJ - RJM
          UT(I, J) = (UTRANS(I, J) *(TRACER(I, J) + TRACER(I + (-1), J)
     >  -(RJJM + RJJP) * 1.66666666666666657415D-01) * 5.0D-01 + ABS(
     > UTRANS(I, J)) * 5.0D-01 * 1.66666666666666657415D-01 *(RJJP -
     >  RJJM))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_u3_adv_y(BI, BJ, K, VTRANS, TRACER, VT, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43)
      REAL(w2f__8) VT(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RJ
      REAL(w2f__8) RJJM
      REAL(w2f__8) RJJP
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        VT(I, (-2)) = 0.0D00
        VT(I, (-1)) = 0.0D00
        VT(I, 43) = 0.0D00
      END DO
      DO J = 0, 42, 1
        DO I = -2, 93, 1
          RJP = MASKS(I, J + 1, K, BI, BJ) *(TRACER(I, J + 1) - TRACER(
     > I, J))
          RJ = MASKS(I, J, K, BI, BJ) *(TRACER(I, J) - TRACER(I, J + (
     > -1)))
          RJM = MASKS(I, J + (-1), K, BI, BJ) *(TRACER(I, J + (-1)) -
     >  TRACER(I, J + (-2)))
          RJJP = RJP - RJ
          RJJM = RJ - RJM
          VT(I, J) = (VTRANS(I, J) *(TRACER(I, J) + TRACER(I, J + (-1))
     >  -(RJJM + RJJP) * 1.66666666666666657415D-01) * 5.0D-01 + ABS(
     > VTRANS(I, J)) * 5.0D-01 * 1.66666666666666657415D-01 *(RJJP -
     >  RJJM))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gad_som_exchanges(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_calc_diff(BI, BJ, IMIN, IMAX, JMIN, JMAX, KARG,
     >  KSIZE, KAPPARX, TRACERIDENTITY, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) KARG
      INTEGER(w2f__i4) KSIZE
      REAL(w2f__8) KAPPARX(-2 : 93, -2 : 43, 1 : KSIZE)
      INTEGER(w2f__i4) TRACERIDENTITY
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      IF(KARG .eq. 0) THEN
        DO K = 1, MIN(KSIZE, 15), 1
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              KAPPARX(I, J, K) = (KAPPARX(I, J, K) + KWZ(I, J, K, BI,
     >  BJ))
            END DO
          END DO
        END DO
      ELSE
        K = MIN(KARG, KSIZE)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            KAPPARX(I, J, K) = (KAPPARX(I, J, K) + KWZ(I, J, KARG, BI,
     >  BJ))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_calc_psi_b(BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  SIGMAX, SIGMAY, SIGMAR, LDD97_LRHOW, LDD97_LRHOS, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use gmredi_mod
      use ffields_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) SIGMAX(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAY(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAR(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) LDD97_LRHOW(-2 : 93, -2 : 43)
      REAL(w2f__8) LDD97_LRHOS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DSIGMADRS(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADRW(-2 : 93, -2 : 43)
      EXTERNAL gmredi_slope_psi
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KM1
      REAL(w2f__8) SLOPEX(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPEY(-2 : 93, -2 : 43)
      REAL(w2f__8) TAPERX(-2 : 93, -2 : 43)
      REAL(w2f__8) TAPERY(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IGMKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      IF(GM_ADVFORM) THEN
        DO K = 2, 15, 1
          KM1 = K +(-1)
          KKEY = K + IGMKEY * 15 +(-15)
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              SLOPEX(I, J) = 0.0D00
              SLOPEY(I, J) = 0.0D00
              DSIGMADRW(I, J) = 0.0D00
              DSIGMADRS(I, J) = 0.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              SLOPEX(I, J) = (MASKW(I, J, K, BI, BJ) *(SIGMAX(I, J, K)
     >  + SIGMAX(I, J, KM1)) * 5.0D-01)
              DSIGMADRW(I, J) = (MASKW(I, J, K, BI, BJ) *(SIGMAR(I, J,
     >  K) + SIGMAR(I + (-1), J, K)) * 5.0D-01)
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              SLOPEY(I, J) = (MASKS(I, J, K, BI, BJ) *(SIGMAY(I, J, K)
     >  + SIGMAY(I, J, KM1)) * 5.0D-01)
              DSIGMADRS(I, J) = (MASKS(I, J, K, BI, BJ) *(SIGMAR(I, J,
     >  K) + SIGMAR(I, J + (-1), K)) * 5.0D-01)
            END DO
          END DO
          CALL gmredi_slope_psi(TAPERX, TAPERY, SLOPEX, SLOPEY,
     >  DSIGMADRW, DSIGMADRS, LDD97_LRHOW, LDD97_LRHOS, RF(K), (K), BI,
     >  BJ, MYTHID)
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              GM_PSIX(I, J, K, BI, BJ) = (MASKW(I, J, K, BI, BJ) *
     >  SLOPEX(I, J) * TAPERX(I, J) *(GM_BACKGROUND_K))
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              GM_PSIY(I, J, K, BI, BJ) = (MASKS(I, J, K, BI, BJ) *
     >  SLOPEY(I, J) * TAPERY(I, J) *(GM_BACKGROUND_K))
            END DO
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_calc_tensor(IMIN, IMAX, JMIN, JMAX, SIGMAX,
     >  SIGMAY, SIGMAR, BI, BJ, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use gmredi_mod
      use gmredi_tave_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) SIGMAX(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAY(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAR(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) BASESLOPE(-2 : 93, -2 : 43)
      REAL(w2f__8) CSPD
      REAL(w2f__8) DSIGMADR(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADX(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADY(-2 : 93, -2 : 43)
      REAL(w2f__8) FCORILOC
      EXTERNAL gmredi_calc_psi_b
      EXTERNAL gmredi_slope_limit
      REAL(w2f__8) HTRANSLAY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      REAL(w2f__8) KGM_TMP
      INTEGER(w2f__i4) KLOW_S(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) KLOW_W(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) LDD97_LRHOC(-2 : 93, -2 : 43)
      REAL(w2f__8) LDD97_LRHOS(-2 : 93, -2 : 43)
      REAL(w2f__8) LDD97_LRHOW(-2 : 93, -2 : 43)
      REAL(w2f__8) LOCMIXLAYER(-2 : 93, -2 : 43)
      REAL(w2f__8) LRHOINF
      REAL(w2f__8) LRHOSUP
      REAL(w2f__8) MASKP1
      REAL(w2f__8) RECIPLAMBDA(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPESQR(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPEX(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPEY(-2 : 93, -2 : 43)
      REAL(w2f__8) TAPERFCT(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IGMKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      IF((GM_TAPER_SCHEME .EQ. 'fm07') .OR.(GM_TAPER_SCHEME .EQ.
     >  'ldd97')) THEN
        CSPD = 2.0D00
        LRHOINF = 1.5D+04
        LRHOSUP = 1.0D+05
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            IF(FCORI(I, J, BI, BJ) .ne. 0.0D00) THEN
              LDD97_LRHOC(I, J) = (CSPD / ABS(FCORI(I, J, BI, BJ)))
            ELSE
              LDD97_LRHOC(I, J) = LRHOSUP
            ENDIF
            LDD97_LRHOC(I, J) = MAX(LRHOINF, MIN(LDD97_LRHOC(I, J),
     >  LRHOSUP))
          END DO
        END DO
        DO J = -2, 43, 1
          KLOW_W((-2), J) = 0
          LDD97_LRHOW((-2), J) = LRHOSUP
          DO I = -1, 93, 1
            KLOW_W(I, J) = MIN(KLOWC(I, J, BI, BJ), KLOWC(I + (-1), J,
     >  BI, BJ))
            FCORILOC = (FCORI(I, J, BI, BJ) + FCORI(I + (-1), J, BI, BJ
     > )) * 5.0D-01
            IF(FCORILOC .ne. 0.0D00) THEN
              LDD97_LRHOW(I, J) = (CSPD / ABS(FCORILOC))
            ELSE
              LDD97_LRHOW(I, J) = LRHOSUP
            ENDIF
            LDD97_LRHOW(I, J) = MAX(LRHOINF, MIN(LDD97_LRHOW(I, J),
     >  LRHOSUP))
          END DO
        END DO
        DO I = -1, 93, 1
          KLOW_S(I, (-2)) = 0
          LDD97_LRHOS(I, (-2)) = LRHOSUP
        END DO
        DO J = -1, 43, 1
          DO I = -2, 93, 1
            KLOW_S(I, J) = MIN(KLOWC(I, J, BI, BJ), KLOWC(I, J + (-1),
     >  BI, BJ))
            FCORILOC = (FCORI(I, J, BI, BJ) + FCORI(I, J + (-1), BI, BJ
     > )) * 5.0D-01
            IF(FCORILOC .ne. 0.0D00) THEN
              LDD97_LRHOS(I, J) = (CSPD / ABS(FCORILOC))
            ELSE
              LDD97_LRHOS(I, J) = LRHOSUP
            ENDIF
            LDD97_LRHOS(I, J) = MAX(LRHOINF, MIN(LDD97_LRHOS(I, J),
     >  LRHOSUP))
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            LDD97_LRHOC(I, J) = 0.0D00
            LDD97_LRHOW(I, J) = 0.0D00
            LDD97_LRHOS(I, J) = 0.0D00
          END DO
        END DO
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          HTRANSLAY(I, J) = R_LOW(I, J, BI, BJ)
          BASESLOPE(I, J) = 0.0D00
          RECIPLAMBDA(I, J) = 0.0D00
          LOCMIXLAYER(I, J) = 0.0D00
        END DO
      END DO
      IF(.TRUE.) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            LOCMIXLAYER(I, J) = HMIXLAYER(I, J, BI, BJ)
          END DO
        END DO
      ENDIF
      DO K = 15, 2, (-1)
        KKEY = K + IGMKEY * 15 +(-15)
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            SLOPEX(I, J) = 0.0D00
            SLOPEY(I, J) = 0.0D00
            DSIGMADX(I, J) = 0.0D00
            DSIGMADY(I, J) = 0.0D00
            DSIGMADR(I, J) = 0.0D00
            SLOPESQR(I, J) = 0.0D00
            TAPERFCT(I, J) = 0.0D00
            KWX(I, J, K, BI, BJ) = 0.0D00
            KWY(I, J, K, BI, BJ) = 0.0D00
            KWZ(I, J, K, BI, BJ) = 0.0D00
            KUX(I, J, K, BI, BJ) = 0.0D00
            KVY(I, J, K, BI, BJ) = 0.0D00
            KUZ(I, J, K, BI, BJ) = 0.0D00
            KVZ(I, J, K, BI, BJ) = 0.0D00
            GM_PSIX(I, J, K, BI, BJ) = 0.0D00
            GM_PSIY(I, J, K, BI, BJ) = 0.0D00
          END DO
        END DO
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            DSIGMADX(I, J) = (MASKC(I, J, K, BI, BJ) *(SIGMAX(I, J, K)
     >  + SIGMAX(I + 1, J, K) + SIGMAX(I, J, K + (-1)) + SIGMAX(I + 1,
     >  J, K + (-1))) * 2.5D-01)
            DSIGMADY(I, J) = (MASKC(I, J, K, BI, BJ) *(SIGMAY(I, J, K)
     >  + SIGMAY(I, J + 1, K) + SIGMAY(I, J, K + (-1)) + SIGMAY(I, J +
     >  1, K + (-1))) * 2.5D-01)
          END DO
        END DO
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DSIGMADR(I, J) = SIGMAR(I, J, K)
          END DO
        END DO
        CALL gmredi_slope_limit(SLOPEX, SLOPEY, SLOPESQR, TAPERFCT,
     >  HTRANSLAY, BASESLOPE, RECIPLAMBDA, DSIGMADR, DSIGMADX, DSIGMADY
     > , LDD97_LRHOC, LOCMIXLAYER, RF, KLOWC((-2), (-2), BI, BJ), (K),
     >  BI, BJ, MYTIME, MYITER, MYTHID)
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            SLOPEX(I, J) = (SLOPEX(I, J) * MASKC(I, J, K, BI, BJ))
            SLOPEY(I, J) = (SLOPEY(I, J) * MASKC(I, J, K, BI, BJ))
            SLOPESQR(I, J) = (SLOPESQR(I, J) * MASKC(I, J, K, BI, BJ))
          END DO
        END DO
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            KWX(I, J, K, BI, BJ) = (SLOPEX(I, J) * TAPERFCT(I, J))
            KWY(I, J, K, BI, BJ) = (SLOPEY(I, J) * TAPERFCT(I, J))
            KWZ(I, J, K, BI, BJ) = (SLOPESQR(I, J) * TAPERFCT(I, J))
          END DO
        END DO
      END DO
      DO K = 1, 15, 1
        KKEY = K + IGMKEY * 15 +(-15)
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            KGM_TMP = GM_ISOPYCK + GM_BACKGROUND_K * GM_SKEWFLX
            KWX(I, J, K, BI, BJ) = (KWX(I, J, K, BI, BJ) * KGM_TMP)
            KWY(I, J, K, BI, BJ) = (KWY(I, J, K, BI, BJ) * KGM_TMP)
            KWZ(I, J, K, BI, BJ) = (KWZ(I, J, K, BI, BJ) *(GM_ISOPYCK))
          END DO
        END DO
      END DO
      IF(.TRUE.) THEN
        DO J = -2, 43, 1
          DO I = -1, 93, 1
            LOCMIXLAYER(I, J) = ((HMIXLAYER(I, J, BI, BJ) + HMIXLAYER(I
     >  + (-1), J, BI, BJ)) * 5.0D-01)
          END DO
        END DO
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          HTRANSLAY(I, J) = 0.0D00
          BASESLOPE(I, J) = 0.0D00
          RECIPLAMBDA(I, J) = 0.0D00
        END DO
        DO I = -1, 93, 1
          HTRANSLAY(I, J) = MAX(R_LOW(I, J, BI, BJ), R_LOW(I + (-1), J,
     >  BI, BJ))
        END DO
      END DO
      DO K = 15, 1, (-1)
        KP1 = MIN(K + 1, 15)
        MASKP1 = 1.0D00
        IF(K .GE. 15) THEN
          MASKP1 = 0.0D00
        ENDIF
        KKEY = K + IGMKEY * 15 +(-15)
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            DSIGMADX(I, J) = (SIGMAX(I, J, K) * MASKW(I, J, K, BI, BJ))
            DSIGMADY(I, J) = (MASKW(I, J, K, BI, BJ) *(SIGMAY(I, J, K)
     >  + SIGMAY(I + (-1), J, K) + SIGMAY(I, J + 1, K) + SIGMAY(I + (-1
     > ), J + 1, K)) * 2.5D-01)
            DSIGMADR(I, J) = (MASKW(I, J, K, BI, BJ) *(SIGMAR(I, J, K)
     >  + SIGMAR(I + (-1), J, K) + MASKP1 *(SIGMAR(I, J, KP1) + SIGMAR(
     > I + (-1), J, KP1))) * 2.5D-01)
          END DO
        END DO
        CALL gmredi_slope_limit(SLOPEX, SLOPEY, SLOPESQR, TAPERFCT,
     >  HTRANSLAY, BASESLOPE, RECIPLAMBDA, DSIGMADR, DSIGMADX, DSIGMADY
     > , LDD97_LRHOW, LOCMIXLAYER, RC, KLOW_W, (K), BI, BJ, MYTIME,
     >  MYITER, MYTHID)
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            KUX(I, J, K, BI, BJ) = (TAPERFCT(I, J) *(GM_ISOPYCK))
          END DO
        END DO
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            KUX(I, J, K, BI, BJ) = MAX(KUX(I, J, K, BI, BJ),
     >  GM_KMIN_HORIZ)
          END DO
        END DO
        IF(GM_EXTRADIAG) THEN
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              KUZ(I, J, K, BI, BJ) = (TAPERFCT(I, J) * SLOPEX(I, J) *(
     > GM_ISOPYCK - GM_BACKGROUND_K * GM_SKEWFLX))
            END DO
          END DO
        ENDIF
      END DO
      IF(.TRUE.) THEN
        DO J = -1, 43, 1
          DO I = -2, 93, 1
            LOCMIXLAYER(I, J) = ((HMIXLAYER(I, J, BI, BJ) + HMIXLAYER(I
     > , J + (-1), BI, BJ)) * 5.0D-01)
          END DO
        END DO
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          HTRANSLAY(I, J) = 0.0D00
          BASESLOPE(I, J) = 0.0D00
          RECIPLAMBDA(I, J) = 0.0D00
        END DO
      END DO
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          HTRANSLAY(I, J) = MAX(R_LOW(I, J, BI, BJ), R_LOW(I, J + (-1),
     >  BI, BJ))
        END DO
      END DO
      DO K = 15, 1, (-1)
        KP1 = MIN(K + 1, 15)
        MASKP1 = 1.0D00
        IF(K .GE. 15) THEN
          MASKP1 = 0.0D00
        ENDIF
        KKEY = K + IGMKEY * 15 +(-15)
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            DSIGMADX(I, J) = (MASKS(I, J, K, BI, BJ) *(SIGMAX(I + 1, J
     >  + (-1), K) + SIGMAX(I, J + (-1), K) + SIGMAX(I, J, K) + SIGMAX(
     > I + 1, J, K)) * 2.5D-01)
            DSIGMADY(I, J) = (SIGMAY(I, J, K) * MASKS(I, J, K, BI, BJ))
            DSIGMADR(I, J) = (MASKS(I, J, K, BI, BJ) *(SIGMAR(I, J, K)
     >  + SIGMAR(I, J + (-1), K) + MASKP1 *(SIGMAR(I, J, KP1) + SIGMAR(
     > I, J + (-1), KP1))) * 2.5D-01)
          END DO
        END DO
        CALL gmredi_slope_limit(SLOPEX, SLOPEY, SLOPESQR, TAPERFCT,
     >  HTRANSLAY, BASESLOPE, RECIPLAMBDA, DSIGMADR, DSIGMADX, DSIGMADY
     > , LDD97_LRHOS, LOCMIXLAYER, RC, KLOW_S, (K), BI, BJ, MYTIME,
     >  MYITER, MYTHID)
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            KVY(I, J, K, BI, BJ) = (TAPERFCT(I, J) *(GM_ISOPYCK))
          END DO
        END DO
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            KVY(I, J, K, BI, BJ) = MAX(KVY(I, J, K, BI, BJ),
     >  GM_KMIN_HORIZ)
          END DO
        END DO
        IF(GM_EXTRADIAG) THEN
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              KVZ(I, J, K, BI, BJ) = (TAPERFCT(I, J) * SLOPEY(I, J) *(
     > GM_ISOPYCK - GM_BACKGROUND_K * GM_SKEWFLX))
            END DO
          END DO
        ENDIF
      END DO
      IF(GM_ADVFORM) THEN
        CALL gmredi_calc_psi_b(BI, BJ, IMIN, IMAX, JMIN, JMAX, SIGMAX,
     >  SIGMAY, SIGMAR, LDD97_LRHOW, LDD97_LRHOS, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_calc_tensor_dummy(IMIN, IMAX, JMIN, JMAX,
     >  SIGMAX, SIGMAY, SIGMAR, BI, BJ, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) SIGMAX(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAY(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAR(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO K = 1, 15, 1
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            KWX(I, J, K, BI, BJ) = 0.0D00
            KWY(I, J, K, BI, BJ) = 0.0D00
            KWZ(I, J, K, BI, BJ) = 0.0D00
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_calc_uvflow(UFLD, VFLD, UTRANS, VTRANS, K, BI,
     >  BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DELPSI
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) MASKP1
C
C     **** Statements ****
C
      IF((GM_ADVFORM .AND.(.NOT. GM_ADVSEPARATE)) .AND.(.NOT.
     >  GM_INMOMASSTRESS)) THEN
        KP1 = MIN(K + 1, 15)
        MASKP1 = 1.0D00
        IF(K .GE. 15) THEN
          MASKP1 = 0.0D00
        ENDIF
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DELPSI = GM_PSIX(I, J, KP1, BI, BJ) * MASKP1 - GM_PSIX(I, J
     > , K, BI, BJ)
            UFLD(I, J) = (UFLD(I, J) + RECIP_HFACW(I, J, K, BI, BJ) *
     >  RECIP_DRF(K) * DELPSI)
            UTRANS(I, J) = (UTRANS(I, J) + MASKW(I, J, K, BI, BJ) * DYG
     > (I, J, BI, BJ) * DELPSI)
          END DO
        END DO
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DELPSI = GM_PSIY(I, J, KP1, BI, BJ) * MASKP1 - GM_PSIY(I, J
     > , K, BI, BJ)
            VFLD(I, J) = (VFLD(I, J) + RECIP_HFACS(I, J, K, BI, BJ) *
     >  RECIP_DRF(K) * DELPSI)
            VTRANS(I, J) = (VTRANS(I, J) + MASKS(I, J, K, BI, BJ) * DXG
     > (I, J, BI, BJ) * DELPSI)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_calc_wflow(WFLD, RTRANS, K, BI, BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DELPSI
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF((GM_ADVFORM .AND.(.NOT. GM_ADVSEPARATE)) .AND.(.NOT.
     >  GM_INMOMASSTRESS)) THEN
        DO J = -2, 42, 1
          DO I = -2, 92, 1
            DELPSI = MASKC(I, J, K, BI, BJ) *(DXG(I, J + 1, BI, BJ) *
     >  GM_PSIY(I, J + 1, K, BI, BJ) + DYG(I + 1, J, BI, BJ) * GM_PSIX(
     > I + 1, J, K, BI, BJ) - DYG(I, J, BI, BJ) * GM_PSIX(I, J, K, BI,
     >  BJ) - DXG(I, J, BI, BJ) * GM_PSIY(I, J, K, BI, BJ))
            WFLD(I, J) = (WFLD(I, J) + RECIP_RA(I, J, BI, BJ) * DELPSI)
            RTRANS(I, J) = (RTRANS(I, J) + DELPSI)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_init(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gmredi_mod
      use gmredi_tave_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                KWX(I, J, K, BI, BJ) = 0.0D00
                KWY(I, J, K, BI, BJ) = 0.0D00
                KWZ(I, J, K, BI, BJ) = 0.0D00
                KUZ(I, J, K, BI, BJ) = 0.0D00
                KVZ(I, J, K, BI, BJ) = 0.0D00
                KUX(I, J, K, BI, BJ) = 0.0D00
                KVY(I, J, K, BI, BJ) = 0.0D00
                GM_PSIX(I, J, K, BI, BJ) = 0.0D00
                GM_PSIY(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_rtransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  TRACER, TRACERIDENTITY, DF, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gmredi_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) TRACERIDENTITY
      REAL(w2f__8) DF(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DTDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DTDY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT0 = TRACERIDENTITY +(-1)
      MAX0 = 2
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IGADKEY = ACT0 + ACT1 * MAX0 + MAX1 * ACT2 * MAX0 + MAX2 * MAX1 *
     >  ACT3 * MAX0 + MAX3 * MAX2 * MAX1 * ACT4 * MAX0 + 1
      KKEY = K + IGADKEY * 15 +(-15)
      IF(TRACERIDENTITY .GT. 2) THEN
        WRITE(*, *) 'ph-pass gmredi_rtrans ', 2, TRACERIDENTITY
        WRITE(*, *) 'maxpass seems smaller than tracerIdentity'
      ENDIF
      IF((K .GT. 1) .AND. USEGMREDI) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            DTDX(I, J) = (((RECIP_DXC(I, J, BI, BJ) * MASKW(I, J, K, BI
     > , BJ) *(TRACER(I, J, K, BI, BJ) - TRACER(I + (-1), J, K, BI, BJ)
     > ) + RECIP_DXC(I + 1, J, BI, BJ) * MASKW(I + 1, J, K, BI, BJ) *(
     > TRACER(I + 1, J, K, BI, BJ) - TRACER(I, J, K, BI, BJ))) *
     >  5.0D-01 +(RECIP_DXC(I, J, BI, BJ) * MASKW(I, J, K + (-1), BI,
     >  BJ) *(TRACER(I, J, K + (-1), BI, BJ) - TRACER(I + (-1), J, K +
     >  (-1), BI, BJ)) + RECIP_DXC(I + 1, J, BI, BJ) * MASKW(I + 1, J,
     >  K + (-1), BI, BJ) *(TRACER(I + 1, J, K + (-1), BI, BJ) - TRACER
     > (I, J, K + (-1), BI, BJ))) * 5.0D-01) * 5.0D-01)
            DTDY(I, J) = (((RECIP_DYC(I, J, BI, BJ) * MASKS(I, J, K, BI
     > , BJ) *(TRACER(I, J, K, BI, BJ) - TRACER(I, J + (-1), K, BI, BJ)
     > ) + RECIP_DYC(I, J + 1, BI, BJ) * MASKS(I, J + 1, K, BI, BJ) *(
     > TRACER(I, J + 1, K, BI, BJ) - TRACER(I, J, K, BI, BJ))) *
     >  5.0D-01 +(RECIP_DYC(I, J, BI, BJ) * MASKS(I, J, K + (-1), BI,
     >  BJ) *(TRACER(I, J, K + (-1), BI, BJ) - TRACER(I, J + (-1), K +
     >  (-1), BI, BJ)) + RECIP_DYC(I, J + 1, BI, BJ) * MASKS(I, J + 1,
     >  K + (-1), BI, BJ) *(TRACER(I, J + 1, K + (-1), BI, BJ) - TRACER
     > (I, J, K + (-1), BI, BJ))) * 5.0D-01) * 5.0D-01)
          END DO
        END DO
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            DF(I, J) = (DF(I, J) - RA(I, J, BI, BJ) *(DTDX(I, J) * KWX(
     > I, J, K, BI, BJ) + DTDY(I, J) * KWY(I, J, K, BI, BJ)))
          END DO
        END DO
        IF((GM_ADVFORM .AND. GM_ADVSEPARATE) .AND.(.NOT.
     >  GM_INMOMASSTRESS)) THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              RTRANS(I, J) = (DXG(I, J + 1, BI, BJ) * GM_PSIY(I, J + 1,
     >  K, BI, BJ) + DYG(I + 1, J, BI, BJ) * GM_PSIX(I + 1, J, K, BI,
     >  BJ) - DYG(I, J, BI, BJ) * GM_PSIX(I, J, K, BI, BJ) - DXG(I, J,
     >  BI, BJ) * GM_PSIY(I, J, K, BI, BJ))
            END DO
          END DO
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              DF(I, J) = (DF(I, J) + RTRANS(I, J) * 5.0D-01 *(TRACER(I,
     >  J, K, BI, BJ) + TRACER(I, J, K + (-1), BI, BJ)))
            END DO
          END DO
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_slope_limit(SLOPEX, SLOPEY, SLOPESQR, TAPERFCT,
     >  HTRANSLAY, BASESLOPE, RECIPLAMBDA, DSIGMADR, DSIGMADX, DSIGMADY
     > , LRHO, HMIXLAY, DEPTHZ, KLOW, K, BI, BJ, MYTIME, MYITER, MYTHID
     > )
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use gmredi_mod
      use params_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) SLOPEX(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPEY(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPESQR(-2 : 93, -2 : 43)
      REAL(w2f__8) TAPERFCT(-2 : 93, -2 : 43)
      REAL(w2f__8) HTRANSLAY(-2 : 93, -2 : 43)
      REAL(w2f__8) BASESLOPE(-2 : 93, -2 : 43)
      REAL(w2f__8) RECIPLAMBDA(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADR(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADX(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADY(-2 : 93, -2 : 43)
      REAL(w2f__8) LRHO(-2 : 93, -2 : 43)
      REAL(w2f__8) HMIXLAY(-2 : 93, -2 : 43)
      REAL(w2f__8) DEPTHZ(1 : *)
      INTEGER(w2f__i4) KLOW(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DOVERLAMB
      REAL(w2f__8) DRDSIGMALTD(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMMOD(-2 : 93, -2 : 43)
      REAL(w2f__8) DTRANSLAY
      REAL(w2f__8) F1
      REAL(w2f__8) F2
      REAL(w2f__8) FPI
      PARAMETER ( FPI = 3.141592653589793116D00)
      REAL(w2f__8) GM_BIGSLOPE
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) LOCVAR(-2 : 93, -2 : 43)
      REAL(w2f__8) MAXSLOPESQR
      REAL(w2f__8) MINTRANSLAY
      REAL(w2f__8) RLAMBMIN
      REAL(w2f__8) RNONDIM
      REAL(w2f__8) SLOPEMOD(-2 : 93, -2 : 43)
      REAL(w2f__8) SMOD
      REAL(w2f__8) TAPERFCTHAT
      REAL(w2f__8) TAPERFCTLOC
      REAL(w2f__8) TMPFLD(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      GM_BIGSLOPE = 1.0D+02
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          DSIGMMOD(I, J) = 0.0D00
          TMPFLD(I, J) = 0.0D00
        END DO
      END DO
      IF((GM_TAPER_SCHEME .EQ. 'orig') .OR.(GM_TAPER_SCHEME .EQ.
     >  'clipping')) THEN
        WRITE(*, *) 'Need to compile without "#define GM_EXCLUDE_CLIP'
     >  // 'PING"'
      ELSE
        IF(GM_TAPER_SCHEME .EQ. 'fm07') THEN
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              IF(KLOW(I, J) .LT. K) THEN
                SLOPEX(I, J) = 0.0D00
                SLOPEY(I, J) = 0.0D00
                SLOPEMOD(I, J) = 0.0D00
                TAPERFCT(I, J) = 0.0D00
              ELSE
                IF(DSIGMADR(I, J) .GE.(- GM_SMALL_NUMBER)) THEN
                  DSIGMADR(I, J) = (- GM_SMALL_NUMBER)
                ENDIF
                TMPFLD(I, J) = (DSIGMADX(I, J) * DSIGMADX(I, J) +
     >  DSIGMADY(I, J) * DSIGMADY(I, J))
                IF(TMPFLD(I, J) .GT. 0.0D00) THEN
                  LOCVAR(I, J) = SQRT(TMPFLD(I, J))
                  SLOPEX(I, J) = (DSIGMADX(I, J) / LOCVAR(I, J))
                  SLOPEY(I, J) = (DSIGMADY(I, J) / LOCVAR(I, J))
                  SLOPEMOD(I, J) = (-(LOCVAR(I, J) / DSIGMADR(I, J)))
                  TAPERFCT(I, J) = 1.0D00
                ELSE
                  SLOPEX(I, J) = 0.0D00
                  SLOPEY(I, J) = 0.0D00
                  SLOPEMOD(I, J) = 0.0D00
                  TAPERFCT(I, J) = 0.0D00
                ENDIF
              ENDIF
            END DO
          END DO
          IF(K .eq. 1) THEN
            MINTRANSLAY = GM_FACTRL2DZ *(DEPTHZ(K) - DEPTHZ(K + 1))
          ELSE
            MINTRANSLAY = GM_FACTRL2DZ *(DEPTHZ(K + (-1)) - DEPTHZ(K))
          ENDIF
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              IF(HTRANSLAY(I, J) .LE. 0.0D00) THEN
                TMPFLD(I, J) = (LRHO(I, J) * SLOPEMOD(I, J))
                DTRANSLAY = MIN(MAX(TMPFLD(I, J), MINTRANSLAY), MAX(
     > GM_MAXTRANSLAY, HMIXLAY(I, J) * GM_FACTRL2ML))
                IF(KLOW(I, J) .LE. K) THEN
                  RECIPLAMBDA(I, J) = 0.0D00
                  BASESLOPE(I, J) = SLOPEMOD(I, J)
                ELSE
                  IF((DEPTHZ(K) + HMIXLAY(I, J) + DTRANSLAY) .GE.
     >  0.0D00) THEN
                    HTRANSLAY(I, J) = (- DEPTHZ(K + 1))
                    IF(BASESLOPE(I, J) .GT. 0.0D00) THEN
                      RECIPLAMBDA(I, J) = (RECIPLAMBDA(I, J) / MIN(
     > BASESLOPE(I, J), GM_MAXSLOPE))
                    ELSE
                      RECIPLAMBDA(I, J) = 0.0D00
                    ENDIF
                    IF((DEPTHZ(K + 1) + HMIXLAY(I, J)) .LT. 0.0D00)
     >  THEN
                      RLAMBMIN = 1D00 / (DEPTHZ(K + 1) + HMIXLAY(I, J))
                      RECIPLAMBDA(I, J) = MAX(RECIPLAMBDA(I, J),
     >  RLAMBMIN)
                    ENDIF
                  ELSE
                    RECIPLAMBDA(I, J) = ((MIN(SLOPEMOD(I, J),
     >  GM_MAXSLOPE) - MIN(BASESLOPE(I, J), GM_MAXSLOPE)) /(DEPTHZ(K) -
     >  DEPTHZ(K + 1)))
                    BASESLOPE(I, J) = SLOPEMOD(I, J)
                  ENDIF
                ENDIF
              ENDIF
            END DO
          END DO
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              IF(HTRANSLAY(I, J) .GT. 0.0D00) THEN
                DOVERLAMB = RECIPLAMBDA(I, J) *(HTRANSLAY(I, J) -
     >  HMIXLAY(I, J))
                IF(HMIXLAY(I, J) .GE.(- DEPTHZ(K))) THEN
                  TAPERFCTLOC = (-((DEPTHZ(K) /(HTRANSLAY(I, J) +
     >  HMIXLAY(I, J))) *(DOVERLAMB + 2.0D00)))
                  TAPERFCTHAT = (-((DEPTHZ(K) /(HTRANSLAY(I, J) +
     >  HMIXLAY(I, J))) * 2.0D00 *(DOVERLAMB + 1.0D00)))
                ELSE
                  TAPERFCTLOC = (-((DEPTHZ(K) /(HTRANSLAY(I, J) +
     >  HMIXLAY(I, J))) *(DOVERLAMB + 2.0D00))) -((((DEPTHZ(K) +
     >  HMIXLAY(I, J)) *(DEPTHZ(K) + HMIXLAY(I, J))) /(HTRANSLAY(I, J)
     >  * HTRANSLAY(I, J) - HMIXLAY(I, J) * HMIXLAY(I, J))) *(HTRANSLAY
     > (I, J) * RECIPLAMBDA(I, J) + 1.0D00))
                  TAPERFCTHAT = (-((DEPTHZ(K) /(HTRANSLAY(I, J) +
     >  HMIXLAY(I, J))) * 2.0D00 *(DOVERLAMB + 1.0D00))) -((((DEPTHZ(K)
     >  + HMIXLAY(I, J)) *(DEPTHZ(K) + HMIXLAY(I, J))) /(HTRANSLAY(I, J
     > ) * HTRANSLAY(I, J) - HMIXLAY(I, J) * HMIXLAY(I, J))) *(
     > HTRANSLAY(I, J) * RECIPLAMBDA(I, J) * 2.0D00 + 1.0D00))
                ENDIF
                SMOD = MIN(BASESLOPE(I, J), GM_MAXSLOPE)
                SLOPEX(I, J) = (TAPERFCTLOC * SLOPEX(I, J) * SMOD)
                SLOPEY(I, J) = (TAPERFCTLOC * SLOPEY(I, J) * SMOD)
                SLOPESQR(I, J) = (TAPERFCTHAT * SMOD * MIN(BASESLOPE(I,
     >  J), GM_BIGSLOPE))
              ELSE
                SMOD = MIN(SLOPEMOD(I, J), GM_MAXSLOPE)
                SLOPEX(I, J) = (SLOPEX(I, J) * SMOD)
                SLOPEY(I, J) = (SLOPEY(I, J) * SMOD)
                SLOPESQR(I, J) = (SMOD * MIN(SLOPEMOD(I, J),
     >  GM_BIGSLOPE))
              ENDIF
            END DO
          END DO
        ELSE
          IF(GM_TAPER_SCHEME .EQ. 'ac02') THEN
            WRITE(*, *)
     >  'Need to compile without "#define GM_EXCLUDE_AC02' // '_TAP"'
          ELSE
            DO J = -1, 42, 1
              DO I = -1, 92, 1
                IF(DSIGMADR(I, J) .ne. 0.0D00) THEN
                  IF(DSIGMADR(I, J) .GE.(- GM_SMALL_NUMBER)) THEN
                    DSIGMADR(I, J) = (- GM_SMALL_NUMBER)
                  ENDIF
                ENDIF
              END DO
            END DO
            DO J = -1, 42, 1
              DO I = -1, 92, 1
                IF(DSIGMADR(I, J) .eq. 0.0D00) THEN
                  IF(DSIGMADX(I, J) .ne. 0.0D00) THEN
                    SLOPEX(I, J) = SIGN(GM_BIGSLOPE, DSIGMADX(I, J))
                  ELSE
                    SLOPEX(I, J) = 0.0D00
                  ENDIF
                  IF(DSIGMADY(I, J) .ne. 0.0D00) THEN
                    SLOPEY(I, J) = SIGN(GM_BIGSLOPE, DSIGMADY(I, J))
                  ELSE
                    SLOPEY(I, J) = 0.0D00
                  ENDIF
                ELSE
                  DRDSIGMALTD(I, J) = 1D00 / (DSIGMADR(I, J))
                  SLOPEX(I, J) = (-(DSIGMADX(I, J) * DRDSIGMALTD(I, J))
     > )
                  SLOPEY(I, J) = (-(DSIGMADY(I, J) * DRDSIGMALTD(I, J))
     > )
                ENDIF
              END DO
            END DO
            DO J = -1, 42, 1
              DO I = -1, 92, 1
                SLOPESQR(I, J) = (SLOPEX(I, J) * SLOPEX(I, J) + SLOPEY(
     > I, J) * SLOPEY(I, J))
                TAPERFCT(I, J) = 1.0D00
                IF(SLOPESQR(I, J) .GT. GM_SLOPESQCUTOFF) THEN
                  SLOPESQR(I, J) = GM_SLOPESQCUTOFF
                  TAPERFCT(I, J) = 0.0D00
                ENDIF
              END DO
            END DO
            IF(GM_TAPER_SCHEME .EQ. 'linear') THEN
              MAXSLOPESQR = GM_MAXSLOPE * GM_MAXSLOPE
              DO J = -1, 42, 1
                DO I = -1, 92, 1
                  IF(SLOPESQR(I, J) .eq. 0.0D00) THEN
                    TAPERFCT(I, J) = 1.0D00
                  ELSE
                    IF((SLOPESQR(I, J) .GT. MAXSLOPESQR) .AND.(SLOPESQR
     > (I, J) .LT. GM_SLOPESQCUTOFF)) THEN
                      TAPERFCT(I, J) = SQRT(MAXSLOPESQR / SLOPESQR(I, J
     > ))
                      SLOPESQR(I, J) = MIN(SLOPESQR(I, J), GM_BIGSLOPE
     >  * GM_BIGSLOPE)
                    ENDIF
                  ENDIF
                END DO
              END DO
            ELSE
              IF(GM_TAPER_SCHEME .EQ. 'gkw91') THEN
                MAXSLOPESQR = GM_MAXSLOPE * GM_MAXSLOPE
                DO J = -1, 42, 1
                  DO I = -1, 92, 1
                    IF(SLOPESQR(I, J) .eq. 0.0D00) THEN
                      TAPERFCT(I, J) = 1.0D00
                    ELSE
                      IF((SLOPESQR(I, J) .GT. MAXSLOPESQR) .AND.(
     > SLOPESQR(I, J) .LT. GM_SLOPESQCUTOFF)) THEN
                        TAPERFCT(I, J) = (MAXSLOPESQR / SLOPESQR(I, J))
                      ENDIF
                    ENDIF
                  END DO
                END DO
              ELSE
                IF(GM_TAPER_SCHEME .EQ. 'dm95') THEN
                  DO J = -1, 42, 1
                    DO I = -1, 92, 1
                      IF(SLOPESQR(I, J) .eq. 0.0D00) THEN
                        TAPERFCT(I, J) = 1.0D00
                      ELSE
                        IF(SLOPESQR(I, J) .LT. GM_SLOPESQCUTOFF) THEN
                          SMOD = SQRT(SLOPESQR(I, J))
                          TAPERFCT(I, J) = ((TANH((GM_SCRIT - SMOD) /
     >  GM_SD) + 1.0D00) * 5.0D-01)
                        ENDIF
                      ENDIF
                    END DO
                  END DO
                ELSE
                  IF(GM_TAPER_SCHEME .EQ. 'ldd97') THEN
                    DO J = -1, 42, 1
                      DO I = -1, 92, 1
                        IF(SLOPESQR(I, J) .eq. 0.0D00) THEN
                          TAPERFCT(I, J) = 1.0D00
                        ELSE
                          IF(SLOPESQR(I, J) .LT. GM_SLOPESQCUTOFF) THEN
                            SMOD = SQRT(SLOPESQR(I, J))
                            F1 = (TANH((GM_SCRIT - SMOD) / GM_SD) +
     >  1.0D00) * 5.0D-01
                            RNONDIM = -(DEPTHZ(K) /(LRHO(I, J) * SMOD))
                            IF(RNONDIM .GE. 1.0D00) THEN
                              F2 = 1.0D00
                            ELSE
                              F2 = (SIN((RNONDIM +(-5.0D-01)) *
     >  3.141592653589793116D00) + 1.0D00) * 5.0D-01
                            ENDIF
                            TAPERFCT(I, J) = (F1 * F2)
                          ENDIF
                        ENDIF
                      END DO
                    END DO
                  ELSE
                    IF(GM_TAPER_SCHEME .NE. ' ') THEN
                      WRITE(*, *)
     >  'GMREDI_SLOPE_LIMIT: Bad GM_taper_scheme'
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_slope_psi(TAPERX, TAPERY, SLOPEX, SLOPEY,
     >  DSIGMADRW, DSIGMADRS, LRHOW, LRHOS, DEPTHZ, K, BI, BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use gmredi_mod
      use params_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) TAPERX(-2 : 93, -2 : 43)
      REAL(w2f__8) TAPERY(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPEX(-2 : 93, -2 : 43)
      REAL(w2f__8) SLOPEY(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADRW(-2 : 93, -2 : 43)
      REAL(w2f__8) DSIGMADRS(-2 : 93, -2 : 43)
      REAL(w2f__8) LRHOW(-2 : 93, -2 : 43)
      REAL(w2f__8) LRHOS(-2 : 93, -2 : 43)
      REAL(w2f__8) DEPTHZ
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) F1
      REAL(w2f__8) F2
      REAL(w2f__8) FPI
      PARAMETER ( FPI = 3.141592653589793116D00)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) MAXSLOPESQR
      REAL(w2f__8) RNONDIM
      REAL(w2f__8) SLOPECUTOFF
      REAL(w2f__8) SMOD
C
C     **** Statements ****
C
      SLOPECUTOFF = SQRT(GM_SLOPESQCUTOFF)
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IGMKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      KKEY = K + IGMKEY * 15 +(-15)
      IF((GM_TAPER_SCHEME .EQ. 'orig') .OR.(GM_TAPER_SCHEME .EQ.
     >  'clipping')) THEN
        WRITE(*, *) 'Need to compile without "#define GM_EXCLUDE_CLIP'
     >  // 'PING"'
      ELSE
        IF(GM_TAPER_SCHEME .EQ. 'fm07') THEN
          WRITE(*, *)
     >  'GMREDI_SLOPE_PSI: AdvForm not yet implemented fo' // 'r fm07'
        ELSE
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              IF(DSIGMADRW(I, J) .GE.(- GM_SMALL_NUMBER)) THEN
                DSIGMADRW(I, J) = (- GM_SMALL_NUMBER)
              ENDIF
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              SLOPEX(I, J) = (-(SLOPEX(I, J) / DSIGMADRW(I, J)))
              TAPERX(I, J) = 1.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              IF(SLOPECUTOFF .LE. ABS(SLOPEX(I, J))) THEN
                SLOPEX(I, J) = SIGN(SLOPECUTOFF, SLOPEX(I, J))
                TAPERX(I, J) = 0.0D00
              ENDIF
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              IF(DSIGMADRS(I, J) .GE.(- GM_SMALL_NUMBER)) THEN
                DSIGMADRS(I, J) = (- GM_SMALL_NUMBER)
              ENDIF
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              SLOPEY(I, J) = (-(SLOPEY(I, J) / DSIGMADRS(I, J)))
              TAPERY(I, J) = 1.0D00
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              IF(SLOPECUTOFF .LE. ABS(SLOPEY(I, J))) THEN
                SLOPEY(I, J) = SIGN(SLOPECUTOFF, SLOPEY(I, J))
                TAPERY(I, J) = 0.0D00
              ENDIF
            END DO
          END DO
          IF(GM_TAPER_SCHEME .EQ. 'linear') THEN
            DO J = -2, 43, 1
              DO I = -1, 93, 1
                SMOD = ABS(SLOPEX(I, J))
                IF((SLOPECUTOFF .GT. SMOD) .AND.(SMOD .GT. GM_MAXSLOPE)
     > ) THEN
                  TAPERX(I, J) = (GM_MAXSLOPE /(SMOD + GM_SMALL_NUMBER)
     > )
                ENDIF
              END DO
            END DO
            DO J = -1, 43, 1
              DO I = -2, 93, 1
                SMOD = ABS(SLOPEY(I, J))
                IF((SLOPECUTOFF .GT. SMOD) .AND.(SMOD .GT. GM_MAXSLOPE)
     > ) THEN
                  TAPERY(I, J) = (GM_MAXSLOPE /(SMOD + GM_SMALL_NUMBER)
     > )
                ENDIF
              END DO
            END DO
          ELSE
            IF(GM_TAPER_SCHEME .EQ. 'gkw91') THEN
              MAXSLOPESQR = GM_MAXSLOPE * GM_MAXSLOPE
              DO J = -2, 43, 1
                DO I = -1, 93, 1
                  IF((SLOPECUTOFF .GT. ABS(SLOPEX(I, J))) .AND.(
     > GM_MAXSLOPE .LT. ABS(SLOPEX(I, J)))) THEN
                    TAPERX(I, J) = (MAXSLOPESQR /(GM_SMALL_NUMBER +
     >  SLOPEX(I, J) * SLOPEX(I, J)))
                  ENDIF
                END DO
              END DO
              DO J = -1, 43, 1
                DO I = -2, 93, 1
                  IF((SLOPECUTOFF .GT. ABS(SLOPEY(I, J))) .AND.(
     > GM_MAXSLOPE .LT. ABS(SLOPEY(I, J)))) THEN
                    TAPERY(I, J) = (MAXSLOPESQR /(GM_SMALL_NUMBER +
     >  SLOPEY(I, J) * SLOPEY(I, J)))
                  ENDIF
                END DO
              END DO
            ELSE
              IF(GM_TAPER_SCHEME .EQ. 'dm95') THEN
                DO J = -2, 43, 1
                  DO I = -1, 93, 1
                    SMOD = ABS(SLOPEX(I, J))
                    TAPERX(I, J) = ((TANH((GM_SCRIT - SMOD) / GM_SD) +
     >  1.0D00) * 5.0D-01)
                  END DO
                END DO
                DO J = -1, 43, 1
                  DO I = -2, 93, 1
                    SMOD = ABS(SLOPEY(I, J))
                    TAPERY(I, J) = ((TANH((GM_SCRIT - SMOD) / GM_SD) +
     >  1.0D00) * 5.0D-01)
                  END DO
                END DO
              ELSE
                IF(GM_TAPER_SCHEME .EQ. 'ldd97') THEN
                  DO J = -2, 43, 1
                    DO I = -1, 93, 1
                      SMOD = ABS(SLOPEX(I, J))
                      IF(SLOPECUTOFF .GT. SMOD) THEN
                        F1 = (TANH((GM_SCRIT - SMOD) / GM_SD) + 1.0D00)
     >  * 5.0D-01
                        IF(SMOD .ne. 0.0D00) THEN
                          RNONDIM = -(DEPTHZ /(LRHOW(I, J) * SMOD))
                        ELSE
                          RNONDIM = 1.0D00
                        ENDIF
                        IF(RNONDIM .GE. 1.0D00) THEN
                          F2 = 1.0D00
                        ELSE
                          F2 = (SIN((RNONDIM +(-5.0D-01)) *
     >  3.141592653589793116D00) + 1.0D00) * 5.0D-01
                        ENDIF
                        TAPERX(I, J) = (F1 * F2)
                      ENDIF
                    END DO
                  END DO
                  DO J = -1, 43, 1
                    DO I = -2, 93, 1
                      SMOD = ABS(SLOPEY(I, J))
                      IF(SLOPECUTOFF .GT. SMOD) THEN
                        F1 = (TANH((GM_SCRIT - SMOD) / GM_SD) + 1.0D00)
     >  * 5.0D-01
                        IF(SMOD .ne. 0.0D00) THEN
                          RNONDIM = -(DEPTHZ /(LRHOS(I, J) * SMOD))
                        ELSE
                          RNONDIM = 1.0D00
                        ENDIF
                        IF(RNONDIM .GE. 1.0D00) THEN
                          F2 = 1.0D00
                        ELSE
                          F2 = (SIN((RNONDIM +(-5.0D-01)) *
     >  3.141592653589793116D00) + 1.0D00) * 5.0D-01
                        ENDIF
                        TAPERY(I, J) = (F1 * F2)
                      ENDIF
                    END DO
                  END DO
                ELSE
                  IF(GM_TAPER_SCHEME .NE. ' ') THEN
                    WRITE(*, *) 'GMREDI_SLOPE_PSI: Bad GM_taper_scheme'
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_xtransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  XA, TRACER, TRACERIDENTITY, DF, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gmredi_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) TRACERIDENTITY
      REAL(w2f__8) DF(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DTDZ(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) MASKP1
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT0 = TRACERIDENTITY +(-1)
      MAX0 = 2
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IGADKEY = ACT0 + ACT1 * MAX0 + MAX1 * ACT2 * MAX0 + MAX2 * MAX1 *
     >  ACT3 * MAX0 + MAX3 * MAX2 * MAX1 * ACT4 * MAX0 + 1
      KKEY = K + IGADKEY * 15 +(-15)
      IF(TRACERIDENTITY .GT. 2) THEN
        WRITE(*, *) 'ph-pass gmredi_xtrans ', 2, TRACERIDENTITY
        WRITE(*, *) 'maxpass seems smaller than tracerIdentity'
      ENDIF
      IF(USEGMREDI) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            DF(I, J) = (DF(I, J) - RECIP_DXC(I, J, BI, BJ) * XA(I, J) *
     >  KUX(I, J, K, BI, BJ) *(TRACER(I, J, K, BI, BJ) - TRACER(I + (-1
     > ), J, K, BI, BJ)))
          END DO
        END DO
        IF(GM_EXTRADIAG) THEN
          KM1 = MAX(K +(-1), 1)
          KP1 = MIN(K + 1, 15)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              DTDZ(I, J) = ((RECIP_DRC(K) * 5.0D-01 *(MASKC(I, J, K, BI
     > , BJ) *(TRACER(I, J, KM1, BI, BJ) - TRACER(I, J, K, BI, BJ)) +
     >  MASKC(I + (-1), J, K, BI, BJ) *(TRACER(I + (-1), J, KM1, BI, BJ
     > ) - TRACER(I + (-1), J, K, BI, BJ))) + RECIP_DRC(KP1) * 5.0D-01
     >  *(MASKC(I, J, KP1, BI, BJ) *(TRACER(I, J, K, BI, BJ) - TRACER(I
     > , J, KP1, BI, BJ)) + MASKC(I + (-1), J, KP1, BI, BJ) *(TRACER(I
     >  + (-1), J, K, BI, BJ) - TRACER(I + (-1), J, KP1, BI, BJ)))) *
     >  5.0D-01)
            END DO
          END DO
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              DF(I, J) = (DF(I, J) - DTDZ(I, J) * XA(I, J) * KUZ(I, J,
     >  K, BI, BJ))
            END DO
          END DO
        ENDIF
        IF((GM_ADVFORM .AND. GM_ADVSEPARATE) .AND.(.NOT.
     >  GM_INMOMASSTRESS)) THEN
          KP1 = MIN(K + 1, 15)
          MASKP1 = 1.0D00
          IF(K .GE. 15) THEN
            MASKP1 = 0.0D00
          ENDIF
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              UTRANS(I, J) = (MASKW(I, J, K, BI, BJ) * DYG(I, J, BI, BJ
     > ) *(GM_PSIX(I, J, KP1, BI, BJ) * MASKP1 - GM_PSIX(I, J, K, BI,
     >  BJ)))
            END DO
          END DO
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              DF(I, J) = (DF(I, J) + UTRANS(I, J) * 5.0D-01 *(TRACER(I,
     >  J, K, BI, BJ) + TRACER(I + (-1), J, K, BI, BJ)))
            END DO
          END DO
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE gmredi_ytransport(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  YA, TRACER, TRACERIDENTITY, DF, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use gmredi_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) TRACERIDENTITY
      REAL(w2f__8) DF(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DTDZ(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) MASKP1
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT0 = TRACERIDENTITY +(-1)
      MAX0 = 2
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IGADKEY = ACT0 + ACT1 * MAX0 + MAX1 * ACT2 * MAX0 + MAX2 * MAX1 *
     >  ACT3 * MAX0 + MAX3 * MAX2 * MAX1 * ACT4 * MAX0 + 1
      KKEY = K + IGADKEY * 15 +(-15)
      IF(TRACERIDENTITY .GT. 2) THEN
        WRITE(*, *) 'ph-pass gmredi_ytrans ', 2, TRACERIDENTITY
        WRITE(*, *) 'maxpass seems smaller than tracerIdentity'
      ENDIF
      IF(USEGMREDI) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            DF(I, J) = (DF(I, J) - RECIP_DYC(I, J, BI, BJ) * YA(I, J) *
     >  KVY(I, J, K, BI, BJ) *(TRACER(I, J, K, BI, BJ) - TRACER(I, J +
     >  (-1), K, BI, BJ)))
          END DO
        END DO
        IF(GM_EXTRADIAG) THEN
          KM1 = MAX(K +(-1), 1)
          KP1 = MIN(K + 1, 15)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              DTDZ(I, J) = ((RECIP_DRC(K) * 5.0D-01 *(MASKC(I, J, K, BI
     > , BJ) *(TRACER(I, J, KM1, BI, BJ) - TRACER(I, J, K, BI, BJ)) +
     >  MASKC(I, J + (-1), K, BI, BJ) *(TRACER(I, J + (-1), KM1, BI, BJ
     > ) - TRACER(I, J + (-1), K, BI, BJ))) + RECIP_DRC(KP1) * 5.0D-01
     >  *(MASKC(I, J, KP1, BI, BJ) *(TRACER(I, J, K, BI, BJ) - TRACER(I
     > , J, KP1, BI, BJ)) + MASKC(I, J + (-1), KP1, BI, BJ) *(TRACER(I,
     >  J + (-1), K, BI, BJ) - TRACER(I, J + (-1), KP1, BI, BJ)))) *
     >  5.0D-01)
            END DO
          END DO
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              DF(I, J) = (DF(I, J) - DTDZ(I, J) * YA(I, J) * KVZ(I, J,
     >  K, BI, BJ))
            END DO
          END DO
        ENDIF
        IF((GM_ADVFORM .AND. GM_ADVSEPARATE) .AND.(.NOT.
     >  GM_INMOMASSTRESS)) THEN
          KP1 = MIN(K + 1, 15)
          MASKP1 = 1.0D00
          IF(K .GE. 15) THEN
            MASKP1 = 0.0D00
          ENDIF
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              VTRANS(I, J) = (MASKS(I, J, K, BI, BJ) * DXG(I, J, BI, BJ
     > ) *(GM_PSIY(I, J, KP1, BI, BJ) * MASKP1 - GM_PSIY(I, J, K, BI,
     >  BJ)))
            END DO
          END DO
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              DF(I, J) = (DF(I, J) + VTRANS(I, J) * 5.0D-01 *(TRACER(I,
     >  J, K, BI, BJ) + TRACER(I, J + (-1), K, BI, BJ)))
            END DO
          END DO
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_rtrans(K, BI, BJ, RTRANSU, RTRANSV, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) RTRANSU(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANSV(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(K .GT. 15) THEN
        DO J = -1, 43, 1
          DO I = -1, 93, 1
            RTRANSU(I, J) = 0.0D00
            RTRANSV(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -1, 43, 1
          DO I = -1, 93, 1
            RTRANSU(I, J) = (RHOFACF(K) * DEEPFAC2F(K) *(RA(I, J, BI,
     >  BJ) * WVEL(I, J, K, BI, BJ) + RA(I + (-1), J, BI, BJ) * WVEL(I
     >  + (-1), J, K, BI, BJ)) * 5.0D-01)
            RTRANSV(I, J) = (RHOFACF(K) * DEEPFAC2F(K) *(RA(I, J, BI,
     >  BJ) * WVEL(I, J, K, BI, BJ) + RA(I, J + (-1), BI, BJ) * WVEL(I,
     >  J + (-1), K, BI, BJ)) * 5.0D-01)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_fluxform(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KUP,
     >  KDOWN, KAPPARU, KAPPARV, FVERU, FVERV, GUDISS, GVDISS, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use ffields_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KUP
      INTEGER(w2f__i4) KDOWN
      REAL(w2f__8) KAPPARU(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) KAPPARV(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) FVERU(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) FVERV(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) GUDISS(-2 : 93, -2 : 43)
      REAL(w2f__8) GVDISS(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) AHDUDXFAC
      REAL(w2f__8) AHDUDYFAC
      REAL(w2f__8) AHDVDXFAC
      REAL(w2f__8) AHDVDYFAC
      REAL(w2f__8) ARDUDRFAC
      REAL(w2f__8) ARDVDRFAC
      LOGICAL(w2f__i4) BIHARMONIC
      LOGICAL(w2f__i4) BOTTOMDRAGTERMS
      REAL(w2f__8) CF(-2 : 93, -2 : 43)
      REAL(w2f__8) FMER(-2 : 93, -2 : 43)
      REAL(w2f__8) FUFAC
      REAL(w2f__8) FVFAC
      REAL(w2f__8) FVRDW(-2 : 93, -2 : 43)
      REAL(w2f__8) FVRUP(-2 : 93, -2 : 43)
      REAL(w2f__8) FZON(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) HARMONIC
      REAL(w2f__8) HDIV(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMOMKEY
      INTEGER(w2f__i4) J
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      EXTERNAL mom_calc_hdiv
      EXTERNAL mom_calc_hfacz
      EXTERNAL mom_calc_ke
      EXTERNAL mom_calc_relvort3
      EXTERNAL mom_calc_rtrans
      EXTERNAL mom_calc_strain
      EXTERNAL mom_calc_tension
      EXTERNAL mom_calc_visc
      EXTERNAL mom_u_adv_uu
      EXTERNAL mom_u_adv_vu
      EXTERNAL mom_u_adv_wu
      EXTERNAL mom_u_bottomdrag
      EXTERNAL mom_u_coriolis
      EXTERNAL mom_u_coriolis_nh
      EXTERNAL mom_u_del2u
      EXTERNAL mom_u_metric_cylinder
      EXTERNAL mom_u_metric_nh
      EXTERNAL mom_u_metric_sphere
      EXTERNAL mom_u_rviscflux
      EXTERNAL mom_u_sidedrag
      EXTERNAL mom_u_xviscflux
      EXTERNAL mom_u_yviscflux
      EXTERNAL mom_v_adv_uv
      EXTERNAL mom_v_adv_vv
      EXTERNAL mom_v_adv_wv
      EXTERNAL mom_v_bottomdrag
      EXTERNAL mom_v_coriolis
      EXTERNAL mom_v_coriolis_nh
      EXTERNAL mom_v_del2v
      EXTERNAL mom_v_metric_cylinder
      EXTERNAL mom_v_metric_nh
      EXTERNAL mom_v_metric_sphere
      EXTERNAL mom_v_rviscflux
      EXTERNAL mom_v_sidedrag
      EXTERNAL mom_v_xviscflux
      EXTERNAL mom_v_yviscflux
      REAL(w2f__8) MT(-2 : 93, -2 : 43)
      REAL(w2f__8) MTFACU
      REAL(w2f__8) MTFACV
      REAL(w2f__8) MTNHFACU
      REAL(w2f__8) MTNHFACV
      REAL(w2f__8) RTRANSU(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANSV(-2 : 93, -2 : 43)
      REAL(w2f__8) RVELDUDRFAC
      REAL(w2f__8) RVELDVDRFAC
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) SIDEMASKFAC
      REAL(w2f__8) STRAIN(-2 : 93, -2 : 43)
      REAL(w2f__8) TENSION(-2 : 93, -2 : 43)
      REAL(w2f__8) UDUDXFAC
      REAL(w2f__8) UDVDXFAC
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) USEVARIABLEVISCOSITY
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) V4F(-2 : 93, -2 : 43)
      REAL(w2f__8) VDUDYFAC
      REAL(w2f__8) VDVDYFAC
      REAL(w2f__8) VF(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT0 = K +(-1)
      MAX0 = 15
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IMOMKEY = ACT0 + ACT1 * MAX0 + MAX1 * ACT2 * MAX0 + MAX2 * MAX1 *
     >  ACT3 * MAX0 + MAX3 * MAX2 * MAX1 * ACT4 * MAX0 + 1
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          VF(I, J) = 0.0D00
          V4F(I, J) = 0.0D00
          CF(I, J) = 0.0D00
          MT(I, J) = 0.0D00
          FZON(I, J) = 0.0D00
          FMER(I, J) = 0.0D00
          FVRUP(I, J) = 0.0D00
          FVRDW(I, J) = 0.0D00
          RTRANSU(I, J) = 0.0D00
          RTRANSV(I, J) = 0.0D00
          HDIV(I, J) = 0.0D00
          VORT3(I, J) = 0.0D00
          STRAIN(I, J) = 0.0D00
          TENSION(I, J) = 0.0D00
          GUDISS(I, J) = 0.0D00
          GVDISS(I, J) = 0.0D00
        END DO
      END DO
      UDUDXFAC = AFFACMOM
      AHDUDXFAC = VFFACMOM
      VDUDYFAC = AFFACMOM
      AHDUDYFAC = VFFACMOM
      RVELDUDRFAC = AFFACMOM
      ARDUDRFAC = VFFACMOM
      MTFACU = MTFACMOM
      MTNHFACU = 1.0D00
      FUFAC = CFFACMOM
      UDVDXFAC = AFFACMOM
      AHDVDXFAC = VFFACMOM
      VDVDYFAC = AFFACMOM
      AHDVDYFAC = VFFACMOM
      RVELDVDRFAC = AFFACMOM
      ARDVDRFAC = VFFACMOM
      MTFACV = MTFACMOM
      MTNHFACV = 1.0D00
      FVFAC = CFFACMOM
      IF(IMPLICITVISCOSITY) THEN
        ARDUDRFAC = 0.0D00
        ARDVDRFAC = 0.0D00
      ENDIF
      IF(NO_SLIP_SIDES) THEN
        SIDEMASKFAC = SIDEDRAGFACTOR
      ELSE
        SIDEMASKFAC = 0.0D00
      ENDIF
      IF((BOTTOMDRAGLINEAR .ne. 0.0D00) .OR.(NO_SLIP_BOTTOM .OR.(
     > BOTTOMDRAGQUADRATIC .ne. 0.0D00))) THEN
        BOTTOMDRAGTERMS = .TRUE.
      ELSE
        BOTTOMDRAGTERMS = .FALSE.
      ENDIF
      CALL mom_calc_hfacz(BI, BJ, K, HFACZ, R_HFACZ, MYTHID)
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          XA(I, J) = (HFACW(I, J, K, BI, BJ) * DRF(K) * DEEPFACC(K) *
     >  DYG(I, J, BI, BJ))
          YA(I, J) = (HFACS(I, J, K, BI, BJ) * DRF(K) * DEEPFACC(K) *
     >  DXG(I, J, BI, BJ))
        END DO
      END DO
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          UFLD(I, J) = UVEL(I, J, K, BI, BJ)
          VFLD(I, J) = VVEL(I, J, K, BI, BJ)
        END DO
      END DO
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          UTRANS(I, J) = (RHOFACC(K) * UFLD(I, J) * XA(I, J))
          VTRANS(I, J) = (RHOFACC(K) * VFLD(I, J) * YA(I, J))
        END DO
      END DO
      CALL mom_calc_ke(BI, BJ, K, (2), UFLD, VFLD, KE, MYTHID)
      IF(MOMVISCOSITY) THEN
        CALL mom_calc_hdiv(BI, BJ, K, (2), UFLD, VFLD, HDIV, MYTHID)
        CALL mom_calc_relvort3(BI, BJ, K, UFLD, VFLD, HFACZ, VORT3,
     >  MYTHID)
        CALL mom_calc_tension(BI, BJ, K, UFLD, VFLD, TENSION, MYTHID)
        CALL mom_calc_strain(BI, BJ, K, UFLD, VFLD, HFACZ, STRAIN,
     >  MYTHID)
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            IF(HFACZ(I, J) .eq. 0.0D00) THEN
              VORT3(I, J) = (VORT3(I, J) * SIDEMASKFAC)
              STRAIN(I, J) = (STRAIN(I, J) * SIDEMASKFAC)
            ENDIF
          END DO
        END DO
      ENDIF
      IF((K .eq. 1) .AND. MOMADVECTION) THEN
        CALL mom_calc_rtrans(K, BI, BJ, RTRANSU, RTRANSV, MYTIME,
     >  MYITER, MYTHID)
        CALL mom_u_adv_wu(BI, BJ, K, UVEL, WVEL, RTRANSU, FVERU((-2), (
     > -2), KUP), MYTHID)
        CALL mom_v_adv_wv(BI, BJ, K, VVEL, WVEL, RTRANSV, FVERV((-2), (
     > -2), KUP), MYTHID)
      ENDIF
      IF(MOMADVECTION) THEN
        CALL mom_calc_rtrans((K + 1), BI, BJ, RTRANSU, RTRANSV, MYTIME,
     >  MYITER, MYTHID)
      ENDIF
      IF(MOMVISCOSITY) THEN
        CALL mom_calc_visc(BI, BJ, K, VISCAH_Z, VISCAH_D, VISCA4_Z,
     >  VISCA4_D, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, HDIV,
     >  VORT3, TENSION, STRAIN, KE, HFACZ, MYTHID)
      ENDIF
      IF(MOMADVECTION) THEN
        CALL mom_u_adv_uu(BI, BJ, K, UTRANS, UFLD, FZON, MYTHID)
        CALL mom_u_adv_vu(BI, BJ, K, VTRANS, UFLD, FMER, MYTHID)
        CALL mom_u_adv_wu(BI, BJ, (K + 1), UVEL, WVEL, RTRANSU, FVERU((
     > -2), (-2), KDOWN), MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (-(RECIP_RHOFACC(K) * RECIP_DEEPFAC2C
     > (K) * RECIP_RAW(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACW(I, J,
     >  K, BI, BJ) *(UDUDXFAC *(FZON(I, J) - FZON(I + (-1), J)) +
     >  VDUDYFAC *(FMER(I, J + 1) - FMER(I, J)) + RVELDUDRFAC * RKSIGN
     >  *(FVERU(I, J, KDOWN) - FVERU(I, J, KUP)))))
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            GU(I, J, K, BI, BJ) = 0.0D00
          END DO
        END DO
      ENDIF
      IF(MOMVISCOSITY) THEN
        IF(BIHARMONIC) THEN
          CALL mom_u_del2u(BI, BJ, K, UFLD, HFACZ, V4F, MYTHID)
        ENDIF
        CALL mom_u_xviscflux(BI, BJ, K, UFLD, V4F, FZON, VISCAH_D,
     >  VISCA4_D, MYTHID)
        CALL mom_u_yviscflux(BI, BJ, K, UFLD, V4F, HFACZ, FMER,
     >  VISCAH_Z, VISCA4_Z, MYTHID)
        IF(.NOT. IMPLICITVISCOSITY) THEN
          CALL mom_u_rviscflux(BI, BJ, K, UVEL, KAPPARU, FVRUP, MYTHID)
          CALL mom_u_rviscflux(BI, BJ, (K + 1), UVEL, KAPPARU, FVRDW,
     >  MYTHID)
        ENDIF
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GUDISS(I, J) = (-(RECIP_DEEPFAC2C(K) * RECIP_RAW(I, J, BI,
     >  BJ) * RECIP_DRF(K) * RECIP_HFACW(I, J, K, BI, BJ) *(AHDUDXFAC *
     > (FZON(I, J) - FZON(I + (-1), J)) + AHDUDYFAC *(FMER(I, J + 1) -
     >  FMER(I, J)) + RECIP_RHOFACC(K) * ARDUDRFAC * RKSIGN *(FVRDW(I,
     >  J) - FVRUP(I, J)))))
          END DO
        END DO
        IF(NO_SLIP_SIDES) THEN
          CALL mom_u_sidedrag(BI, BJ, K, UFLD, V4F, HFACZ, VISCAH_Z,
     >  VISCA4_Z, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, VF,
     >  MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GUDISS(I, J) = (GUDISS(I, J) + VF(I, J))
            END DO
          END DO
        ENDIF
        IF(BOTTOMDRAGTERMS) THEN
          CALL mom_u_bottomdrag(BI, BJ, K, UFLD, KE, KAPPARU, VF,
     >  MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GUDISS(I, J) = (GUDISS(I, J) + VF(I, J))
            END DO
          END DO
        ENDIF
      ENDIF
      IF(USENHMTERMS) THEN
        CALL mom_u_metric_nh(BI, BJ, K, UFLD, WVEL, MT, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) + MT(I, J) *
     >  MTNHFACU)
          END DO
        END DO
      ENDIF
      IF(METRICTERMS .AND. USINGSPHERICALPOLARGRID) THEN
        CALL mom_u_metric_sphere(BI, BJ, K, UFLD, VFLD, MT, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) + MT(I, J) *
     >  MTFACU)
          END DO
        END DO
      ENDIF
      IF(METRICTERMS .AND. USINGCYLINDRICALGRID) THEN
        CALL mom_u_metric_cylinder(BI, BJ, K, UFLD, VFLD, MT, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) + MT(I, J) *
     >  MTFACU)
          END DO
        END DO
      ENDIF
      IF(MOMADVECTION) THEN
        CALL mom_v_adv_uv(BI, BJ, K, UTRANS, VFLD, FZON, MYTHID)
        CALL mom_v_adv_vv(BI, BJ, K, VTRANS, VFLD, FMER, MYTHID)
        CALL mom_v_adv_wv(BI, BJ, (K + 1), VVEL, WVEL, RTRANSV, FVERV((
     > -2), (-2), KDOWN), MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (-(RECIP_RHOFACC(K) * RECIP_DEEPFAC2C
     > (K) * RECIP_RAS(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACS(I, J,
     >  K, BI, BJ) *(UDVDXFAC *(FZON(I + 1, J) - FZON(I, J)) + VDVDYFAC
     >  *(FMER(I, J) - FMER(I, J + (-1))) + RVELDVDRFAC * RKSIGN *(
     > FVERV(I, J, KDOWN) - FVERV(I, J, KUP)))))
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            GV(I, J, K, BI, BJ) = 0.0D00
          END DO
        END DO
      ENDIF
      IF(MOMVISCOSITY) THEN
        IF(BIHARMONIC) THEN
          CALL mom_v_del2v(BI, BJ, K, VFLD, HFACZ, V4F, MYTHID)
        ENDIF
        CALL mom_v_xviscflux(BI, BJ, K, VFLD, V4F, HFACZ, FZON,
     >  VISCAH_Z, VISCA4_Z, MYTHID)
        CALL mom_v_yviscflux(BI, BJ, K, VFLD, V4F, FMER, VISCAH_D,
     >  VISCA4_D, MYTHID)
        IF(.NOT. IMPLICITVISCOSITY) THEN
          CALL mom_v_rviscflux(BI, BJ, K, VVEL, KAPPARV, FVRUP, MYTHID)
          CALL mom_v_rviscflux(BI, BJ, (K + 1), VVEL, KAPPARV, FVRDW,
     >  MYTHID)
        ENDIF
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GVDISS(I, J) = (-(RECIP_DEEPFAC2C(K) * RECIP_RAS(I, J, BI,
     >  BJ) * RECIP_DRF(K) * RECIP_HFACS(I, J, K, BI, BJ) *(AHDVDXFAC *
     > (FZON(I + 1, J) - FZON(I, J)) + AHDVDYFAC *(FMER(I, J) - FMER(I,
     >  J + (-1))) + RECIP_RHOFACC(K) * ARDVDRFAC * RKSIGN *(FVRDW(I, J
     > ) - FVRUP(I, J)))))
          END DO
        END DO
        IF(NO_SLIP_SIDES) THEN
          CALL mom_v_sidedrag(BI, BJ, K, VFLD, V4F, HFACZ, VISCAH_Z,
     >  VISCA4_Z, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, VF,
     >  MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GVDISS(I, J) = (GVDISS(I, J) + VF(I, J))
            END DO
          END DO
        ENDIF
        IF(BOTTOMDRAGTERMS) THEN
          CALL mom_v_bottomdrag(BI, BJ, K, VFLD, KE, KAPPARV, VF,
     >  MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GVDISS(I, J) = (GVDISS(I, J) + VF(I, J))
            END DO
          END DO
        ENDIF
      ENDIF
      IF(USENHMTERMS) THEN
        CALL mom_v_metric_nh(BI, BJ, K, VFLD, WVEL, MT, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) + MT(I, J) *
     >  MTNHFACV)
          END DO
        END DO
      ENDIF
      IF(METRICTERMS .AND. USINGSPHERICALPOLARGRID) THEN
        CALL mom_v_metric_sphere(BI, BJ, K, UFLD, MT, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) + MT(I, J) *
     >  MTFACV)
          END DO
        END DO
      ENDIF
      IF(METRICTERMS .AND. USINGCYLINDRICALGRID) THEN
        CALL mom_v_metric_cylinder(BI, BJ, K, UFLD, VFLD, MT, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) + MT(I, J) *
     >  MTFACV)
          END DO
        END DO
      ENDIF
      IF(.NOT. USECDSCHEME) THEN
        CALL mom_u_coriolis(BI, BJ, K, VFLD, CF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) + CF(I, J) *
     >  FUFAC)
          END DO
        END DO
        CALL mom_v_coriolis(BI, BJ, K, UFLD, CF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) + CF(I, J) *
     >  FVFAC)
          END DO
        END DO
      ENDIF
      IF(USE3DCORIOLIS) THEN
        CALL mom_u_coriolis_nh(BI, BJ, K, WVEL, CF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) + CF(I, J) *
     >  FUFAC)
          END DO
        END DO
        IF(USINGCURVILINEARGRID) THEN
          CALL mom_v_coriolis_nh(BI, BJ, K, WVEL, CF, MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) + CF(I, J) *
     >  FVFAC)
            END DO
          END DO
        ENDIF
      ENDIF
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) * MASKW(I, J, K,
     >  BI, BJ))
          GUDISS(I, J) = (GUDISS(I, J) * MASKW(I, J, K, BI, BJ))
          GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) * MASKS(I, J, K,
     >  BI, BJ))
          GVDISS(I, J) = (GVDISS(I, J) * MASKS(I, J, K, BI, BJ))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_adv_uu(BI, BJ, K, UTRANS, UFLD, ADVECTFLUXUU,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) ADVECTFLUXUU(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 42, 1
        DO I = -2, 92, 1
          ADVECTFLUXUU(I, J) = ((UTRANS(I, J) + UTRANS(I + 1, J)) *
     >  2.5D-01 *(UFLD(I, J) + UFLD(I + 1, J)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_adv_vu(BI, BJ, K, VTRANS, UFLD, ADVECTFLUXVU,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) ADVECTFLUXVU(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -1, 93, 1
          ADVECTFLUXVU(I, J) = ((VTRANS(I, J) + VTRANS(I + (-1), J)) *
     >  2.5D-01 *(UFLD(I, J) + UFLD(I, J + (-1))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_adv_wu(BI, BJ, K, UFLD, WFLD, RTRANS,
     >  ADVECTIVEFLUXWU, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) ADVECTIVEFLUXWU(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(USINGPCOORDS .AND.((K .eq. 16) .AND. USEREALFRESHWATERFLUX))
     >  THEN
        DO J = -1, 43, 1
          DO I = -1, 93, 1
            ADVECTIVEFLUXWU(I, J) = (RTRANS(I, J) * UFLD(I, J, K + (-1)
     > , BI, BJ))
          END DO
        END DO
      ELSE
        IF((K .GT. 15) .OR.((K .eq. 1) .AND. RIGIDLID)) THEN
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ADVECTIVEFLUXWU(I, J) = 0.0D00
            END DO
          END DO
        ELSE
          IF(K .eq. 1) THEN
            DO J = -1, 43, 1
              DO I = -1, 93, 1
                ADVECTIVEFLUXWU(I, J) = (RTRANS(I, J) * UFLD(I, J, K,
     >  BI, BJ))
              END DO
            END DO
          ELSE
            DO J = -1, 43, 1
              DO I = -1, 93, 1
                ADVECTIVEFLUXWU(I, J) = (RTRANS(I, J) * 5.0D-01 *(UFLD(
     > I, J, K, BI, BJ) + UFLD(I, J, K + (-1), BI, BJ)))
              END DO
            END DO
            IF((SELECT_RSTAR .eq. 0) .AND.(.NOT. RIGIDLID)) THEN
              DO J = -1, 43, 1
                DO I = -1, 93, 1
                  ADVECTIVEFLUXWU(I, J) = (ADVECTIVEFLUXWU(I, J) + UFLD
     > (I, J, K, BI, BJ) * RHOFACF(K) * DEEPFAC2F(K) *(RA(I, J, BI, BJ)
     >  * WFLD(I, J, K, BI, BJ) *(MASKC(I, J, K, BI, BJ) - MASKC(I, J,
     >  K + (-1), BI, BJ)) + RA(I + (-1), J, BI, BJ) * WFLD(I + (-1), J
     > , K, BI, BJ) *(MASKC(I + (-1), J, K, BI, BJ) - MASKC(I + (-1), J
     > , K + (-1), BI, BJ))) * 2.5D-01)
                END DO
              END DO
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_coriolis(BI, BJ, K, VFLD, UCORIOLISTERM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) ONE
      PARAMETER ( ONE = 1.0D00)
C
C     **** Statements ****
C
      IF(USEENERGYCONSERVINGCORIOLIS) THEN
        DO J = -2, 42, 1
          DO I = -1, 93, 1
            UCORIOLISTERM(I, J) = ((FCORI(I, J, BI, BJ) * 5.0D-01 *(
     > VFLD(I, J) + VFLD(I, J + 1)) + FCORI(I + (-1), J, BI, BJ) *
     >  5.0D-01 *(VFLD(I + (-1), J) + VFLD(I + (-1), J + 1))) * 5.0D-01
     > )
          END DO
        END DO
      ELSE
        DO J = -2, 42, 1
          DO I = -1, 93, 1
            UCORIOLISTERM(I, J) = ((FCORI(I, J, BI, BJ) + FCORI(I + (-1
     > ), J, BI, BJ)) * 5.0D-01 * 2.5D-01 *(VFLD(I + (-1), J + 1) +
     >  VFLD(I + (-1), J) + VFLD(I, J) + VFLD(I, J + 1)))
          END DO
        END DO
      ENDIF
      IF(USEJAMARTWETPOINTS) THEN
        DO J = -2, 42, 1
          DO I = -1, 93, 1
            UCORIOLISTERM(I, J) = ((UCORIOLISTERM(I, J) * 4.0D00) / MAX
     > (MASKS(I + (-1), J + 1, K, BI, BJ) + MASKS(I + (-1), J, K, BI,
     >  BJ) + MASKS(I, J, K, BI, BJ) + MASKS(I, J + 1, K, BI, BJ),
     >  1.0D00))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_del2u(BI, BJ, K, UFLD, HFACZ, DEL2U, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2U(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) FMER(-2 : 93, -2 : 43)
      REAL(w2f__8) FZON(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZCLOSEDN
      REAL(w2f__8) HFACZCLOSEDS
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 42, 1
        DO I = -2, 92, 1
          FZON(I, J) = (RECIP_DXF(I, J, BI, BJ) * DYF(I, J, BI, BJ) *
     >  DRF(K) * HFACC(I, J, K, BI, BJ) *(UFLD(I + 1, J) - UFLD(I, J)))
        END DO
      END DO
      DO J = -1, 43, 1
        DO I = -1, 92, 1
          FMER(I, J) = (RECIP_DYU(I, J, BI, BJ) * DXV(I, J, BI, BJ) *
     >  DRF(K) * HFACZ(I, J) *(UFLD(I, J) - UFLD(I, J + (-1))))
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          DEL2U(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DEEPFAC2C(K) *
     >  RECIP_RAW(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACW(I, J, K,
     >  BI, BJ) *(FMER(I, J + 1) + FZON(I, J) - FZON(I + (-1), J) -
     >  FMER(I, J)))
        END DO
      END DO
      IF(NO_SLIP_SIDES) THEN
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            HFACZCLOSEDS = HFACW(I, J, K, BI, BJ) - HFACZ(I, J)
            HFACZCLOSEDN = HFACW(I, J, K, BI, BJ) - HFACZ(I, J + 1)
            DEL2U(I, J) = (DEL2U(I, J) - MASKW(I, J, K, BI, BJ) * UFLD(
     > I, J) * DRF(K) * RECIP_DEEPFAC2C(K) * RECIP_RAW(I, J, BI, BJ) *
     >  RECIP_DRF(K) * RECIP_HFACW(I, J, K, BI, BJ) *(RECIP_DYU(I, J,
     >  BI, BJ) * DXV(I, J, BI, BJ) * HFACZCLOSEDS + RECIP_DYU(I, J + 1
     > , BI, BJ) * DXV(I, J + 1, BI, BJ) * HFACZCLOSEDN) * 2.0D00)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_metric_cylinder(BI, BJ, K, UFLD, VFLD,
     >  UMETRICTERMS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UMETRICTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RADIUS
C
C     **** Statements ****
C
      DO J = -2, 42, 1
        DO I = -1, 93, 1
          RADIUS = (YG(I, J, BI, BJ) + YG(I, J + 1, BI, BJ)) * 5.0D-01
          IF(RADIUS .GT. 0.0D00) THEN
            UMETRICTERMS(I, J) = ((UFLD(I, J) * 2.5D-01 *(VFLD(I + (-1)
     > , J + 1) + VFLD(I, J + 1) + VFLD(I, J) + VFLD(I + (-1), J))) /
     >  RADIUS)
          ELSE
            UMETRICTERMS(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_metric_sphere(BI, BJ, K, UFLD, VFLD,
     >  UMETRICTERMS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UMETRICTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 42, 1
        DO I = -1, 93, 1
          UMETRICTERMS(I, J) = (TANPHIATU(I, J, BI, BJ) *
     >  RECIP_DEEPFACC(K) * UFLD(I, J) * RECIP_RSPHERE * 2.5D-01 *(VFLD
     > (I + (-1), J + 1) + VFLD(I, J + 1) + VFLD(I, J) + VFLD(I + (-1),
     >  J)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_xviscflux(BI, BJ, K, UFLD, DEL2U, XVISCFLUXU,
     >  VISCAH_D, VISCA4_D, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2U(-2 : 93, -2 : 43)
      REAL(w2f__8) XVISCFLUXU(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_D(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 42, 1
        DO I = -2, 92, 1
          XVISCFLUXU(I, J) = (RECIP_DXF(I, J, BI, BJ) * HFACC(I, J, K,
     >  BI, BJ) * DRF(K) * DYF(I, J, BI, BJ) *(COSFACU(J, BI, BJ) *
     >  VISCA4_D(I, J) *(DEL2U(I + 1, J) - DEL2U(I, J)) - COSFACU(J, BI
     > , BJ) * VISCAH_D(I, J) *(UFLD(I + 1, J) - UFLD(I, J))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_yviscflux(BI, BJ, K, UFLD, DEL2U, HFACZ,
     >  YVISCFLUXU, VISCAH_Z, VISCA4_Z, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2U(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) YVISCFLUXU(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          YVISCFLUXU(I, J) = (RECIP_DYU(I, J, BI, BJ) * HFACZ(I, J) *
     >  DRF(K) * DXV(I, J, BI, BJ) *(VISCA4_Z(I, J) *(DEL2U(I, J) -
     >  DEL2U(I, J + (-1))) - VISCAH_Z(I, J) *(UFLD(I, J) - UFLD(I, J +
     >  (-1)))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_adv_uv(BI, BJ, K, UTRANS, VFLD, ADVECTFLUXUV,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) ADVECTFLUXUV(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -1, 93, 1
          ADVECTFLUXUV(I, J) = ((UTRANS(I, J) + UTRANS(I, J + (-1))) *
     >  2.5D-01 *(VFLD(I, J) + VFLD(I + (-1), J)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_adv_vv(BI, BJ, K, VTRANS, VFLD, ADVECTFLUXVV,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) ADVECTFLUXVV(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 42, 1
        DO I = -2, 92, 1
          ADVECTFLUXVV(I, J) = ((VTRANS(I, J) + VTRANS(I, J + 1)) *
     >  2.5D-01 *(VFLD(I, J) + VFLD(I, J + 1)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_adv_wv(BI, BJ, K, VFLD, WFLD, RTRANS,
     >  ADVECTIVEFLUXWV, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) ADVECTIVEFLUXWV(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(USINGPCOORDS .AND.((K .eq. 16) .AND. USEREALFRESHWATERFLUX))
     >  THEN
        DO J = -1, 43, 1
          DO I = -1, 93, 1
            ADVECTIVEFLUXWV(I, J) = (RTRANS(I, J) * VFLD(I, J, K + (-1)
     > , BI, BJ))
          END DO
        END DO
      ELSE
        IF((K .GT. 15) .OR.((K .eq. 1) .AND. RIGIDLID)) THEN
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ADVECTIVEFLUXWV(I, J) = 0.0D00
            END DO
          END DO
        ELSE
          IF(K .eq. 1) THEN
            DO J = -1, 43, 1
              DO I = -1, 93, 1
                ADVECTIVEFLUXWV(I, J) = (RTRANS(I, J) * VFLD(I, J, K,
     >  BI, BJ))
              END DO
            END DO
          ELSE
            DO J = -1, 43, 1
              DO I = -1, 93, 1
                ADVECTIVEFLUXWV(I, J) = (RTRANS(I, J) * 5.0D-01 *(VFLD(
     > I, J, K, BI, BJ) + VFLD(I, J, K + (-1), BI, BJ)))
              END DO
            END DO
            IF((SELECT_RSTAR .eq. 0) .AND.(.NOT. RIGIDLID)) THEN
              DO J = -1, 43, 1
                DO I = -1, 93, 1
                  ADVECTIVEFLUXWV(I, J) = (ADVECTIVEFLUXWV(I, J) + VFLD
     > (I, J, K, BI, BJ) * RHOFACF(K) * DEEPFAC2F(K) *(RA(I, J, BI, BJ)
     >  * WFLD(I, J, K, BI, BJ) *(MASKC(I, J, K, BI, BJ) - MASKC(I, J,
     >  K + (-1), BI, BJ)) + RA(I, J + (-1), BI, BJ) * WFLD(I, J + (-1)
     > , K, BI, BJ) *(MASKC(I, J + (-1), K, BI, BJ) - MASKC(I, J + (-1)
     > , K + (-1), BI, BJ))) * 2.5D-01)
                END DO
              END DO
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_coriolis(BI, BJ, K, UFLD, VCORIOLISTERM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) ONE
      PARAMETER ( ONE = 1.0D00)
C
C     **** Statements ****
C
      IF(USEENERGYCONSERVINGCORIOLIS) THEN
        DO J = -1, 43, 1
          DO I = -2, 92, 1
            VCORIOLISTERM(I, J) = ((FCORI(I, J, BI, BJ) * 5.0D-01 *(
     > UFLD(I, J) + UFLD(I + 1, J)) + FCORI(I, J + (-1), BI, BJ) *
     >  5.0D-01 *(UFLD(I, J + (-1)) + UFLD(I + 1, J + (-1)))) *(
     > -5.0D-01))
          END DO
        END DO
      ELSE
        DO J = -1, 43, 1
          DO I = -2, 92, 1
            VCORIOLISTERM(I, J) = (-((FCORI(I, J, BI, BJ) + FCORI(I, J
     >  + (-1), BI, BJ)) * 5.0D-01 * 2.5D-01 *(UFLD(I + 1, J + (-1)) +
     >  UFLD(I, J + (-1)) + UFLD(I, J) + UFLD(I + 1, J))))
          END DO
        END DO
      ENDIF
      IF(USEJAMARTWETPOINTS) THEN
        DO J = -1, 43, 1
          DO I = -2, 92, 1
            VCORIOLISTERM(I, J) = ((VCORIOLISTERM(I, J) * 4.0D00) / MAX
     > (MASKW(I + 1, J + (-1), K, BI, BJ) + MASKW(I, J + (-1), K, BI,
     >  BJ) + MASKW(I, J, K, BI, BJ) + MASKW(I + 1, J, K, BI, BJ),
     >  1.0D00))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_del2v(BI, BJ, K, VFLD, HFACZ, DEL2V, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2V(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) FMER(-2 : 93, -2 : 43)
      REAL(w2f__8) FZON(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZCLOSEDE
      REAL(w2f__8) HFACZCLOSEDW
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 42, 1
        DO I = -1, 93, 1
          FZON(I, J) = (RECIP_DXV(I, J, BI, BJ) * DYU(I, J, BI, BJ) *
     >  DRF(K) * HFACZ(I, J) *(VFLD(I, J) - VFLD(I + (-1), J)))
        END DO
      END DO
      DO J = -2, 42, 1
        DO I = -1, 92, 1
          FMER(I, J) = (RECIP_DYF(I, J, BI, BJ) * DXF(I, J, BI, BJ) *
     >  DRF(K) * HFACC(I, J, K, BI, BJ) *(VFLD(I, J + 1) - VFLD(I, J)))
        END DO
      END DO
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          DEL2V(I, J) = (MASKS(I, J, K, BI, BJ) * RECIP_DEEPFAC2C(K) *
     >  RECIP_RAS(I, J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACS(I, J, K,
     >  BI, BJ) *(FMER(I, J) + FZON(I + 1, J) - FZON(I, J) - FMER(I, J
     >  + (-1))))
        END DO
      END DO
      IF(NO_SLIP_SIDES) THEN
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            HFACZCLOSEDW = HFACS(I, J, K, BI, BJ) - HFACZ(I, J)
            HFACZCLOSEDE = HFACS(I, J, K, BI, BJ) - HFACZ(I + 1, J)
            DEL2V(I, J) = (DEL2V(I, J) - MASKS(I, J, K, BI, BJ) * VFLD(
     > I, J) * DRF(K) * RECIP_DEEPFAC2C(K) * RECIP_RAS(I, J, BI, BJ) *
     >  RECIP_DRF(K) * RECIP_HFACS(I, J, K, BI, BJ) *(RECIP_DXV(I, J,
     >  BI, BJ) * DYU(I, J, BI, BJ) * HFACZCLOSEDW + RECIP_DXV(I + 1, J
     > , BI, BJ) * DYU(I + 1, J, BI, BJ) * HFACZCLOSEDE) * 2.0D00)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_metric_cylinder(BI, BJ, K, UFLD, VFLD,
     >  VMETRICTERMS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VMETRICTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RADIUS
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -2, 92, 1
          RADIUS = (YG(I, J, BI, BJ) + YG(I + 1, J, BI, BJ)) * 5.0D-01
          IF(RADIUS .GT. 0.0D00) THEN
            VMETRICTERMS(I, J) = (-(((UFLD(I + 1, J + (-1)) + UFLD(I, J
     >  + (-1)) + UFLD(I, J) + UFLD(I + 1, J)) * 2.5D-01 * 2.5D-01 *(
     > UFLD(I + 1, J + (-1)) + UFLD(I, J + (-1)) + UFLD(I, J) + UFLD(I
     >  + 1, J))) / RADIUS))
          ELSE
            VMETRICTERMS(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_metric_sphere(BI, BJ, K, UFLD, VMETRICTERMS,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VMETRICTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -2, 92, 1
          VMETRICTERMS(I, J) = (-(TANPHIATV(I, J, BI, BJ) *
     >  RECIP_DEEPFACC(K) * RECIP_RSPHERE * 2.5D-01 *(UFLD(I + 1, J + (
     > -1)) + UFLD(I, J + (-1)) + UFLD(I, J) + UFLD(I + 1, J)) *
     >  2.5D-01 *(UFLD(I + 1, J + (-1)) + UFLD(I, J + (-1)) + UFLD(I, J
     > ) + UFLD(I + 1, J))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_xviscflux(BI, BJ, K, VFLD, DEL2V, HFACZ,
     >  XVISCFLUXV, VISCAH_Z, VISCA4_Z, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2V(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) XVISCFLUXV(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          XVISCFLUXV(I, J) = (RECIP_DXV(I, J, BI, BJ) * HFACZ(I, J) *
     >  DRF(K) * DYU(I, J, BI, BJ) *(COSFACV(J, BI, BJ) * VISCA4_Z(I, J
     > ) *(DEL2V(I, J) - DEL2V(I + (-1), J)) - COSFACV(J, BI, BJ) *
     >  VISCAH_Z(I, J) *(VFLD(I, J) - VFLD(I + (-1), J))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_yviscflux(BI, BJ, K, VFLD, DEL2V, YVISCFLUXV,
     >  VISCAH_D, VISCA4_D, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2V(-2 : 93, -2 : 43)
      REAL(w2f__8) YVISCFLUXV(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_D(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 42, 1
        DO I = -2, 92, 1
          YVISCFLUXV(I, J) = (RECIP_DYF(I, J, BI, BJ) * HFACC(I, J, K,
     >  BI, BJ) * DRF(K) * DXF(I, J, BI, BJ) *(VISCA4_D(I, J) *(DEL2V(I
     > , J + 1) - DEL2V(I, J)) - VISCAH_D(I, J) *(VFLD(I, J + 1) - VFLD
     > (I, J))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vecinv(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KUP,
     >  KDOWN, KAPPARU, KAPPARV, FVERU, FVERV, GUDISS, GVDISS, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KUP
      INTEGER(w2f__i4) KDOWN
      REAL(w2f__8) KAPPARU(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) KAPPARV(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) FVERU(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) FVERV(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) GUDISS(-2 : 93, -2 : 43)
      REAL(w2f__8) GVDISS(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) ARDUDRFAC
      REAL(w2f__8) ARDVDRFAC
      LOGICAL(w2f__i4) BIHARMONIC
      LOGICAL(w2f__i4) BOTTOMDRAGTERMS
      EXTERNAL debug_cs_corner_uv
      REAL(w2f__8) DEL2U(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2V(-2 : 93, -2 : 43)
      EXTERNAL different_multiple
      LOGICAL(w2f__i4) different_multiple
      REAL(w2f__8) DSTAR(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) HARMONIC
      REAL(w2f__8) HDIV(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMOMKEY
      INTEGER(w2f__i4) J
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      EXTERNAL mom_calc_absvort3
      EXTERNAL mom_calc_hdiv
      EXTERNAL mom_calc_hfacz
      EXTERNAL mom_calc_ke
      EXTERNAL mom_calc_relvort3
      EXTERNAL mom_calc_strain
      EXTERNAL mom_calc_tension
      EXTERNAL mom_calc_visc
      EXTERNAL mom_hdissip
      EXTERNAL mom_u_bottomdrag
      EXTERNAL mom_u_coriolis_nh
      EXTERNAL mom_u_metric_nh
      EXTERNAL mom_u_rviscflux
      EXTERNAL mom_u_sidedrag
      EXTERNAL mom_vi_coriolis
      EXTERNAL mom_vi_del2uv
      EXTERNAL mom_vi_hdissip
      EXTERNAL mom_vi_u_coriolis
      EXTERNAL mom_vi_u_coriolis_c4
      EXTERNAL mom_vi_u_grad_ke
      EXTERNAL mom_vi_u_vertshear
      EXTERNAL mom_vi_v_coriolis
      EXTERNAL mom_vi_v_coriolis_c4
      EXTERNAL mom_vi_v_grad_ke
      EXTERNAL mom_vi_v_vertshear
      EXTERNAL mom_v_bottomdrag
      EXTERNAL mom_v_coriolis_nh
      EXTERNAL mom_v_metric_nh
      EXTERNAL mom_v_rviscflux
      EXTERNAL mom_v_sidedrag
      REAL(w2f__8) OMEGA3(-2 : 93, -2 : 43)
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) SIDEMASKFAC
      REAL(w2f__8) STRAIN(-2 : 93, -2 : 43)
      REAL(w2f__8) TENSION(-2 : 93, -2 : 43)
      REAL(w2f__8) UCF(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) USEVARIABLEVISCOSITY
      REAL(w2f__8) VCF(-2 : 93, -2 : 43)
      REAL(w2f__8) VF(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      REAL(w2f__8) VRF(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) WRITEDIAG
      EXTERNAL write_local_rl
      REAL(w2f__8) ZSTAR(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT0 = K +(-1)
      MAX0 = 15
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IMOMKEY = ACT0 + ACT1 * MAX0 + MAX1 * ACT2 * MAX0 + MAX2 * MAX1 *
     >  ACT3 * MAX0 + MAX3 * MAX2 * MAX1 * ACT4 * MAX0 + 1
      WRITEDIAG = different_multiple(DIAGFREQ, MYTIME, DELTATCLOCK)
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          VF(I, J) = 0.0D00
          VRF(I, J) = 0.0D00
          UCF(I, J) = 0.0D00
          VCF(I, J) = 0.0D00
          DEL2U(I, J) = 0.0D00
          DEL2V(I, J) = 0.0D00
          DSTAR(I, J) = 0.0D00
          ZSTAR(I, J) = 0.0D00
          GUDISS(I, J) = 0.0D00
          GVDISS(I, J) = 0.0D00
          VORT3(I, J) = 0.0D00
          OMEGA3(I, J) = 0.0D00
          KE(I, J) = 0.0D00
          HDIV(I, J) = 0.0D00
          VISCAH_Z(I, J) = 0.0D00
          VISCAH_D(I, J) = 0.0D00
          VISCA4_Z(I, J) = 0.0D00
          VISCA4_D(I, J) = 0.0D00
          STRAIN(I, J) = 0.0D00
          TENSION(I, J) = 0.0D00
          HFACZ(I, J) = 0.0D00
        END DO
      END DO
      ARDUDRFAC = VFFACMOM
      ARDVDRFAC = VFFACMOM
      IF(NO_SLIP_SIDES) THEN
        SIDEMASKFAC = SIDEDRAGFACTOR
      ELSE
        SIDEMASKFAC = 0.0D00
      ENDIF
      IF((BOTTOMDRAGLINEAR .ne. 0.0D00) .OR.(NO_SLIP_BOTTOM .OR.(
     > BOTTOMDRAGQUADRATIC .ne. 0.0D00))) THEN
        BOTTOMDRAGTERMS = .TRUE.
      ELSE
        BOTTOMDRAGTERMS = .FALSE.
      ENDIF
      CALL mom_calc_hfacz(BI, BJ, K, HFACZ, R_HFACZ, MYTHID)
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          UFLD(I, J) = UVEL(I, J, K, BI, BJ)
          VFLD(I, J) = VVEL(I, J, K, BI, BJ)
        END DO
      END DO
      CALL mom_calc_ke(BI, BJ, K, SELECTKESCHEME, UFLD, VFLD, KE,
     >  MYTHID)
      CALL mom_calc_relvort3(BI, BJ, K, UFLD, VFLD, HFACZ, VORT3,
     >  MYTHID)
      IF(MOMVISCOSITY) THEN
        CALL mom_calc_hdiv(BI, BJ, K, (2), UFLD, VFLD, HDIV, MYTHID)
        CALL mom_calc_tension(BI, BJ, K, UFLD, VFLD, TENSION, MYTHID)
        CALL mom_calc_strain(BI, BJ, K, UFLD, VFLD, HFACZ, STRAIN,
     >  MYTHID)
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            IF(HFACZ(I, J) .eq. 0.0D00) THEN
              VORT3(I, J) = (VORT3(I, J) * SIDEMASKFAC)
              STRAIN(I, J) = (STRAIN(I, J) * SIDEMASKFAC)
            ENDIF
          END DO
        END DO
        CALL mom_calc_visc(BI, BJ, K, VISCAH_Z, VISCAH_D, VISCA4_Z,
     >  VISCA4_D, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, HDIV,
     >  VORT3, TENSION, STRAIN, KE, HFACZ, MYTHID)
        IF(BIHARMONIC) THEN
          CALL mom_vi_del2uv(BI, BJ, K, HDIV, VORT3, HFACZ, DEL2U,
     >  DEL2V, MYTHID)
          CALL mom_calc_hdiv(BI, BJ, K, (2), DEL2U, DEL2V, DSTAR,
     >  MYTHID)
          CALL mom_calc_relvort3(BI, BJ, K, DEL2U, DEL2V, HFACZ, ZSTAR,
     >  MYTHID)
        ENDIF
        IF(WRITEDIAG) THEN
          IF(SNAPSHOT_MDSIO) THEN
            CALL write_local_rl('Ds', 'I10', (1), STRAIN, BI, BJ, K,
     >  MYITER, MYTHID)
          ENDIF
        ENDIF
        IF(USESTRAINTENSIONVISC) THEN
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              IF(HFACZ(I, J) .eq. 0.0D00) THEN
                STRAIN(I, J) = 0.0D00
              ENDIF
            END DO
          END DO
          CALL mom_hdissip(BI, BJ, K, HDIV, VORT3, TENSION, STRAIN, KE,
     >  HFACZ, VISCAH_Z, VISCAH_D, VISCA4_Z, VISCA4_D, HARMONIC,
     >  BIHARMONIC, USEVARIABLEVISCOSITY, GUDISS, GVDISS, MYTHID)
        ELSE
          CALL mom_vi_hdissip(BI, BJ, K, HDIV, VORT3, TENSION, STRAIN,
     >  KE, HFACZ, DSTAR, ZSTAR, VISCAH_Z, VISCAH_D, VISCA4_Z, VISCA4_D
     > , HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, GUDISS, GVDISS,
     >  MYTHID)
        ENDIF
      ENDIF
      IF(MOMVISCOSITY .AND.(.NOT. IMPLICITVISCOSITY)) THEN
        CALL mom_u_rviscflux(BI, BJ, (K + 1), UVEL, KAPPARU, VRF,
     >  MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            FVERU(I, J, KDOWN) = (VRF(I, J) * ARDUDRFAC)
          END DO
        END DO
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            GUDISS(I, J) = (GUDISS(I, J) - RKSIGN * RECIP_RAW(I, J, BI,
     >  BJ) * RECIP_DRF(K) * RECIP_HFACW(I, J, K, BI, BJ) *(FVERU(I, J,
     >  KDOWN) - FVERU(I, J, KUP)))
          END DO
        END DO
      ENDIF
      IF(MOMVISCOSITY .AND. NO_SLIP_SIDES) THEN
        CALL mom_u_sidedrag(BI, BJ, K, UFLD, DEL2U, HFACZ, VISCAH_Z,
     >  VISCA4_Z, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, VF,
     >  MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GUDISS(I, J) = (GUDISS(I, J) + VF(I, J))
          END DO
        END DO
      ENDIF
      IF(BOTTOMDRAGTERMS .AND. MOMVISCOSITY) THEN
        CALL mom_u_bottomdrag(BI, BJ, K, UFLD, KE, KAPPARU, VF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GUDISS(I, J) = (GUDISS(I, J) + VF(I, J))
          END DO
        END DO
      ENDIF
      IF(MOMVISCOSITY .AND.(.NOT. IMPLICITVISCOSITY)) THEN
        CALL mom_v_rviscflux(BI, BJ, (K + 1), VVEL, KAPPARV, VRF,
     >  MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            FVERV(I, J, KDOWN) = (VRF(I, J) * ARDVDRFAC)
          END DO
        END DO
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GVDISS(I, J) = (GVDISS(I, J) - RKSIGN * RECIP_RAS(I, J, BI,
     >  BJ) * RECIP_DRF(K) * RECIP_HFACS(I, J, K, BI, BJ) *(FVERV(I, J,
     >  KDOWN) - FVERV(I, J, KUP)))
          END DO
        END DO
      ENDIF
      IF(MOMVISCOSITY .AND. NO_SLIP_SIDES) THEN
        CALL mom_v_sidedrag(BI, BJ, K, VFLD, DEL2V, HFACZ, VISCAH_Z,
     >  VISCA4_Z, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, VF,
     >  MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GVDISS(I, J) = (GVDISS(I, J) + VF(I, J))
          END DO
        END DO
      ENDIF
      IF(BOTTOMDRAGTERMS .AND. MOMVISCOSITY) THEN
        CALL mom_v_bottomdrag(BI, BJ, K, VFLD, KE, KAPPARV, VF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GVDISS(I, J) = (GVDISS(I, J) + VF(I, J))
          END DO
        END DO
      ENDIF
      IF(WRITEDIAG) THEN
        IF(SNAPSHOT_MDSIO) THEN
          CALL write_local_rl('Z3', 'I10', (1), VORT3, BI, BJ, K,
     >  MYITER, MYTHID)
        ENDIF
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          IF(HFACZ(I, J) .eq. 0.0D00) THEN
            VORT3(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      IF(USEABSVORTICITY) THEN
        CALL mom_calc_absvort3(BI, BJ, K, VORT3, OMEGA3, MYTHID)
      ENDIF
      IF(USECORIOLIS .AND.(.NOT.(USECDSCHEME .OR.(MOMADVECTION .AND.
     >  USEABSVORTICITY)))) THEN
        IF(USEABSVORTICITY) THEN
          CALL mom_vi_u_coriolis(BI, BJ, K, VFLD, OMEGA3, HFACZ,
     >  R_HFACZ, UCF, MYTHID)
          CALL mom_vi_v_coriolis(BI, BJ, K, UFLD, OMEGA3, HFACZ,
     >  R_HFACZ, VCF, MYTHID)
        ELSE
          CALL mom_vi_coriolis(BI, BJ, K, UFLD, VFLD, HFACZ, R_HFACZ,
     >  UCF, VCF, MYTHID)
        ENDIF
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = UCF(I, J)
            GV(I, J, K, BI, BJ) = VCF(I, J)
          END DO
        END DO
        IF(WRITEDIAG) THEN
          IF(SNAPSHOT_MDSIO) THEN
            CALL write_local_rl('fV', 'I10', (1), UCF, BI, BJ, K,
     >  MYITER, MYTHID)
            CALL write_local_rl('fU', 'I10', (1), VCF, BI, BJ, K,
     >  MYITER, MYTHID)
          ENDIF
        ENDIF
      ELSE
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = 0.0D00
            GV(I, J, K, BI, BJ) = 0.0D00
          END DO
        END DO
      ENDIF
      IF(MOMADVECTION) THEN
        IF(USEABSVORTICITY .AND.(HIGHORDERVORTICITY .OR.
     >  UPWINDVORTICITY)) THEN
          CALL mom_vi_u_coriolis_c4(BI, BJ, K, VFLD, OMEGA3, R_HFACZ,
     >  UCF, MYTHID)
        ELSE
          IF(HIGHORDERVORTICITY .OR. UPWINDVORTICITY) THEN
            CALL mom_vi_u_coriolis_c4(BI, BJ, K, VFLD, VORT3, R_HFACZ,
     >  UCF, MYTHID)
          ELSE
            IF(USEABSVORTICITY) THEN
              CALL mom_vi_u_coriolis(BI, BJ, K, VFLD, OMEGA3, HFACZ,
     >  R_HFACZ, UCF, MYTHID)
            ELSE
              CALL mom_vi_u_coriolis(BI, BJ, K, VFLD, VORT3, HFACZ,
     >  R_HFACZ, UCF, MYTHID)
            ENDIF
          ENDIF
        ENDIF
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (UCF(I, J) + GU(I, J, K, BI, BJ))
          END DO
        END DO
        IF(USEABSVORTICITY .AND.(HIGHORDERVORTICITY .OR.
     >  UPWINDVORTICITY)) THEN
          CALL mom_vi_v_coriolis_c4(BI, BJ, K, UFLD, OMEGA3, R_HFACZ,
     >  VCF, MYTHID)
        ELSE
          IF(HIGHORDERVORTICITY .OR. UPWINDVORTICITY) THEN
            CALL mom_vi_v_coriolis_c4(BI, BJ, K, UFLD, VORT3, R_HFACZ,
     >  VCF, MYTHID)
          ELSE
            IF(USEABSVORTICITY) THEN
              CALL mom_vi_v_coriolis(BI, BJ, K, UFLD, OMEGA3, HFACZ,
     >  R_HFACZ, VCF, MYTHID)
            ELSE
              CALL mom_vi_v_coriolis(BI, BJ, K, UFLD, VORT3, HFACZ,
     >  R_HFACZ, VCF, MYTHID)
            ENDIF
          ENDIF
        ENDIF
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (VCF(I, J) + GV(I, J, K, BI, BJ))
          END DO
        END DO
        IF(WRITEDIAG) THEN
          IF(SNAPSHOT_MDSIO) THEN
            CALL write_local_rl('zV', 'I10', (1), UCF, BI, BJ, K,
     >  MYITER, MYTHID)
            CALL write_local_rl('zU', 'I10', (1), VCF, BI, BJ, K,
     >  MYITER, MYTHID)
          ENDIF
        ENDIF
        IF(.NOT. MOMIMPLVERTADV) THEN
          CALL mom_vi_u_vertshear(BI, BJ, K, UVEL, WVEL, UCF, MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GU(I, J, K, BI, BJ) = (UCF(I, J) + GU(I, J, K, BI, BJ))
            END DO
          END DO
          CALL mom_vi_v_vertshear(BI, BJ, K, VVEL, WVEL, VCF, MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GV(I, J, K, BI, BJ) = (VCF(I, J) + GV(I, J, K, BI, BJ))
            END DO
          END DO
        ENDIF
        CALL mom_vi_u_grad_ke(BI, BJ, K, KE, UCF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (UCF(I, J) + GU(I, J, K, BI, BJ))
          END DO
        END DO
        CALL mom_vi_v_grad_ke(BI, BJ, K, KE, VCF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (VCF(I, J) + GV(I, J, K, BI, BJ))
          END DO
        END DO
        IF(WRITEDIAG) THEN
          IF(SNAPSHOT_MDSIO) THEN
            CALL write_local_rl('KEx', 'I10', (1), UCF, BI, BJ, K,
     >  MYITER, MYTHID)
            CALL write_local_rl('KEy', 'I10', (1), VCF, BI, BJ, K,
     >  MYITER, MYTHID)
          ENDIF
        ENDIF
      ENDIF
      IF(USE3DCORIOLIS) THEN
        CALL mom_u_coriolis_nh(BI, BJ, K, WVEL, UCF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (UCF(I, J) + GU(I, J, K, BI, BJ))
          END DO
        END DO
        IF(USINGCURVILINEARGRID) THEN
          CALL mom_v_coriolis_nh(BI, BJ, K, WVEL, VCF, MYTHID)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GV(I, J, K, BI, BJ) = (VCF(I, J) + GV(I, J, K, BI, BJ))
            END DO
          END DO
        ENDIF
      ENDIF
      IF(USENHMTERMS) THEN
        CALL mom_u_metric_nh(BI, BJ, K, UFLD, WVEL, UCF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (UCF(I, J) + GU(I, J, K, BI, BJ))
          END DO
        END DO
        CALL mom_v_metric_nh(BI, BJ, K, VFLD, WVEL, VCF, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GV(I, J, K, BI, BJ) = (VCF(I, J) + GV(I, J, K, BI, BJ))
          END DO
        END DO
      ENDIF
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) * MASKW(I, J, K,
     >  BI, BJ))
          GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) * MASKS(I, J, K,
     >  BI, BJ))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE .AND.((MYITER .eq. NITER0) .AND.((K
     >  .eq. 4) .AND.(DEBUGLEVEL .GE. 2)))) THEN
        CALL debug_cs_corner_uv(' uDiss,vDiss from MOM_VECINV', GUDISS,
     >  GVDISS, K, STANDARDMESSAGEUNIT, BI, BJ, MYTHID)
      ENDIF
      IF(WRITEDIAG) THEN
        IF(SNAPSHOT_MDSIO) THEN
          CALL write_local_rl('W3', 'I10', (1), OMEGA3, BI, BJ, K,
     >  MYITER, MYTHID)
          CALL write_local_rl('KE', 'I10', (1), KE, BI, BJ, K, MYITER,
     >  MYTHID)
          CALL write_local_rl('D', 'I10', (1), HDIV, BI, BJ, K, MYITER,
     >  MYTHID)
          CALL write_local_rl('Dt', 'I10', (1), TENSION, BI, BJ, K,
     >  MYITER, MYTHID)
          CALL write_local_rl('Du', 'I10', (1), GUDISS, BI, BJ, K,
     >  MYITER, MYTHID)
          CALL write_local_rl('Dv', 'I10', (1), GVDISS, BI, BJ, K,
     >  MYITER, MYTHID)
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_coriolis(BI, BJ, K, UFLD, VFLD, HFACZ, R_HFACZ,
     >  UCORIOLISTERM, VCORIOLISTERM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) UCORIOLISTERM(-2 : 93, -2 : 43)
      REAL(w2f__8) VCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) EPSIL
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) UBARXY
      REAL(w2f__8) VBARXY
C
C     **** Statements ****
C
      EPSIL = 1.00000000000000006228D-09
      IF(USEJAMARTWETPOINTS) THEN
        DO J = -2, 42, 1
          DO I = -1, 93, 1
            VBARXY = ((HFACS(I, J, K, BI, BJ) * VFLD(I, J) * DXG(I, J,
     >  BI, BJ) + HFACS(I + (-1), J, K, BI, BJ) * VFLD(I + (-1), J) *
     >  DXG(I + (-1), J, BI, BJ)) +(HFACS(I, J + 1, K, BI, BJ) * VFLD(I
     > , J + 1) * DXG(I, J + 1, BI, BJ) + HFACS(I + (-1), J + 1, K, BI,
     >  BJ) * VFLD(I + (-1), J + 1) * DXG(I + (-1), J + 1, BI, BJ))) /
     >  MAX(EPSIL, (HFACS(I, J, K, BI, BJ) + HFACS(I + (-1), J, K, BI,
     >  BJ)) +(HFACS(I, J + 1, K, BI, BJ) + HFACS(I + (-1), J + 1, K,
     >  BI, BJ)))
            UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DXC(I
     > , J, BI, BJ) * VBARXY *(FCORIG(I, J, BI, BJ) + FCORIG(I, J + 1,
     >  BI, BJ)) * 5.0D-01)
          END DO
        END DO
      ELSE
        DO J = -2, 42, 1
          DO I = -1, 93, 1
            VBARXY = ((VFLD(I, J) * DXG(I, J, BI, BJ) + VFLD(I + (-1),
     >  J) * DXG(I + (-1), J, BI, BJ)) +(VFLD(I, J + 1) * DXG(I, J + 1,
     >  BI, BJ) + VFLD(I + (-1), J + 1) * DXG(I + (-1), J + 1, BI, BJ))
     > ) * 2.5D-01
            UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DXC(I
     > , J, BI, BJ) * VBARXY *(FCORIG(I, J, BI, BJ) + FCORIG(I, J + 1,
     >  BI, BJ)) * 5.0D-01)
          END DO
        END DO
      ENDIF
      IF(USEJAMARTWETPOINTS) THEN
        DO J = -1, 43, 1
          DO I = -2, 92, 1
            UBARXY = ((HFACW(I, J, K, BI, BJ) * UFLD(I, J) * DYG(I, J,
     >  BI, BJ) + HFACW(I, J + (-1), K, BI, BJ) * UFLD(I, J + (-1)) *
     >  DYG(I, J + (-1), BI, BJ)) +(HFACW(I + 1, J, K, BI, BJ) * UFLD(I
     >  + 1, J) * DYG(I + 1, J, BI, BJ) + HFACW(I + 1, J + (-1), K, BI,
     >  BJ) * UFLD(I + 1, J + (-1)) * DYG(I + 1, J + (-1), BI, BJ))) /
     >  MAX(EPSIL, (HFACW(I, J, K, BI, BJ) + HFACW(I, J + (-1), K, BI,
     >  BJ)) +(HFACW(I + 1, J, K, BI, BJ) + HFACW(I + 1, J + (-1), K,
     >  BI, BJ)))
            VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) * RECIP_DYC
     > (I, J, BI, BJ) * UBARXY *(FCORIG(I, J, BI, BJ) + FCORIG(I + 1, J
     > , BI, BJ)) * 5.0D-01))
          END DO
        END DO
      ELSE
        DO J = -1, 43, 1
          DO I = -2, 92, 1
            UBARXY = ((UFLD(I, J) * DYG(I, J, BI, BJ) + UFLD(I, J + (-1
     > )) * DYG(I, J + (-1), BI, BJ)) +(UFLD(I + 1, J) * DYG(I + 1, J,
     >  BI, BJ) + UFLD(I + 1, J + (-1)) * DYG(I + 1, J + (-1), BI, BJ))
     > ) * 2.5D-01
            VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) * RECIP_DYC
     > (I, J, BI, BJ) * UBARXY *(FCORIG(I, J, BI, BJ) + FCORIG(I + 1, J
     > , BI, BJ)) * 5.0D-01))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_del2uv(BI, BJ, K, HDIV, VORT3, HFACZ, DEL2U,
     >  DEL2V, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) HDIV(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2U(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2V(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL fill_cs_corner_tr_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(USECUBEDSPHEREEXCHANGE) THEN
        CALL fill_cs_corner_tr_rl((1), (.FALSE.), HDIV, BI, BJ, MYTHID)
      ENDIF
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          DEL2U(I, J) = (RECIP_DXC(I, J, BI, BJ) *(HDIV(I, J) - HDIV(I
     >  + (-1), J)) - RECIP_DYG(I, J, BI, BJ) * RECIP_HFACW(I, J, K, BI
     > , BJ) *(VORT3(I, J + 1) * HFACZ(I, J + 1) - VORT3(I, J) * HFACZ(
     > I, J)))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE) THEN
        CALL fill_cs_corner_tr_rl((2), (.FALSE.), HDIV, BI, BJ, MYTHID)
      ENDIF
      DO J = -1, 42, 1
        DO I = -1, 92, 1
          DEL2V(I, J) = (RECIP_DXG(I, J, BI, BJ) * RECIP_HFACS(I, J, K,
     >  BI, BJ) *(VORT3(I + 1, J) * HFACZ(I + 1, J) - VORT3(I, J) *
     >  HFACZ(I, J)) + RECIP_DYC(I, J, BI, BJ) *(HDIV(I, J) - HDIV(I, J
     >  + (-1))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_hdissip(BI, BJ, K, HDIV, VORT3, TENSION, STRAIN
     > , KE, HFACZ, DSTAR, ZSTAR, VISCAH_Z, VISCAH_D, VISCA4_Z,
     >  VISCA4_D, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, UDISSIP,
     >  VDISSIP, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) HDIV(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      REAL(w2f__8) TENSION(-2 : 93, -2 : 43)
      REAL(w2f__8) STRAIN(-2 : 93, -2 : 43)
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) DSTAR(-2 : 93, -2 : 43)
      REAL(w2f__8) ZSTAR(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_D(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) HARMONIC
      LOGICAL(w2f__i4) BIHARMONIC
      LOGICAL(w2f__i4) USEVARIABLEVISCOSITY
      REAL(w2f__8) UDISSIP(-2 : 93, -2 : 43)
      REAL(w2f__8) VDISSIP(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DIJ
      REAL(w2f__8) DIM
      REAL(w2f__8) DMJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) UD2
      REAL(w2f__8) UD4
      REAL(w2f__8) VD2
      REAL(w2f__8) VD4
      REAL(w2f__8) ZIJ
      REAL(w2f__8) ZIJ1
      REAL(w2f__8) ZIP
      REAL(w2f__8) ZIP1
      REAL(w2f__8) ZPJ
      REAL(w2f__8) ZPJ1
C
C     **** Statements ****
C
      IF(HARMONIC) THEN
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            IF(USEVARIABLEVISCOSITY) THEN
              DIJ = HDIV(I, J) * VISCAH_D(I, J)
              DIM = HDIV(I, J + (-1)) * VISCAH_D(I, J + (-1))
              DMJ = HDIV(I + (-1), J) * VISCAH_D(I + (-1), J)
              ZIJ = VISCAH_Z(I, J) * VORT3(I, J) * HFACZ(I, J)
              ZIP = VISCAH_Z(I, J + 1) * VORT3(I, J + 1) * HFACZ(I, J +
     >  1)
              ZPJ = VISCAH_Z(I + 1, J) * VORT3(I + 1, J) * HFACZ(I + 1,
     >  J)
              UD2 = (RECIP_DXC(I, J, BI, BJ) * COSFACU(J, BI, BJ) *(DIJ
     >  - DMJ) - RECIP_DYG(I, J, BI, BJ) * RECIP_HFACW(I, J, K, BI, BJ)
     >  *(ZIP - ZIJ))
              VD2 = (COSFACV(J, BI, BJ) * RECIP_DXG(I, J, BI, BJ) *
     >  RECIP_HFACS(I, J, K, BI, BJ) *(ZPJ - ZIJ) + RECIP_DYC(I, J, BI,
     >  BJ) *(DIJ - DIM))
            ELSE
              DIM = HDIV(I, J + (-1))
              DIJ = HDIV(I, J)
              DMJ = HDIV(I + (-1), J)
              ZIP = VORT3(I, J + 1) * HFACZ(I, J + 1)
              ZIJ = VORT3(I, J) * HFACZ(I, J)
              ZPJ = VORT3(I + 1, J) * HFACZ(I + 1, J)
              UD2 = RECIP_DXC(I, J, BI, BJ) * COSFACU(J, BI, BJ) *
     >  VISCAHD *(DIJ - DMJ) - RECIP_DYG(I, J, BI, BJ) * RECIP_HFACW(I,
     >  J, K, BI, BJ) * VISCAHZ *(ZIP - ZIJ)
              VD2 = RECIP_DXG(I, J, BI, BJ) * COSFACV(J, BI, BJ) *
     >  RECIP_HFACS(I, J, K, BI, BJ) * VISCAHZ *(ZPJ - ZIJ) + RECIP_DYC
     > (I, J, BI, BJ) * VISCAHD *(DIJ - DIM)
            ENDIF
            UDISSIP(I, J) = UD2
            VDISSIP(I, J) = VD2
          END DO
        END DO
      ELSE
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            UDISSIP(I, J) = 0.0D00
            VDISSIP(I, J) = 0.0D00
          END DO
        END DO
      ENDIF
      IF(BIHARMONIC) THEN
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            DIM = DSTAR(I, J + (-1))
            DIJ = DSTAR(I, J)
            DMJ = DSTAR(I + (-1), J)
            ZIP1 = HFACZ(I, J + 1) * ZSTAR(I, J + 1)
            ZIJ1 = HFACZ(I, J) * ZSTAR(I, J)
            ZPJ1 = HFACZ(I + 1, J) * ZSTAR(I + 1, J)
            IF(USEVARIABLEVISCOSITY) THEN
              DIJ = VISCA4_D(I, J) * DIJ
              DIM = VISCA4_D(I, J + (-1)) * DIM
              DMJ = VISCA4_D(I + (-1), J) * DMJ
              ZIJ = VISCA4_Z(I, J) * ZIJ1
              ZIP = VISCA4_Z(I, J + 1) * ZIP1
              ZPJ = VISCA4_Z(I + 1, J) * ZPJ1
              UD4 = (RECIP_DXC(I, J, BI, BJ) * COSFACU(J, BI, BJ) *(DIJ
     >  - DMJ) - RECIP_DYG(I, J, BI, BJ) * RECIP_HFACW(I, J, K, BI, BJ)
     >  *(ZIP - ZIJ))
              VD4 = (COSFACV(J, BI, BJ) * RECIP_DXG(I, J, BI, BJ) *
     >  RECIP_HFACS(I, J, K, BI, BJ) *(ZPJ - ZIJ) + RECIP_DYC(I, J, BI,
     >  BJ) *(DIJ - DIM))
            ELSE
              ZIJ = ZIJ1
              ZIP = ZIP1
              ZPJ = ZPJ1
              UD4 = RECIP_DXC(I, J, BI, BJ) * COSFACU(J, BI, BJ) *
     >  VISCA4D *(DIJ - DMJ) - RECIP_DYG(I, J, BI, BJ) * RECIP_HFACW(I,
     >  J, K, BI, BJ) * VISCA4Z *(ZIP - ZIJ)
              VD4 = RECIP_DXG(I, J, BI, BJ) * COSFACV(J, BI, BJ) *
     >  RECIP_HFACS(I, J, K, BI, BJ) * VISCA4Z *(ZPJ - ZIJ) + RECIP_DYC
     > (I, J, BI, BJ) * VISCA4D *(DIJ - DIM)
            ENDIF
            UDISSIP(I, J) = (UDISSIP(I, J) - UD4)
            VDISSIP(I, J) = (VDISSIP(I, J) - VD4)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_u_coriolis(BI, BJ, K, VFLD, OMEGA3, HFACZ,
     >  R_HFACZ, UCORIOLISTERM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) OMEGA3(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) UCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) EPSIL
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      CHARACTER(512) MSGBUF
      REAL(w2f__8) ONETHIRD
      EXTERNAL print_error
      REAL(w2f__8) TMPFAC
      LOGICAL(w2f__i4) UPWINDVORT3
      PARAMETER ( UPWINDVORT3 = .FALSE.)
      REAL(w2f__8) VBARXM
      REAL(w2f__8) VBARXP
      REAL(w2f__8) VBARXY
      REAL(w2f__8) VORT3IJ
      REAL(w2f__8) VORT3IP
      REAL(w2f__8) VORT3MJ
      REAL(w2f__8) VORT3MP
      REAL(w2f__8) VORT3U
C
C     **** Statements ****
C
      EPSIL = 1.00000000000000006228D-09
      TMPFAC = 1.0D00
      ONETHIRD = 3.3333333333333331483D-01
      IF(SELECTVORTSCHEME .eq. 0) THEN
        DO J = -2, 42, 1
          DO I = -1, 93, 1
            VBARXY = ((HFACS(I, J, K, BI, BJ) * VFLD(I, J) * DXG(I, J,
     >  BI, BJ) + HFACS(I + (-1), J, K, BI, BJ) * VFLD(I + (-1), J) *
     >  DXG(I + (-1), J, BI, BJ)) +(HFACS(I, J + 1, K, BI, BJ) * VFLD(I
     > , J + 1) * DXG(I, J + 1, BI, BJ) + HFACS(I + (-1), J + 1, K, BI,
     >  BJ) * VFLD(I + (-1), J + 1) * DXG(I + (-1), J + 1, BI, BJ))) *
     >  2.5D-01
            IF(.FALSE.) THEN
              IF(VBARXY .GT. 0.0D00) THEN
                VORT3U = OMEGA3(I, J) * R_HFACZ(I, J)
              ELSE
                VORT3U = OMEGA3(I, J + 1) * R_HFACZ(I, J + 1)
              ENDIF
            ELSE
              VORT3U = (OMEGA3(I, J) * R_HFACZ(I, J) + OMEGA3(I, J + 1)
     >  * R_HFACZ(I, J + 1)) * 5.0D-01
            ENDIF
            UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DXC(I
     > , J, BI, BJ) * VBARXY * VORT3U)
          END DO
        END DO
      ELSE
        IF(SELECTVORTSCHEME .eq. 1) THEN
          DO J = -2, 42, 1
            DO I = -1, 93, 1
              VBARXY = (((HFACZ(I, J) * VFLD(I, J) * DXG(I, J, BI, BJ)
     >  + HFACZ(I, J) * VFLD(I + (-1), J) * DXG(I + (-1), J, BI, BJ)) +
     > (HFACZ(I, J + 1) * VFLD(I, J + 1) * DXG(I, J + 1, BI, BJ) +
     >  HFACZ(I, J + 1) * VFLD(I + (-1), J + 1) * DXG(I + (-1), J + 1,
     >  BI, BJ))) * 5.0D-01) / MAX(EPSIL, HFACZ(I, J) + HFACZ(I, J + 1)
     > )
              IF(.FALSE.) THEN
                IF(VBARXY .GT. 0.0D00) THEN
                  VORT3U = OMEGA3(I, J)
                ELSE
                  VORT3U = OMEGA3(I, J + 1)
                ENDIF
              ELSE
                VORT3U = (OMEGA3(I, J) + OMEGA3(I, J + 1)) * 5.0D-01
              ENDIF
              UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DXC
     > (I, J, BI, BJ) * VBARXY * VORT3U)
            END DO
          END DO
        ELSE
          IF(SELECTVORTSCHEME .eq. 2) THEN
            DO J = -2, 42, 1
              DO I = -1, 93, 1
                VBARXM = (HFACS(I, J, K, BI, BJ) * VFLD(I, J) * DXG(I,
     >  J, BI, BJ) + HFACS(I + (-1), J, K, BI, BJ) * VFLD(I + (-1), J)
     >  * DXG(I + (-1), J, BI, BJ)) * 5.0D-01
                VBARXP = (HFACS(I, J + 1, K, BI, BJ) * VFLD(I, J + 1) *
     >  DXG(I, J + 1, BI, BJ) + HFACS(I + (-1), J + 1, K, BI, BJ) *
     >  VFLD(I + (-1), J + 1) * DXG(I + (-1), J + 1, BI, BJ)) * 5.0D-01
                IF(.FALSE.) THEN
                  IF((VBARXM + VBARXP) .GT. 0.0D00) THEN
                    VORT3U = OMEGA3(I, J) * R_HFACZ(I, J) * VBARXM
                  ELSE
                    VORT3U = OMEGA3(I, J + 1) * R_HFACZ(I, J + 1) *
     >  VBARXP
                  ENDIF
                ELSE
                  VORT3U = (OMEGA3(I, J) * R_HFACZ(I, J) * VBARXM +
     >  OMEGA3(I, J + 1) * R_HFACZ(I, J + 1) * VBARXP) * 5.0D-01
                ENDIF
                UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) *
     >  RECIP_DXC(I, J, BI, BJ) * VORT3U)
              END DO
            END DO
          ELSE
            IF(SELECTVORTSCHEME .eq. 3) THEN
              DO J = -2, 42, 1
                DO I = -1, 92, 1
                  VORT3MJ = HFACS(I + (-1), J, K, BI, BJ) * DXG(I + (-1
     > ), J, BI, BJ) * VFLD(I + (-1), J) * ONETHIRD *(OMEGA3(I, J) *
     >  R_HFACZ(I, J) +(OMEGA3(I + (-1), J) * R_HFACZ(I + (-1), J) +
     >  OMEGA3(I, J + 1) * R_HFACZ(I, J + 1)))
                  VORT3IJ = HFACS(I, J, K, BI, BJ) * DXG(I, J, BI, BJ)
     >  * VFLD(I, J) * ONETHIRD *(OMEGA3(I, J) * R_HFACZ(I, J) +(OMEGA3
     > (I + 1, J) * R_HFACZ(I + 1, J) + OMEGA3(I, J + 1) * R_HFACZ(I, J
     >  + 1)))
                  VORT3MP = HFACS(I + (-1), J + 1, K, BI, BJ) * DXG(I +
     >  (-1), J + 1, BI, BJ) * VFLD(I + (-1), J + 1) * ONETHIRD *(
     > OMEGA3(I, J + 1) * R_HFACZ(I, J + 1) +(OMEGA3(I, J) * R_HFACZ(I,
     >  J) + OMEGA3(I + (-1), J + 1) * R_HFACZ(I + (-1), J + 1)))
                  VORT3IP = HFACS(I, J + 1, K, BI, BJ) * DXG(I, J + 1,
     >  BI, BJ) * VFLD(I, J + 1) * ONETHIRD *(OMEGA3(I, J + 1) *
     >  R_HFACZ(I, J + 1) +(OMEGA3(I, J) * R_HFACZ(I, J) + OMEGA3(I + 1
     > , J + 1) * R_HFACZ(I + 1, J + 1)))
                  UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) *
     >  RECIP_DXC(I, J, BI, BJ) *((VORT3IJ + VORT3MJ) +(VORT3IP +
     >  VORT3MP)) * 2.5D-01)
                END DO
              END DO
            ELSE
              WRITE(MSGBUF, '(A,I5,A)')
     >  'MOM_VI_U_CORIOLIS: selectVortScheme=', SELECTVORTSCHEME,
     >  ' not implemented'
              CALL print_error(MSGBUF, MYTHID)
              WRITE(*, *) 'ABNORMAL END: S/R MOM_VI_U_CORIOLIS'
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF(USEJAMARTMOMADV) THEN
        DO J = -2, 42, 1
          DO I = -1, 92, 1
            UCORIOLISTERM(I, J) = ((HFACW(I, J, K, BI, BJ) *
     >  UCORIOLISTERM(I, J) * 4.0D00) / MAX(EPSIL, (HFACS(I, J, K, BI,
     >  BJ) + HFACS(I + (-1), J, K, BI, BJ)) +(HFACS(I, J + 1, K, BI,
     >  BJ) + HFACS(I + (-1), J + 1, K, BI, BJ))))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_u_coriolis_c4(BI, BJ, K, VFLD, OMEGA3, R_HFACZ,
     >  UCORIOLISTERM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) OMEGA3(-2 : 93, -2 : 43)
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) UCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      LOGICAL(w2f__i4) FOURTHVORT3
      PARAMETER ( FOURTHVORT3 = .TRUE.)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      CHARACTER(512) MSGBUF
      INTEGER(w2f__i4) MYFACE
      LOGICAL(w2f__i4) NORTHEASTCORNER
      LOGICAL(w2f__i4) NORTHWESTCORNER
      REAL(w2f__8) ONESIXTH
      PARAMETER ( ONESIXTH = 1.66666666666666657415D-01)
      REAL(w2f__8) ONETWELVE
      PARAMETER ( ONETWELVE = 8.33333333333333287074D-02)
      EXTERNAL print_error
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      LOGICAL(w2f__i4) SOUTHEASTCORNER
      LOGICAL(w2f__i4) SOUTHWESTCORNER
      REAL(w2f__8) VBARXM
      REAL(w2f__8) VBARXP
      REAL(w2f__8) VBARXY
      REAL(w2f__8) VORT3R(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3U
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          VORT3R(I, J) = (OMEGA3(I, J) * R_HFACZ(I, J))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE .AND. HIGHORDERVORTICITY) THEN
        MYFACE = BI
        SOUTHWESTCORNER = .TRUE.
        SOUTHEASTCORNER = .TRUE.
        NORTHWESTCORNER = .TRUE.
        NORTHEASTCORNER = .TRUE.
        IF(SOUTHWESTCORNER) THEN
          I = 1
          J = 1
          VORT3R(I, J + (-1)) = ((VORT3R(I + 1, J) + VORT3R(I, J + (-1)
     > )) * 5.0D-01)
        ENDIF
        IF(SOUTHEASTCORNER) THEN
          I = 91
          J = 1
          VORT3R(I, J + (-1)) = ((VORT3R(I + (-1), J) + VORT3R(I, J + (
     > -1))) * 5.0D-01)
        ENDIF
        IF(NORTHWESTCORNER) THEN
          I = 1
          J = 41
          VORT3R(I, J + 1) = ((VORT3R(I + 1, J) + VORT3R(I, J + 1)) *
     >  5.0D-01)
        ENDIF
        IF(NORTHEASTCORNER) THEN
          I = 91
          J = 41
          VORT3R(I, J + 1) = ((VORT3R(I + (-1), J) + VORT3R(I, J + 1))
     >  * 5.0D-01)
        ENDIF
      ENDIF
      IF(SELECTVORTSCHEME .eq. 0) THEN
        DO J = 1, 40, 1
          DO I = 1, 91, 1
            VBARXY = ((HFACS(I, J, K, BI, BJ) * VFLD(I, J) * DXG(I, J,
     >  BI, BJ) + HFACS(I + (-1), J, K, BI, BJ) * VFLD(I + (-1), J) *
     >  DXG(I + (-1), J, BI, BJ)) +(HFACS(I, J + 1, K, BI, BJ) * VFLD(I
     > , J + 1) * DXG(I, J + 1, BI, BJ) + HFACS(I + (-1), J + 1, K, BI,
     >  BJ) * VFLD(I + (-1), J + 1) * DXG(I + (-1), J + 1, BI, BJ))) *
     >  2.5D-01
            IF(UPWINDVORTICITY) THEN
              IF(VBARXY .GT. 0.0D00) THEN
                VORT3U = VORT3R(I, J)
              ELSE
                VORT3U = VORT3R(I, J + 1)
              ENDIF
            ELSE
              IF(.TRUE.) THEN
                RJP = VORT3R(I, J + 2) - VORT3R(I, J + 1)
                RJM = VORT3R(I, J) - VORT3R(I, J + (-1))
                VORT3U = (VORT3R(I, J) + VORT3R(I, J + 1) -(RJP - RJM)
     >  * 8.33333333333333287074D-02) * 5.0D-01
              ELSE
                VORT3U = (VORT3R(I, J) + VORT3R(I, J + 1)) * 5.0D-01
              ENDIF
            ENDIF
            UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DXC(I
     > , J, BI, BJ) * VBARXY * VORT3U)
          END DO
        END DO
      ELSE
        IF(SELECTVORTSCHEME .eq. 2) THEN
          DO J = 1, 40, 1
            DO I = 1, 91, 1
              VBARXM = (HFACS(I, J, K, BI, BJ) * VFLD(I, J) * DXG(I, J,
     >  BI, BJ) + HFACS(I + (-1), J, K, BI, BJ) * VFLD(I + (-1), J) *
     >  DXG(I + (-1), J, BI, BJ)) * 5.0D-01
              VBARXP = (HFACS(I, J + 1, K, BI, BJ) * VFLD(I, J + 1) *
     >  DXG(I, J + 1, BI, BJ) + HFACS(I + (-1), J + 1, K, BI, BJ) *
     >  VFLD(I + (-1), J + 1) * DXG(I + (-1), J + 1, BI, BJ)) * 5.0D-01
              IF(UPWINDVORTICITY) THEN
                IF((VBARXM + VBARXP) .GT. 0.0D00) THEN
                  VORT3U = VORT3R(I, J) * VBARXM
                ELSE
                  VORT3U = VORT3R(I, J + 1) * VBARXP
                ENDIF
              ELSE
                IF(.TRUE.) THEN
                  RJP = VORT3R(I, J + 1) -(VORT3R(I, J + 2) - VORT3R(I,
     >  J)) * 1.66666666666666657415D-01
                  RJM = VORT3R(I, J) +(VORT3R(I, J + 1) - VORT3R(I, J +
     >  (-1))) * 1.66666666666666657415D-01
                  VORT3U = (RJM * VBARXM + RJP * VBARXP) * 5.0D-01
                ELSE
                  VORT3U = (VORT3R(I, J) * VBARXM + VORT3R(I, J + 1) *
     >  VBARXP) * 5.0D-01
                ENDIF
              ENDIF
              UCORIOLISTERM(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DXC
     > (I, J, BI, BJ) * VORT3U)
            END DO
          END DO
        ELSE
          WRITE(MSGBUF, '(A,I5,A)')
     >  'MOM_VI_U_CORIOLIS_C4: selectVortScheme=', SELECTVORTSCHEME,
     >  ' not implemented'
          CALL print_error(MSGBUF, MYTHID)
          WRITE(*, *) 'ABNORMAL END: S/R MOM_VI_U_CORIOLIS_C4'
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_u_grad_ke(BI, BJ, K, KE, DKEDX, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      REAL(w2f__8) DKEDX(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          DKEDX(I, J) = (-(MASKW(I, J, K, BI, BJ) * RECIP_DXC(I, J, BI,
     >  BJ) *(KE(I, J) - KE(I + (-1), J))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_u_vertshear(BI, BJ, K, UFLD, WFLD, USHEARTERM,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) USHEARTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) MASK_KM1
      REAL(w2f__8) MASK_KP1
      LOGICAL(w2f__i4) RADVAREAWEIGHT
      REAL(w2f__8) UZM
      REAL(w2f__8) UZP
      REAL(w2f__8) WBARXM
      REAL(w2f__8) WBARXP
C
C     **** Statements ****
C
      RADVAREAWEIGHT = .TRUE.
      IF((SELECTKESCHEME .eq. 1) .OR.(SELECTKESCHEME .eq. 3)) THEN
        RADVAREAWEIGHT = .FALSE.
      ENDIF
      KP1 = MIN(K + 1, 15)
      MASK_KP1 = 1.0D00
      IF(K .eq. 15) THEN
        MASK_KP1 = 0.0D00
      ENDIF
      KM1 = MAX(K +(-1), 1)
      MASK_KM1 = 1.0D00
      IF(K .eq. 1) THEN
        MASK_KM1 = 0.0D00
      ENDIF
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          IF(RADVAREAWEIGHT) THEN
            WBARXM = RECIP_RAW(I, J, BI, BJ) * MASK_KM1 *(MASKC(I, J,
     >  KM1, BI, BJ) * RA(I, J, BI, BJ) * WFLD(I, J, K, BI, BJ) + MASKC
     > (I + (-1), J, KM1, BI, BJ) * RA(I + (-1), J, BI, BJ) * WFLD(I +
     >  (-1), J, K, BI, BJ)) * 5.0D-01
            WBARXP = RECIP_RAW(I, J, BI, BJ) * MASK_KP1 *(RA(I, J, BI,
     >  BJ) * WFLD(I, J, KP1, BI, BJ) + RA(I + (-1), J, BI, BJ) * WFLD(
     > I + (-1), J, KP1, BI, BJ)) * 5.0D-01
          ELSE
            WBARXM = MASK_KM1 *(WFLD(I, J, K, BI, BJ) * MASKC(I, J, KM1
     > , BI, BJ) + WFLD(I + (-1), J, K, BI, BJ) * MASKC(I + (-1), J,
     >  KM1, BI, BJ)) * 5.0D-01
            WBARXP = MASK_KP1 *(WFLD(I, J, KP1, BI, BJ) + WFLD(I + (-1)
     > , J, KP1, BI, BJ)) * 5.0D-01
          ENDIF
          UZM = RKSIGN *(UFLD(I, J, K, BI, BJ) - UFLD(I, J, KM1, BI, BJ
     > ) * MASK_KM1)
          UZP = RKSIGN *(UFLD(I, J, KP1, BI, BJ) * MASK_KP1 - UFLD(I, J
     > , K, BI, BJ))
          IF(UPWINDSHEAR) THEN
            USHEARTERM(I, J) = (-(RECIP_DRF(K) * RECIP_HFACW(I, J, K,
     >  BI, BJ) *((UZM * WBARXM + UZP * WBARXP) +(UZP * ABS(WBARXP) -
     >  UZM * ABS(WBARXM))) * 5.0D-01))
          ELSE
            USHEARTERM(I, J) = (-(RECIP_DRF(K) * RECIP_HFACW(I, J, K,
     >  BI, BJ) *(UZM * WBARXM + UZP * WBARXP) * 5.0D-01))
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_v_coriolis(BI, BJ, K, UFLD, OMEGA3, HFACZ,
     >  R_HFACZ, VCORIOLISTERM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) OMEGA3(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) VCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) EPSIL
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      CHARACTER(512) MSGBUF
      REAL(w2f__8) ONETHIRD
      EXTERNAL print_error
      REAL(w2f__8) TMPFAC
      REAL(w2f__8) UBARXY
      REAL(w2f__8) UBARYM
      REAL(w2f__8) UBARYP
      LOGICAL(w2f__i4) UPWINDVORT3
      PARAMETER ( UPWINDVORT3 = .FALSE.)
      REAL(w2f__8) VORT3IJ
      REAL(w2f__8) VORT3IM
      REAL(w2f__8) VORT3PJ
      REAL(w2f__8) VORT3PM
      REAL(w2f__8) VORT3V
C
C     **** Statements ****
C
      EPSIL = 1.00000000000000006228D-09
      TMPFAC = 1.0D00
      ONETHIRD = 3.3333333333333331483D-01
      IF(SELECTVORTSCHEME .eq. 0) THEN
        DO J = -1, 43, 1
          DO I = -2, 92, 1
            UBARXY = ((HFACW(I, J, K, BI, BJ) * UFLD(I, J) * DYG(I, J,
     >  BI, BJ) + HFACW(I, J + (-1), K, BI, BJ) * UFLD(I, J + (-1)) *
     >  DYG(I, J + (-1), BI, BJ)) +(HFACW(I + 1, J, K, BI, BJ) * UFLD(I
     >  + 1, J) * DYG(I + 1, J, BI, BJ) + HFACW(I + 1, J + (-1), K, BI,
     >  BJ) * UFLD(I + 1, J + (-1)) * DYG(I + 1, J + (-1), BI, BJ))) *
     >  2.5D-01
            IF(.FALSE.) THEN
              IF(UBARXY .GT. 0.0D00) THEN
                VORT3V = OMEGA3(I, J) * R_HFACZ(I, J)
              ELSE
                VORT3V = OMEGA3(I + 1, J) * R_HFACZ(I + 1, J)
              ENDIF
            ELSE
              VORT3V = (OMEGA3(I, J) * R_HFACZ(I, J) + OMEGA3(I + 1, J)
     >  * R_HFACZ(I + 1, J)) * 5.0D-01
            ENDIF
            VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) * RECIP_DYC
     > (I, J, BI, BJ) * UBARXY * VORT3V))
          END DO
        END DO
      ELSE
        IF(SELECTVORTSCHEME .eq. 1) THEN
          DO J = -1, 43, 1
            DO I = -2, 92, 1
              UBARXY = (((HFACZ(I, J) * UFLD(I, J) * DYG(I, J, BI, BJ)
     >  + HFACZ(I, J) * UFLD(I, J + (-1)) * DYG(I, J + (-1), BI, BJ)) +
     > (HFACZ(I + 1, J) * UFLD(I + 1, J) * DYG(I + 1, J, BI, BJ) +
     >  HFACZ(I + 1, J) * UFLD(I + 1, J + (-1)) * DYG(I + 1, J + (-1),
     >  BI, BJ))) * 5.0D-01) / MAX(EPSIL, HFACZ(I, J) + HFACZ(I + 1, J)
     > )
              IF(.FALSE.) THEN
                IF(UBARXY .GT. 0.0D00) THEN
                  VORT3V = OMEGA3(I, J)
                ELSE
                  VORT3V = OMEGA3(I + 1, J)
                ENDIF
              ELSE
                VORT3V = (OMEGA3(I, J) + OMEGA3(I + 1, J)) * 5.0D-01
              ENDIF
              VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) *
     >  RECIP_DYC(I, J, BI, BJ) * UBARXY * VORT3V))
            END DO
          END DO
        ELSE
          IF(SELECTVORTSCHEME .eq. 2) THEN
            DO J = -1, 43, 1
              DO I = -2, 92, 1
                UBARYM = (HFACW(I, J, K, BI, BJ) * UFLD(I, J) * DYG(I,
     >  J, BI, BJ) + HFACW(I, J + (-1), K, BI, BJ) * UFLD(I, J + (-1))
     >  * DYG(I, J + (-1), BI, BJ)) * 5.0D-01
                UBARYP = (HFACW(I + 1, J, K, BI, BJ) * UFLD(I + 1, J) *
     >  DYG(I + 1, J, BI, BJ) + HFACW(I + 1, J + (-1), K, BI, BJ) *
     >  UFLD(I + 1, J + (-1)) * DYG(I + 1, J + (-1), BI, BJ)) * 5.0D-01
                IF(.FALSE.) THEN
                  IF((UBARYM + UBARYP) .GT. 0.0D00) THEN
                    VORT3V = OMEGA3(I, J) * R_HFACZ(I, J) * UBARYM
                  ELSE
                    VORT3V = OMEGA3(I + 1, J) * R_HFACZ(I + 1, J) *
     >  UBARYP
                  ENDIF
                ELSE
                  VORT3V = (OMEGA3(I, J) * R_HFACZ(I, J) * UBARYM +
     >  OMEGA3(I + 1, J) * R_HFACZ(I + 1, J) * UBARYP) * 5.0D-01
                ENDIF
                VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) *
     >  RECIP_DYC(I, J, BI, BJ) * VORT3V))
              END DO
            END DO
          ELSE
            IF(SELECTVORTSCHEME .eq. 3) THEN
              DO J = -1, 42, 1
                DO I = -2, 92, 1
                  VORT3IM = HFACW(I, J + (-1), K, BI, BJ) * DYG(I, J +
     >  (-1), BI, BJ) * UFLD(I, J + (-1)) * ONETHIRD *(OMEGA3(I, J) *
     >  R_HFACZ(I, J) +(OMEGA3(I + 1, J) * R_HFACZ(I + 1, J) + OMEGA3(I
     > , J + (-1)) * R_HFACZ(I, J + (-1))))
                  VORT3IJ = HFACW(I, J, K, BI, BJ) * DYG(I, J, BI, BJ)
     >  * UFLD(I, J) * ONETHIRD *(OMEGA3(I, J) * R_HFACZ(I, J) +(OMEGA3
     > (I + 1, J) * R_HFACZ(I + 1, J) + OMEGA3(I, J + 1) * R_HFACZ(I, J
     >  + 1)))
                  VORT3PM = HFACW(I + 1, J + (-1), K, BI, BJ) * DYG(I +
     >  1, J + (-1), BI, BJ) * UFLD(I + 1, J + (-1)) * ONETHIRD *(
     > OMEGA3(I + 1, J) * R_HFACZ(I + 1, J) +(OMEGA3(I, J) * R_HFACZ(I,
     >  J) + OMEGA3(I + 1, J + (-1)) * R_HFACZ(I + 1, J + (-1))))
                  VORT3PJ = HFACW(I + 1, J, K, BI, BJ) * DYG(I + 1, J,
     >  BI, BJ) * UFLD(I + 1, J) * ONETHIRD *(OMEGA3(I + 1, J) *
     >  R_HFACZ(I + 1, J) +(OMEGA3(I, J) * R_HFACZ(I, J) + OMEGA3(I + 1
     > , J + 1) * R_HFACZ(I + 1, J + 1)))
                  VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) *
     >  RECIP_DYC(I, J, BI, BJ) *((VORT3IJ + VORT3IM) +(VORT3PJ +
     >  VORT3PM)) * 2.5D-01))
                END DO
              END DO
            ELSE
              WRITE(MSGBUF, '(A,I5,A)')
     >  'MOM_VI_V_CORIOLIS: selectVortScheme=', SELECTVORTSCHEME,
     >  ' not implemented'
              CALL print_error(MSGBUF, MYTHID)
              WRITE(*, *) 'ABNORMAL END: S/R MOM_VI_V_CORIOLIS'
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      IF(USEJAMARTMOMADV) THEN
        DO J = -1, 42, 1
          DO I = -2, 92, 1
            VCORIOLISTERM(I, J) = ((HFACS(I, J, K, BI, BJ) *
     >  VCORIOLISTERM(I, J) * 4.0D00) / MAX(EPSIL, (HFACW(I, J, K, BI,
     >  BJ) + HFACW(I, J + (-1), K, BI, BJ)) +(HFACW(I + 1, J, K, BI,
     >  BJ) + HFACW(I + 1, J + (-1), K, BI, BJ))))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_v_coriolis_c4(BI, BJ, K, UFLD, OMEGA3, R_HFACZ,
     >  VCORIOLISTERM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) OMEGA3(-2 : 93, -2 : 43)
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) VCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      LOGICAL(w2f__i4) FOURTHVORT3
      PARAMETER ( FOURTHVORT3 = .TRUE.)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      CHARACTER(512) MSGBUF
      INTEGER(w2f__i4) MYFACE
      LOGICAL(w2f__i4) NORTHEASTCORNER
      LOGICAL(w2f__i4) NORTHWESTCORNER
      REAL(w2f__8) ONESIXTH
      PARAMETER ( ONESIXTH = 1.66666666666666657415D-01)
      REAL(w2f__8) ONETWELVE
      PARAMETER ( ONETWELVE = 8.33333333333333287074D-02)
      EXTERNAL print_error
      REAL(w2f__8) RJM
      REAL(w2f__8) RJP
      LOGICAL(w2f__i4) SOUTHEASTCORNER
      LOGICAL(w2f__i4) SOUTHWESTCORNER
      REAL(w2f__8) UBARXY
      REAL(w2f__8) UBARYM
      REAL(w2f__8) UBARYP
      REAL(w2f__8) VORT3R(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3V
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          VORT3R(I, J) = (OMEGA3(I, J) * R_HFACZ(I, J))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE .AND. HIGHORDERVORTICITY) THEN
        MYFACE = BI
        SOUTHWESTCORNER = .TRUE.
        SOUTHEASTCORNER = .TRUE.
        NORTHWESTCORNER = .TRUE.
        NORTHEASTCORNER = .TRUE.
        IF(SOUTHWESTCORNER) THEN
          I = 1
          J = 1
          VORT3R(I + (-1), J) = ((VORT3R(I + (-1), J) + VORT3R(I, J + 1
     > )) * 5.0D-01)
        ENDIF
        IF(SOUTHEASTCORNER) THEN
          I = 91
          J = 1
          VORT3R(I + 1, J) = ((VORT3R(I + 1, J) + VORT3R(I, J + 1)) *
     >  5.0D-01)
        ENDIF
        IF(NORTHWESTCORNER) THEN
          I = 1
          J = 41
          VORT3R(I + (-1), J) = ((VORT3R(I + (-1), J) + VORT3R(I, J + (
     > -1))) * 5.0D-01)
        ENDIF
        IF(NORTHEASTCORNER) THEN
          I = 91
          J = 41
          VORT3R(I + 1, J) = ((VORT3R(I + 1, J) + VORT3R(I, J + (-1)))
     >  * 5.0D-01)
        ENDIF
      ENDIF
      IF(SELECTVORTSCHEME .eq. 0) THEN
        DO J = 1, 41, 1
          DO I = 1, 90, 1
            UBARXY = ((HFACW(I, J, K, BI, BJ) * UFLD(I, J) * DYG(I, J,
     >  BI, BJ) + HFACW(I, J + (-1), K, BI, BJ) * UFLD(I, J + (-1)) *
     >  DYG(I, J + (-1), BI, BJ)) +(HFACW(I + 1, J, K, BI, BJ) * UFLD(I
     >  + 1, J) * DYG(I + 1, J, BI, BJ) + HFACW(I + 1, J + (-1), K, BI,
     >  BJ) * UFLD(I + 1, J + (-1)) * DYG(I + 1, J + (-1), BI, BJ))) *
     >  2.5D-01
            IF(UPWINDVORTICITY) THEN
              IF(UBARXY .GT. 0.0D00) THEN
                VORT3V = VORT3R(I, J)
              ELSE
                VORT3V = VORT3R(I + 1, J)
              ENDIF
            ELSE
              IF(.TRUE.) THEN
                RJP = VORT3R(I + 2, J) - VORT3R(I + 1, J)
                RJM = VORT3R(I, J) - VORT3R(I + (-1), J)
                VORT3V = (VORT3R(I, J) + VORT3R(I + 1, J) -(RJP - RJM)
     >  * 8.33333333333333287074D-02) * 5.0D-01
              ELSE
                VORT3V = (VORT3R(I, J) + VORT3R(I + 1, J)) * 5.0D-01
              ENDIF
            ENDIF
            VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) * RECIP_DYC
     > (I, J, BI, BJ) * UBARXY * VORT3V))
          END DO
        END DO
      ELSE
        IF(SELECTVORTSCHEME .eq. 2) THEN
          DO J = 1, 41, 1
            DO I = 1, 90, 1
              UBARYM = (HFACW(I, J, K, BI, BJ) * UFLD(I, J) * DYG(I, J,
     >  BI, BJ) + HFACW(I, J + (-1), K, BI, BJ) * UFLD(I, J + (-1)) *
     >  DYG(I, J + (-1), BI, BJ)) * 5.0D-01
              UBARYP = (HFACW(I + 1, J, K, BI, BJ) * UFLD(I + 1, J) *
     >  DYG(I + 1, J, BI, BJ) + HFACW(I + 1, J + (-1), K, BI, BJ) *
     >  UFLD(I + 1, J + (-1)) * DYG(I + 1, J + (-1), BI, BJ)) * 5.0D-01
              IF(UPWINDVORTICITY) THEN
                IF((UBARYM + UBARYP) .GT. 0.0D00) THEN
                  VORT3V = VORT3R(I, J) * UBARYM
                ELSE
                  VORT3V = VORT3R(I + 1, J) * UBARYP
                ENDIF
              ELSE
                IF(.TRUE.) THEN
                  RJP = VORT3R(I + 1, J) -(VORT3R(I + 2, J) - VORT3R(I,
     >  J)) * 1.66666666666666657415D-01
                  RJM = VORT3R(I, J) +(VORT3R(I + 1, J) - VORT3R(I + (
     > -1), J)) * 1.66666666666666657415D-01
                  VORT3V = (RJM * UBARYM + RJP * UBARYP) * 5.0D-01
                ELSE
                  VORT3V = (VORT3R(I, J) * UBARYM + VORT3R(I + 1, J) *
     >  UBARYP) * 5.0D-01
                ENDIF
              ENDIF
              VCORIOLISTERM(I, J) = (-(MASKS(I, J, K, BI, BJ) *
     >  RECIP_DYC(I, J, BI, BJ) * VORT3V))
            END DO
          END DO
        ELSE
          WRITE(MSGBUF, '(A,I5,A)')
     >  'MOM_VI_V_CORIOLIS_C4: selectVortScheme=', SELECTVORTSCHEME,
     >  ' not implemented'
          CALL print_error(MSGBUF, MYTHID)
          WRITE(*, *) 'ABNORMAL END: S/R MOM_VI_V_CORIOLIS_C4'
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_v_grad_ke(BI, BJ, K, KE, DKEDY, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      REAL(w2f__8) DKEDY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          DKEDY(I, J) = (-(MASKS(I, J, K, BI, BJ) * RECIP_DYC(I, J, BI,
     >  BJ) *(KE(I, J) - KE(I, J + (-1)))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_vi_v_vertshear(BI, BJ, K, VFLD, WFLD, VSHEARTERM,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VSHEARTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) MASK_KM1
      REAL(w2f__8) MASK_KP1
      LOGICAL(w2f__i4) RADVAREAWEIGHT
      REAL(w2f__8) VZM
      REAL(w2f__8) VZP
      REAL(w2f__8) WBARYM
      REAL(w2f__8) WBARYP
C
C     **** Statements ****
C
      RADVAREAWEIGHT = .TRUE.
      IF((SELECTKESCHEME .eq. 1) .OR.(SELECTKESCHEME .eq. 3)) THEN
        RADVAREAWEIGHT = .FALSE.
      ENDIF
      KP1 = MIN(K + 1, 15)
      MASK_KP1 = 1.0D00
      IF(K .eq. 15) THEN
        MASK_KP1 = 0.0D00
      ENDIF
      KM1 = MAX(K +(-1), 1)
      MASK_KM1 = 1.0D00
      IF(K .eq. 1) THEN
        MASK_KM1 = 0.0D00
      ENDIF
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          IF(RADVAREAWEIGHT) THEN
            WBARYM = RECIP_RAS(I, J, BI, BJ) * MASK_KM1 *(MASKC(I, J,
     >  KM1, BI, BJ) * RA(I, J, BI, BJ) * WFLD(I, J, K, BI, BJ) + MASKC
     > (I, J + (-1), KM1, BI, BJ) * RA(I, J + (-1), BI, BJ) * WFLD(I, J
     >  + (-1), K, BI, BJ)) * 5.0D-01
            WBARYP = RECIP_RAS(I, J, BI, BJ) * MASK_KP1 *(RA(I, J, BI,
     >  BJ) * WFLD(I, J, KP1, BI, BJ) + RA(I, J + (-1), BI, BJ) * WFLD(
     > I, J + (-1), KP1, BI, BJ)) * 5.0D-01
          ELSE
            WBARYM = MASK_KM1 *(WFLD(I, J, K, BI, BJ) * MASKC(I, J, KM1
     > , BI, BJ) + WFLD(I, J + (-1), K, BI, BJ) * MASKC(I, J + (-1),
     >  KM1, BI, BJ)) * 5.0D-01
            WBARYP = MASK_KP1 *(WFLD(I, J, KP1, BI, BJ) + WFLD(I, J + (
     > -1), KP1, BI, BJ)) * 5.0D-01
          ENDIF
          VZM = RKSIGN *(VFLD(I, J, K, BI, BJ) - VFLD(I, J, KM1, BI, BJ
     > ) * MASK_KM1)
          VZP = RKSIGN *(VFLD(I, J, KP1, BI, BJ) * MASK_KP1 - VFLD(I, J
     > , K, BI, BJ))
          IF(UPWINDSHEAR) THEN
            VSHEARTERM(I, J) = (-(RECIP_DRF(K) * RECIP_HFACS(I, J, K,
     >  BI, BJ) *((VZM * WBARYM + VZP * WBARYP) +(VZP * ABS(WBARYP) -
     >  VZM * ABS(WBARYM))) * 5.0D-01))
          ELSE
            VSHEARTERM(I, J) = (-(RECIP_DRF(K) * RECIP_HFACS(I, J, K,
     >  BI, BJ) *(VZM * WBARYM + VZP * WBARYP) * 5.0D-01))
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE read_fld_xyz_rs(PREF, SUFF, FIELD, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) PREF
      CHARACTER(*) SUFF
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      CHARACTER(512) FULLNAME
      EXTERNAL ifnblnk
      INTEGER(w2f__i4) ifnblnk
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IREC
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      INTEGER(w2f__i4) S1HI
      INTEGER(w2f__i4) S1LO
      INTEGER(w2f__i4) S2HI
      INTEGER(w2f__i4) S2LO
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      S1LO = ifnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      S1HI = ilnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      IF(SUFF(1_w2f__i8 : INT(LEN(SUFF))) .EQ. ' ') THEN
        WRITE(FULLNAME, '(A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1))
      ELSE
        S2LO = ifnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        S2HI = ilnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        WRITE(FULLNAME, '(A,A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1)), SUFF((S2LO) : ((S2LO) - 1_w2f__i8) + (S2HI -
     >  S2LO + 1))
      ENDIF
      USECURRENTDIR = .FALSE.
      FTYPE = 'RS'
      NNZ = 15
      IREC = 1
      CALL mds_read_field(FULLNAME, READBINARYPREC, USECURRENTDIR,
     >  FTYPE, NNZ, (1), NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_fld_xyz_rl(PREF, SUFF, FIELD, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) PREF
      CHARACTER(*) SUFF
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      CHARACTER(512) FULLNAME
      EXTERNAL ifnblnk
      INTEGER(w2f__i4) ifnblnk
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IREC
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      INTEGER(w2f__i4) S1HI
      INTEGER(w2f__i4) S1LO
      INTEGER(w2f__i4) S2HI
      INTEGER(w2f__i4) S2LO
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      S1LO = ifnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      S1HI = ilnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      IF(SUFF(1_w2f__i8 : INT(LEN(SUFF))) .EQ. ' ') THEN
        WRITE(FULLNAME, '(A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1))
      ELSE
        S2LO = ifnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        S2HI = ilnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        WRITE(FULLNAME, '(A,A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1)), SUFF((S2LO) : ((S2LO) - 1_w2f__i8) + (S2HI -
     >  S2LO + 1))
      ENDIF
      USECURRENTDIR = .FALSE.
      FTYPE = 'RL'
      NNZ = 15
      IREC = 1
      CALL mds_read_field(FULLNAME, READBINARYPREC, USECURRENTDIR,
     >  FTYPE, NNZ, (1), NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_fld_xy_rs(PREF, SUFF, FIELD, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) PREF
      CHARACTER(*) SUFF
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      CHARACTER(512) FULLNAME
      EXTERNAL ifnblnk
      INTEGER(w2f__i4) ifnblnk
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IREC
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      INTEGER(w2f__i4) S1HI
      INTEGER(w2f__i4) S1LO
      INTEGER(w2f__i4) S2HI
      INTEGER(w2f__i4) S2LO
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      S1LO = ifnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      S1HI = ilnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      IF(SUFF(1_w2f__i8 : INT(LEN(SUFF))) .EQ. ' ') THEN
        WRITE(FULLNAME, '(A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1))
      ELSE
        S2LO = ifnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        S2HI = ilnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        WRITE(FULLNAME, '(A,A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1)), SUFF((S2LO) : ((S2LO) - 1_w2f__i8) + (S2HI -
     >  S2LO + 1))
      ENDIF
      USECURRENTDIR = .FALSE.
      FTYPE = 'RS'
      NNZ = 1
      IREC = 1
      CALL mds_read_field(FULLNAME, READBINARYPREC, USECURRENTDIR,
     >  FTYPE, NNZ, (1), NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_fld_xy_rl(PREF, SUFF, FIELD, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) PREF
      CHARACTER(*) SUFF
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      CHARACTER(512) FULLNAME
      EXTERNAL ifnblnk
      INTEGER(w2f__i4) ifnblnk
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IREC
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      INTEGER(w2f__i4) S1HI
      INTEGER(w2f__i4) S1LO
      INTEGER(w2f__i4) S2HI
      INTEGER(w2f__i4) S2LO
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      S1LO = ifnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      S1HI = ilnblnk(PREF(1_w2f__i8 : INT(LEN(PREF))))
      IF(SUFF(1_w2f__i8 : INT(LEN(SUFF))) .EQ. ' ') THEN
        WRITE(FULLNAME, '(A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1))
      ELSE
        S2LO = ifnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        S2HI = ilnblnk(SUFF(1_w2f__i8 : INT(LEN(SUFF))))
        WRITE(FULLNAME, '(A,A)') PREF((S1LO) : ((S1LO) - 1_w2f__i8) + (
     > S1HI - S1LO + 1)), SUFF((S2LO) : ((S2LO) - 1_w2f__i8) + (S2HI -
     >  S2LO + 1))
      ENDIF
      USECURRENTDIR = .FALSE.
      FTYPE = 'RL'
      NNZ = 1
      IREC = 1
      CALL mds_read_field(FULLNAME, READBINARYPREC, USECURRENTDIR,
     >  FTYPE, NNZ, (1), NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_xy_rs(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RS'
      NNZ = 1
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, USECURRENTDIR, FTYPE, NNZ, (1), NNZ, FIELD,
     >  IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_xy_rl(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RL'
      NNZ = 1
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, USECURRENTDIR, FTYPE, NNZ, (1), NNZ, FIELD,
     >  IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_xyz_rs(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RS'
      NNZ = 15
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, USECURRENTDIR, FTYPE, NNZ, (1), NNZ, FIELD,
     >  IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_xyz_rl(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      INTEGER(w2f__i4) NNZ
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RL'
      NNZ = 15
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, USECURRENTDIR, FTYPE, NNZ, (1), NNZ, FIELD,
     >  IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_3d_rs(FNAME, FPREC, NNZ, FIELD, IREC, MYITER,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      INTEGER(w2f__i4) FPREC
      INTEGER(w2f__i4) NNZ
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : NNZ, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RS'
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))), FPREC,
     >  USECURRENTDIR, FTYPE, NNZ, (1), NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_3d_rl(FNAME, FPREC, NNZ, FIELD, IREC, MYITER,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      INTEGER(w2f__i4) FPREC
      INTEGER(w2f__i4) NNZ
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : NNZ, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RL'
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))), FPREC,
     >  USECURRENTDIR, FTYPE, NNZ, (1), NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_lev_rs(FNAME, FPREC, KSIZ, KLO, KHI, FIELD,
     >  IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      INTEGER(w2f__i4) FPREC
      INTEGER(w2f__i4) KSIZ
      INTEGER(w2f__i4) KLO
      INTEGER(w2f__i4) KHI
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : KSIZ, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RS'
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))), FPREC,
     >  USECURRENTDIR, FTYPE, KSIZ, KLO, KHI, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_lev_rl(FNAME, FPREC, KSIZ, KLO, KHI, FIELD,
     >  IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      INTEGER(w2f__i4) FPREC
      INTEGER(w2f__i4) KSIZ
      INTEGER(w2f__i4) KLO
      INTEGER(w2f__i4) KHI
      REAL(w2f__8) FIELD(-2 : 93, -2 : 43, 1 : KSIZ, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mds_read_field
      LOGICAL(w2f__i4) USECURRENTDIR
C
C     **** Statements ****
C
      USECURRENTDIR = .FALSE.
      FTYPE = 'RL'
      CALL mds_read_field(FNAME(1_w2f__i8 : INT(LEN(FNAME))), FPREC,
     >  USECURRENTDIR, FTYPE, KSIZ, KLO, KHI, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_xz_rs(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 93, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mdsreadfieldxz
      INTEGER(w2f__i4) NNZ
C
C     **** Statements ****
C
      FTYPE = 'RS'
      NNZ = 15
      CALL mdsreadfieldxz(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, FTYPE, NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_xz_rl(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 93, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mdsreadfieldxz
      INTEGER(w2f__i4) NNZ
C
C     **** Statements ****
C
      FTYPE = 'RL'
      NNZ = 15
      CALL mdsreadfieldxz(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, FTYPE, NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_yz_rs(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mdsreadfieldyz
      INTEGER(w2f__i4) NNZ
C
C     **** Statements ****
C
      FTYPE = 'RS'
      NNZ = 15
      CALL mdsreadfieldyz(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, FTYPE, NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE read_rec_yz_rl(FNAME, FIELD, IREC, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      CHARACTER(*) FNAME
      REAL(w2f__8) FIELD(-2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) IREC
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      CHARACTER(2) FTYPE
      EXTERNAL mdsreadfieldyz
      INTEGER(w2f__i4) NNZ
C
C     **** Statements ****
C
      FTYPE = 'RL'
      NNZ = 15
      CALL mdsreadfieldyz(FNAME(1_w2f__i8 : INT(LEN(FNAME))),
     >  READBINARYPREC, FTYPE, NNZ, FIELD, IREC, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_absvort3(BI, BJ, K, VORT3, OMEGA3, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      REAL(w2f__8) OMEGA3(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) NONLINFAC
      REAL(w2f__8) USECORIOLISFAC
C
C     **** Statements ****
C
      IF(MOMADVECTION) THEN
        NONLINFAC = 1.0D00
      ELSE
        NONLINFAC = 0.0D00
      ENDIF
      IF(USECORIOLIS) THEN
        USECORIOLISFAC = 1.0D00
      ELSE
        USECORIOLISFAC = 0.0D00
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          OMEGA3(I, J) = (VORT3(I, J) * NONLINFAC + FCORIG(I, J, BI, BJ
     > ) * USECORIOLISFAC)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_hdiv(BI, BJ, K, HDIVSCHEME, UFLD, VFLD, HDIV,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) HDIVSCHEME
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) HDIV(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(HDIVSCHEME .eq. 1) THEN
        DO J = -2, 42, 1
          DO I = -2, 92, 1
            HDIV(I, J) = (RECIP_RA(I, J, BI, BJ) *(VFLD(I, J + 1) * DXG
     > (I, J + 1, BI, BJ) + UFLD(I + 1, J) * DYG(I + 1, J, BI, BJ) -
     >  UFLD(I, J) * DYG(I, J, BI, BJ) - VFLD(I, J) * DXG(I, J, BI, BJ)
     > ))
          END DO
        END DO
      ELSE
        IF(HDIVSCHEME .eq. 2) THEN
          DO J = -2, 42, 1
            DO I = -2, 92, 1
              HDIV(I, J) = (RECIP_HFACC(I, J, K, BI, BJ) * RECIP_RA(I,
     >  J, BI, BJ) *((HFACS(I, J + 1, K, BI, BJ) * VFLD(I, J + 1) * DXG
     > (I, J + 1, BI, BJ) - HFACS(I, J, K, BI, BJ) * VFLD(I, J) * DXG(I
     > , J, BI, BJ)) +(HFACW(I + 1, J, K, BI, BJ) * UFLD(I + 1, J) *
     >  DYG(I + 1, J, BI, BJ) - HFACW(I, J, K, BI, BJ) * UFLD(I, J) *
     >  DYG(I, J, BI, BJ))))
            END DO
          END DO
        ELSE
          WRITE(*, *)
     >  'S/R MOM_CALC_HDIV: We should never reach this po' // 'int!'
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_hfacz(BI, BJ, K, HFACZ, R_HFACZ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) R_HFACZ(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) HFACZOPEN
      INTEGER(w2f__i4) HZOPTION
      PARAMETER ( HZOPTION = 0)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) MYFACE
      LOGICAL(w2f__i4) NORTHEASTCORNER
      LOGICAL(w2f__i4) NORTHWESTCORNER
      LOGICAL(w2f__i4) SOUTHEASTCORNER
      LOGICAL(w2f__i4) SOUTHWESTCORNER
C
C     **** Statements ****
C
      DO I = -2, 93, 1
        HFACZ(I, (-2)) = 0.0D00
      END DO
      DO J = -1, 43, 1
        HFACZ((-2), J) = 0.0D00
      END DO
      IF(.FALSE.) THEN
        DO J = -1, 43, 1
          DO I = -1, 93, 1
            HFACZOPEN = (HFACS(I, J, K, BI, BJ) + HFACS(I + (-1), J, K,
     >  BI, BJ)) +(HFACW(I, J, K, BI, BJ) + HFACW(I, J + (-1), K, BI,
     >  BJ))
            HFACZ(I, J) = (HFACZOPEN * 2.5D-01)
          END DO
        END DO
      ELSE
        IF(.FALSE.) THEN
          DO J = -1, 43, 1
            DO I = -1, 93, 1
              HFACZOPEN = MIN(HFACS(I, J, K, BI, BJ) + HFACS(I + (-1),
     >  J, K, BI, BJ), HFACW(I, J, K, BI, BJ) + HFACW(I, J + (-1), K,
     >  BI, BJ))
              HFACZ(I, J) = (HFACZOPEN * 5.0D-01)
            END DO
          END DO
        ELSE
          DO J = -1, 43, 1
            DO I = -1, 93, 1
              HFACZOPEN = MIN(HFACW(I, J, K, BI, BJ), HFACW(I, J + (-1)
     > , K, BI, BJ))
              HFACZOPEN = MIN(HFACS(I, J, K, BI, BJ), HFACZOPEN)
              HFACZOPEN = MIN(HFACS(I + (-1), J, K, BI, BJ), HFACZOPEN)
              HFACZ(I, J) = HFACZOPEN
            END DO
          END DO
        ENDIF
      ENDIF
      IF(.FALSE.) THEN
        MYFACE = BI
        SOUTHWESTCORNER = .TRUE.
        SOUTHEASTCORNER = .TRUE.
        NORTHWESTCORNER = .TRUE.
        NORTHEASTCORNER = .TRUE.
        IF(SOUTHWESTCORNER) THEN
          I = 1
          J = 1
          IF(.FALSE.) THEN
            HFACZOPEN = MIN(HFACW(I, J, K, BI, BJ), HFACW(I, J + (-1),
     >  K, BI, BJ))
            HFACZOPEN = MIN(HFACS(I, J, K, BI, BJ), HFACZOPEN)
            HFACZ(I, J) = HFACZOPEN
          ELSE
            IF(MOD(MYFACE, 2) .eq. 1) THEN
              HFACZOPEN = HFACW(I, J, K, BI, BJ) +(HFACS(I, J, K, BI,
     >  BJ) + HFACW(I, J + (-1), K, BI, BJ))
            ELSE
              HFACZOPEN = HFACS(I, J, K, BI, BJ) +(HFACW(I, J, K, BI,
     >  BJ) + HFACW(I, J + (-1), K, BI, BJ))
            ENDIF
            HFACZ(I, J) = (HFACZOPEN / 3.0D00)
          ENDIF
        ENDIF
        IF(SOUTHEASTCORNER) THEN
          I = 91
          J = 1
          IF(.FALSE.) THEN
            HFACZOPEN = MIN(HFACW(I, J, K, BI, BJ), HFACW(I, J + (-1),
     >  K, BI, BJ))
            HFACZOPEN = MIN(HFACS(I + (-1), J, K, BI, BJ), HFACZOPEN)
            HFACZ(I, J) = HFACZOPEN
          ELSE
            IF(MYFACE .eq. 4) THEN
              HFACZOPEN = HFACW(I, J, K, BI, BJ) +(HFACS(I + (-1), J, K
     > , BI, BJ) + HFACW(I, J + (-1), K, BI, BJ))
            ELSE
              IF(MYFACE .eq. 6) THEN
                HFACZOPEN = HFACS(I + (-1), J, K, BI, BJ) +(HFACW(I, J,
     >  K, BI, BJ) + HFACW(I, J + (-1), K, BI, BJ))
              ELSE
                HFACZOPEN = HFACW(I, J + (-1), K, BI, BJ) +(HFACS(I + (
     > -1), J, K, BI, BJ) + HFACW(I, J, K, BI, BJ))
              ENDIF
            ENDIF
            HFACZ(I, J) = (HFACZOPEN / 3.0D00)
          ENDIF
        ENDIF
        IF(NORTHWESTCORNER) THEN
          I = 1
          J = 41
          IF(.FALSE.) THEN
            HFACZOPEN = MIN(HFACW(I, J, K, BI, BJ), HFACW(I, J + (-1),
     >  K, BI, BJ))
            HFACZOPEN = MIN(HFACS(I, J, K, BI, BJ), HFACZOPEN)
            HFACZ(I, J) = HFACZOPEN
          ELSE
            IF(MYFACE .eq. 1) THEN
              HFACZOPEN = HFACW(I, J + (-1), K, BI, BJ) +(HFACS(I, J, K
     > , BI, BJ) + HFACW(I, J, K, BI, BJ))
            ELSE
              IF(MYFACE .eq. 5) THEN
                HFACZOPEN = HFACS(I, J, K, BI, BJ) +(HFACW(I, J, K, BI,
     >  BJ) + HFACW(I, J + (-1), K, BI, BJ))
              ELSE
                HFACZOPEN = HFACW(I, J, K, BI, BJ) +(HFACS(I, J, K, BI,
     >  BJ) + HFACW(I, J + (-1), K, BI, BJ))
              ENDIF
            ENDIF
            HFACZ(I, J) = (HFACZOPEN / 3.0D00)
          ENDIF
        ENDIF
        IF(NORTHEASTCORNER) THEN
          I = 91
          J = 41
          IF(.FALSE.) THEN
            HFACZOPEN = MIN(HFACW(I, J, K, BI, BJ), HFACW(I, J + (-1),
     >  K, BI, BJ))
            HFACZOPEN = MIN(HFACS(I + (-1), J, K, BI, BJ), HFACZOPEN)
            HFACZ(I, J) = HFACZOPEN
          ELSE
            IF(MOD(MYFACE, 2) .eq. 1) THEN
              HFACZOPEN = HFACS(I + (-1), J, K, BI, BJ) +(HFACW(I, J, K
     > , BI, BJ) + HFACW(I, J + (-1), K, BI, BJ))
            ELSE
              HFACZOPEN = HFACW(I, J + (-1), K, BI, BJ) +(HFACS(I + (-1
     > ), J, K, BI, BJ) + HFACW(I, J, K, BI, BJ))
            ENDIF
            HFACZ(I, J) = (HFACZOPEN / 3.0D00)
          ENDIF
        ENDIF
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          IF(HFACZ(I, J) .eq. 0.0D00) THEN
            R_HFACZ(I, J) = 0.0D00
          ELSE
            R_HFACZ(I, J) = 1D00 / (HFACZ(I, J))
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_ke(BI, BJ, K, KESCHEME, UFLD, VFLD, KE,
     >  MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KESCHEME
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(KESCHEME .eq.(-1)) THEN
        DO J = -2, 42, 1
          DO I = -2, 92, 1
            KE(I, J) = ((((UFLD(I, J) + UFLD(I + 1, J)) ** 2) +((VFLD(I
     > , J) + VFLD(I, J + 1)) ** 2)) * 1.25D-01)
          END DO
        END DO
      ELSE
        IF(KESCHEME .eq. 0) THEN
          DO J = -2, 42, 1
            DO I = -2, 92, 1
              KE(I, J) = (((UFLD(I, J) * UFLD(I, J) + UFLD(I + 1, J) *
     >  UFLD(I + 1, J)) +(VFLD(I, J) * VFLD(I, J) + VFLD(I, J + 1) *
     >  VFLD(I, J + 1))) * 2.5D-01)
            END DO
          END DO
        ELSE
          IF(KESCHEME .eq. 1) THEN
            DO J = -2, 42, 1
              DO I = -2, 92, 1
                KE(I, J) = (RECIP_RA(I, J, BI, BJ) *((RAS(I, J, BI, BJ)
     >  * VFLD(I, J) * VFLD(I, J) + RAS(I, J + 1, BI, BJ) * VFLD(I, J +
     >  1) * VFLD(I, J + 1)) +(RAW(I, J, BI, BJ) * UFLD(I, J) * UFLD(I,
     >  J) + RAW(I + 1, J, BI, BJ) * UFLD(I + 1, J) * UFLD(I + 1, J)))
     >  * 2.5D-01)
              END DO
            END DO
          ELSE
            IF(KESCHEME .eq. 2) THEN
              DO J = -2, 42, 1
                DO I = -2, 92, 1
                  KE(I, J) = (RECIP_HFACC(I, J, K, BI, BJ) *((HFACS(I,
     >  J, K, BI, BJ) * VFLD(I, J) * VFLD(I, J) + HFACS(I, J + 1, K, BI
     > , BJ) * VFLD(I, J + 1) * VFLD(I, J + 1)) +(HFACW(I, J, K, BI, BJ
     > ) * UFLD(I, J) * UFLD(I, J) + HFACW(I + 1, J, K, BI, BJ) * UFLD(
     > I + 1, J) * UFLD(I + 1, J))) * 2.5D-01)
                END DO
              END DO
            ELSE
              IF(KESCHEME .eq. 3) THEN
                DO J = -2, 42, 1
                  DO I = -2, 92, 1
                    KE(I, J) = (RECIP_RA(I, J, BI, BJ) * RECIP_HFACC(I,
     >  J, K, BI, BJ) *((RAS(I, J, BI, BJ) * HFACS(I, J, K, BI, BJ) *
     >  VFLD(I, J) * VFLD(I, J) + RAS(I, J + 1, BI, BJ) * HFACS(I, J +
     >  1, K, BI, BJ) * VFLD(I, J + 1) * VFLD(I, J + 1)) +(RAW(I, J, BI
     > , BJ) * HFACW(I, J, K, BI, BJ) * UFLD(I, J) * UFLD(I, J) + RAW(I
     >  + 1, J, BI, BJ) * HFACW(I + 1, J, K, BI, BJ) * UFLD(I + 1, J) *
     >  UFLD(I + 1, J))) * 2.5D-01)
                  END DO
                END DO
              ELSE
                WRITE(*, *)
     >  'S/R MOM_CALC_KE: We should never reach this poin' // 't!'
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_relvort3(BI, BJ, K, UFLD, VFLD, HFACZ, VORT3,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) MYFACE
      LOGICAL(w2f__i4) NORTHEASTCORNER
      LOGICAL(w2f__i4) NORTHWESTCORNER
      LOGICAL(w2f__i4) SOUTHEASTCORNER
      LOGICAL(w2f__i4) SOUTHWESTCORNER
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          VORT3(I, J) = 0.0D00
        END DO
      END DO
      DO J = -1, 43, 1
        DO I = -1, 93, 1
          VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *((VFLD(I, J) * DYC(I,
     >  J, BI, BJ) - VFLD(I + (-1), J) * DYC(I + (-1), J, BI, BJ)) -(
     > UFLD(I, J) * DXC(I, J, BI, BJ) - UFLD(I, J + (-1)) * DXC(I, J +
     >  (-1), BI, BJ))))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE) THEN
        MYFACE = BI
        SOUTHWESTCORNER = .TRUE.
        SOUTHEASTCORNER = .TRUE.
        NORTHWESTCORNER = .TRUE.
        NORTHEASTCORNER = .TRUE.
        IF(SOUTHWESTCORNER) THEN
          I = 1
          J = 1
          VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *(UFLD(I, J + (-1)) *
     >  DXC(I, J + (-1), BI, BJ) +(VFLD(I, J) * DYC(I, J, BI, BJ) -
     >  UFLD(I, J) * DXC(I, J, BI, BJ))))
        ENDIF
        IF(SOUTHEASTCORNER) THEN
          I = 91
          J = 1
          IF(MYFACE .eq. 2) THEN
            VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *(UFLD(I, J + (-1))
     >  * DXC(I, J + (-1), BI, BJ) +(-(UFLD(I, J) * DXC(I, J, BI, BJ) +
     >  VFLD(I + (-1), J) * DYC(I + (-1), J, BI, BJ)))))
          ELSE
            IF(MYFACE .eq. 4) THEN
              VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *((UFLD(I, J + (-1
     > )) * DXC(I, J + (-1), BI, BJ) - VFLD(I + (-1), J) * DYC(I + (-1)
     > , J, BI, BJ)) - UFLD(I, J) * DXC(I, J, BI, BJ)))
            ELSE
              VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *((UFLD(I, J + (-1
     > )) * DXC(I, J + (-1), BI, BJ) - UFLD(I, J) * DXC(I, J, BI, BJ))
     >  - VFLD(I + (-1), J) * DYC(I + (-1), J, BI, BJ)))
            ENDIF
          ENDIF
        ENDIF
        IF(NORTHWESTCORNER) THEN
          I = 1
          J = 41
          IF(MYFACE .eq. 1) THEN
            VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *((UFLD(I, J + (-1))
     >  * DXC(I, J + (-1), BI, BJ) + VFLD(I, J) * DYC(I, J, BI, BJ)) -
     >  UFLD(I, J) * DXC(I, J, BI, BJ)))
          ELSE
            IF(MYFACE .eq. 3) THEN
              VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *(VFLD(I, J) * DYC
     > (I, J, BI, BJ) +(UFLD(I, J + (-1)) * DXC(I, J + (-1), BI, BJ) -
     >  UFLD(I, J) * DXC(I, J, BI, BJ))))
            ELSE
              VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *(UFLD(I, J + (-1)
     > ) * DXC(I, J + (-1), BI, BJ) +(VFLD(I, J) * DYC(I, J, BI, BJ) -
     >  UFLD(I, J) * DXC(I, J, BI, BJ))))
            ENDIF
          ENDIF
        ENDIF
        IF(NORTHEASTCORNER) THEN
          I = 91
          J = 41
          IF(MOD(MYFACE, 2) .eq. 1) THEN
            VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *(UFLD(I, J + (-1))
     >  * DXC(I, J + (-1), BI, BJ) +(-(UFLD(I, J) * DXC(I, J, BI, BJ) +
     >  VFLD(I + (-1), J) * DYC(I + (-1), J, BI, BJ)))))
          ELSE
            VORT3(I, J) = (RECIP_RAZ(I, J, BI, BJ) *((UFLD(I, J + (-1))
     >  * DXC(I, J + (-1), BI, BJ) - UFLD(I, J) * DXC(I, J, BI, BJ)) -
     >  VFLD(I + (-1), J) * DYC(I + (-1), J, BI, BJ)))
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_strain(BI, BJ, K, UFLD, VFLD, HFACZ, STRAIN,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) STRAIN(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -1, 43, 1
        DO I = -1, 93, 1
          STRAIN(I, J) = (RECIP_RAZ(I, J, BI, BJ) *(UFLD(I, J) * DXC(I,
     >  J, BI, BJ) + VFLD(I, J) * DYC(I, J, BI, BJ) - VFLD(I + (-1), J)
     >  * DYC(I + (-1), J, BI, BJ) - UFLD(I, J + (-1)) * DXC(I, J + (-1
     > ), BI, BJ)))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE) THEN
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_tension(BI, BJ, K, UFLD, VFLD, TENSION,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) TENSION(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 42, 1
        DO I = -2, 92, 1
          TENSION(I, J) = (RECIP_RA(I, J, BI, BJ) *(VFLD(I, J) * DXG(I,
     >  J, BI, BJ) + UFLD(I + 1, J) * DYG(I + 1, J, BI, BJ) - UFLD(I, J
     > ) * DYG(I, J, BI, BJ) - VFLD(I, J + 1) * DXG(I, J + 1, BI, BJ)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_calc_visc(BI, BJ, K, VISCAH_Z, VISCAH_D, VISCA4_Z,
     >  VISCA4_D, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY, HDIV,
     >  VORT3, TENSION, STRAIN, KE, HFACZ, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_D(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_D(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) HARMONIC
      LOGICAL(w2f__i4) BIHARMONIC
      LOGICAL(w2f__i4) USEVARIABLEVISCOSITY
      REAL(w2f__8) HDIV(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      REAL(w2f__8) TENSION(-2 : 93, -2 : 43)
      REAL(w2f__8) STRAIN(-2 : 93, -2 : 43)
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) ALIN
      LOGICAL(w2f__i4) CALCLEITH
      LOGICAL(w2f__i4) CALCSMAG
      REAL(w2f__8) DIVDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DIVDY(-2 : 93, -2 : 43)
      EXTERNAL fill_cs_corner_tr_rl
      REAL(w2f__8) GRDDIV
      REAL(w2f__8) GRDVRT
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) KEZPT
      REAL(w2f__8) L2
      REAL(w2f__8) L2RDT
      REAL(w2f__8) L3
      REAL(w2f__8) L4
      REAL(w2f__8) L4RDT
      REAL(w2f__8) L5
      REAL(w2f__8) LEITH2FAC
      REAL(w2f__8) LEITH4FAC
      REAL(w2f__8) LEITHD2FAC
      REAL(w2f__8) LEITHD4FAC
      INTEGER(w2f__i4) LOCKEY_1
      INTEGER(w2f__i4) LOCKEY_2
      REAL(w2f__8) RECIP_DT
      REAL(w2f__8) SMAG2FAC
      REAL(w2f__8) SMAG4FAC
      REAL(w2f__8) U4SCL
      REAL(w2f__8) USCL
      REAL(w2f__8) VISCA4RE_MAX
      REAL(w2f__8) VISCA4_DLTH(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_DLTHD(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_DMAX(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_DMIN(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_DSMG(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_ZLTH(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_ZLTHD(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_ZMAX(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_ZMIN(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_ZSMG(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAHRE_MAX
      REAL(w2f__8) VISCAH_DLTH(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_DLTHD(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_DMAX(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_DMIN(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_DSMG(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_ZLTH(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_ZLTHD(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_ZMAX(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_ZMIN(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_ZSMG(-2 : 93, -2 : 43)
      REAL(w2f__8) VRTDX(-2 : 93, -2 : 43)
      REAL(w2f__8) VRTDY(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      LOCKEY_1 = K + IKEY * 15 +(-15)
      USEVARIABLEVISCOSITY = (VISCC4SMAG .ne. 0.0D00) .OR.((VISCC2SMAG
     >  .ne. 0.0D00) .OR.((VISCC4LEITHD .ne. 0.0D00) .OR.((VISCC4LEITH
     >  .ne. 0.0D00) .OR.((VISCC2LEITHD .ne. 0.0D00) .OR.((VISCC2LEITH
     >  .ne. 0.0D00) .OR.((VISCA4GRID .ne. 0.0D00) .OR.(VISCAHGRID .ne.
     >  0.0D00)))))))
      HARMONIC = (VISCC2SMAG .ne. 0.0D00) .OR.((VISCC2LEITHD .ne.
     >  0.0D00) .OR.((VISCC2LEITH .ne. 0.0D00) .OR.((VISCAHGRID .ne.
     >  0.0D00) .OR.((VISCAHZ .ne. 0.0D00) .OR.((VISCAH .ne. 0.0D00)
     >  .OR.(VISCAHD .ne. 0.0D00))))))
      BIHARMONIC = (VISCC4SMAG .ne. 0.0D00) .OR.((VISCC4LEITHD .ne.
     >  0.0D00) .OR.((VISCC4LEITH .ne. 0.0D00) .OR.((VISCA4GRID .ne.
     >  0.0D00) .OR.((VISCA4Z .ne. 0.0D00) .OR.((VISCA4 .ne. 0.0D00)
     >  .OR.(VISCA4D .ne. 0.0D00))))))
      IF(USEVARIABLEVISCOSITY) THEN
        IF(HARMONIC .AND.(VISCAHREMAX .ne. 0.0D00)) THEN
          VISCAHRE_MAX = SQRT(2.0D00) / VISCAHREMAX
        ELSE
          VISCAHRE_MAX = 0.0D00
        ENDIF
        IF(BIHARMONIC .AND.(VISCA4REMAX .ne. 0.0D00)) THEN
          VISCA4RE_MAX = (SQRT(2.0D00) * 1.25D-01) / VISCA4REMAX
        ELSE
          VISCA4RE_MAX = 0.0D00
        ENDIF
        CALCLEITH = (VISCC4LEITHD .ne. 0.0D00) .OR.((VISCC4LEITH .ne.
     >  0.0D00) .OR.((VISCC2LEITH .ne. 0.0D00) .OR.(VISCC2LEITHD .ne.
     >  0.0D00)))
        CALCSMAG = (VISCC2SMAG .ne. 0.0D00) .OR.(VISCC4SMAG .ne. 0.0D00
     > )
        IF(DELTATMOM .ne. 0.0D00) THEN
          RECIP_DT = 1D00 / DELTATMOM
        ELSE
          RECIP_DT = 0.0D00
        ENDIF
        IF(CALCSMAG) THEN
          SMAG2FAC = (VISCC2SMAG / 3.141592653589793116D00) ** 2
          SMAG4FAC = ((VISCC4SMAG / 3.141592653589793116D00) ** 2) *
     >  1.25D-01
        ELSE
          SMAG2FAC = 0.0D00
          SMAG4FAC = 0.0D00
        ENDIF
        IF(CALCLEITH) THEN
          IF(USEFULLLEITH) THEN
            LEITH2FAC = (VISCC2LEITH / 3.141592653589793116D00) ** 6
            LEITHD2FAC = (VISCC2LEITHD / 3.141592653589793116D00) ** 6
            LEITH4FAC = ((VISCC4LEITH / 3.141592653589793116D00) ** 6)
     >  * 1.5625D-02
            LEITHD4FAC = ((VISCC4LEITHD / 3.141592653589793116D00) ** 6
     > ) * 1.5625D-02
          ELSE
            LEITH2FAC = (VISCC2LEITH / 3.141592653589793116D00) ** 3
            LEITHD2FAC = (VISCC2LEITHD / 3.141592653589793116D00) ** 3
            LEITH4FAC = ((VISCC4LEITH / 3.141592653589793116D00) ** 3)
     >  * 1.25D-01
            LEITHD4FAC = ((VISCC4LEITHD / 3.141592653589793116D00) ** 3
     > ) * 1.25D-01
          ENDIF
        ELSE
          LEITH2FAC = 0.0D00
          LEITH4FAC = 0.0D00
          LEITHD2FAC = 0.0D00
          LEITHD4FAC = 0.0D00
        ENDIF
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            VISCAH_D(I, J) = VISCAHD
            VISCAH_Z(I, J) = VISCAHZ
            VISCA4_D(I, J) = VISCA4D
            VISCA4_Z(I, J) = VISCA4Z
            VISCA4_ZSMG(I, J) = 0.0D00
            VISCAH_ZSMG(I, J) = 0.0D00
            VISCAH_DLTH(I, J) = 0.0D00
            VISCA4_DLTH(I, J) = 0.0D00
            VISCAH_DLTHD(I, J) = 0.0D00
            VISCA4_DLTHD(I, J) = 0.0D00
            VISCAH_DSMG(I, J) = 0.0D00
            VISCA4_DSMG(I, J) = 0.0D00
            VISCAH_ZLTH(I, J) = 0.0D00
            VISCA4_ZLTH(I, J) = 0.0D00
            VISCAH_ZLTHD(I, J) = 0.0D00
            VISCA4_ZLTHD(I, J) = 0.0D00
          END DO
        END DO
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            DIVDX(I, J) = 0.0D00
            DIVDY(I, J) = 0.0D00
            VRTDX(I, J) = 0.0D00
            VRTDY(I, J) = 0.0D00
          END DO
        END DO
        IF(CALCLEITH) THEN
          IF(USECUBEDSPHEREEXCHANGE) THEN
            CALL fill_cs_corner_tr_rl((1), (.FALSE.), HDIV, BI, BJ,
     >  MYTHID)
          ENDIF
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              DIVDX(I, J) = (RECIP_DXC(I, J, BI, BJ) *(HDIV(I, J) -
     >  HDIV(I + (-1), J)))
            END DO
          END DO
          IF(USECUBEDSPHEREEXCHANGE) THEN
            CALL fill_cs_corner_tr_rl((2), (.FALSE.), HDIV, BI, BJ,
     >  MYTHID)
          ENDIF
          DO J = -1, 42, 1
            DO I = -1, 92, 1
              DIVDY(I, J) = (RECIP_DYC(I, J, BI, BJ) *(HDIV(I, J) -
     >  HDIV(I, J + (-1))))
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -1, 92, 1
              VRTDX(I, J) = (MASKS(I, J, K, BI, BJ) * RECIP_DXG(I, J,
     >  BI, BJ) *(VORT3(I + 1, J) - VORT3(I, J)))
            END DO
          END DO
          DO J = -1, 42, 1
            DO I = -1, 93, 1
              VRTDY(I, J) = (MASKW(I, J, K, BI, BJ) * RECIP_DYG(I, J,
     >  BI, BJ) *(VORT3(I, J + 1) - VORT3(I, J)))
            END DO
          END DO
        ENDIF
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            LOCKEY_2 = I + J * 96 + LOCKEY_1 * 4416 +(-4221)
            IF(USEAREAVISCLENGTH) THEN
              L2 = RA(I, J, BI, BJ)
            ELSE
              L2 = 2.0D00 /((RECIP_DXF(I, J, BI, BJ) ** 2) +(RECIP_DYF(
     > I, J, BI, BJ) ** 2))
            ENDIF
            L4RDT = (L2 ** 2) * RECIP_DT * 3.125D-02
            L3 = (L2 ** 1.5D00)
            L4 = (L2 ** 2)
            L5 = (L2 * L3)
            L2RDT = L2 * RECIP_DT * 2.5D-01
            IF((KE(I, J) .GT. 0.0D00) .AND.(VISCAHRE_MAX .GT. 0.0D00))
     >  THEN
              USCL = VISCAHRE_MAX * SQRT(KE(I, J) * L2)
            ELSE
              USCL = 0.0D00
            ENDIF
            IF((KE(I, J) .GT. 0.0D00) .AND.(VISCA4RE_MAX .GT. 0.0D00))
     >  THEN
              U4SCL = VISCA4RE_MAX * L3 * SQRT(KE(I, J))
            ELSE
              U4SCL = 0.0D00
            ENDIF
            IF(CALCLEITH .AND. USEFULLLEITH) THEN
              GRDVRT = ((VRTDX(I, J) * VRTDX(I, J) + VRTDX(I, J + 1) *
     >  VRTDX(I, J + 1)) +(VRTDY(I, J) * VRTDY(I, J) + VRTDY(I + 1, J)
     >  * VRTDY(I + 1, J))) * 2.5D-01
              GRDDIV = ((DIVDX(I, J) * DIVDX(I, J) + DIVDX(I + 1, J) *
     >  DIVDX(I + 1, J)) +(DIVDY(I, J) * DIVDY(I, J) + DIVDY(I, J + 1)
     >  * DIVDY(I, J + 1))) * 2.5D-01
              VISCAH_DLTH(I, J) = (L3 * SQRT(GRDDIV * LEITHD2FAC +
     >  GRDVRT * LEITH2FAC))
              VISCA4_DLTH(I, J) = (L5 * SQRT(GRDDIV * LEITHD4FAC +
     >  GRDVRT * LEITH4FAC))
              VISCAH_DLTHD(I, J) = (L3 * SQRT(GRDDIV * LEITHD2FAC))
              VISCA4_DLTHD(I, J) = (L5 * SQRT(GRDDIV * LEITHD4FAC))
            ELSE
              IF(CALCLEITH) THEN
                GRDVRT = MAX(ABS(VRTDX(I, J + 1)), ABS(VRTDX(I, J)))
                GRDVRT = MAX(GRDVRT, ABS(VRTDY(I + 1, J)))
                GRDVRT = MAX(GRDVRT, ABS(VRTDY(I, J)))
                GRDDIV = MAX(ABS(DIVDX(I + 1, J)), ABS(DIVDX(I, J)))
                GRDDIV = MAX(GRDDIV, ABS(DIVDY(I, J + 1)))
                GRDDIV = MAX(GRDDIV, ABS(DIVDY(I, J)))
                VISCAH_DLTH(I, J) = (L3 *(GRDVRT * LEITH2FAC +(GRDDIV *
     >  LEITHD2FAC)))
                VISCA4_DLTH(I, J) = (L5 *(GRDVRT * LEITH4FAC +(GRDDIV *
     >  LEITHD4FAC)))
                VISCAH_DLTHD(I, J) = (L3 *(GRDDIV * LEITHD2FAC))
                VISCA4_DLTHD(I, J) = (L5 *(GRDDIV * LEITHD4FAC))
              ELSE
                VISCAH_DLTH(I, J) = 0.0D00
                VISCA4_DLTH(I, J) = 0.0D00
                VISCAH_DLTHD(I, J) = 0.0D00
                VISCA4_DLTHD(I, J) = 0.0D00
              ENDIF
            ENDIF
            IF(CALCSMAG) THEN
              VISCAH_DSMG(I, J) = (L2 * SQRT((TENSION(I, J) ** 2) +((
     > STRAIN(I + 1, J) ** 2) +(STRAIN(I, J + 1) ** 2) +(STRAIN(I, J)
     >  ** 2) +(STRAIN(I + 1, J + 1) ** 2)) * 2.5D-01))
              VISCA4_DSMG(I, J) = (VISCAH_DSMG(I, J) * L2 * SMAG4FAC)
              VISCAH_DSMG(I, J) = (VISCAH_DSMG(I, J) * SMAG2FAC)
            ELSE
              VISCAH_DSMG(I, J) = 0.0D00
              VISCA4_DSMG(I, J) = 0.0D00
            ENDIF
            ALIN = VISCAH_DSMG(I, J) + VISCAH_DLTH(I, J) + VISCAHD +
     >  L2RDT * VISCAHGRID
            VISCAH_DMIN(I, J) = MAX(USCL, L2RDT * VISCAHGRIDMIN)
            VISCAH_D(I, J) = MAX(VISCAH_DMIN(I, J), ALIN)
            VISCAH_DMAX(I, J) = MIN(VISCAHMAX, L2RDT * VISCAHGRIDMAX)
            VISCAH_D(I, J) = MIN(VISCAH_D(I, J), VISCAH_DMAX(I, J))
            ALIN = VISCA4_DSMG(I, J) + VISCA4_DLTH(I, J) + VISCA4D +
     >  L4RDT * VISCA4GRID
            VISCA4_DMIN(I, J) = MAX(U4SCL, L4RDT * VISCA4GRIDMIN)
            VISCA4_D(I, J) = MAX(VISCA4_DMIN(I, J), ALIN)
            VISCA4_DMAX(I, J) = MIN(VISCA4MAX, L4RDT * VISCA4GRIDMAX)
            VISCA4_D(I, J) = MIN(VISCA4_D(I, J), VISCA4_DMAX(I, J))
            IF(USEAREAVISCLENGTH) THEN
              L2 = RAZ(I, J, BI, BJ)
            ELSE
              L2 = 2.0D00 /((RECIP_DXV(I, J, BI, BJ) ** 2) +(RECIP_DYU(
     > I, J, BI, BJ) ** 2))
            ENDIF
            L4RDT = (L2 ** 2) * RECIP_DT * 3.125D-02
            L3 = (L2 ** 1.5D00)
            L4 = (L2 ** 2)
            L5 = (L2 * L3)
            L2RDT = L2 * RECIP_DT * 2.5D-01
            IF((VISCA4RE_MAX .GT. 0.0D00) .OR.(VISCAHRE_MAX .GT. 0.0D00
     > )) THEN
              KEZPT = ((KE(I, J) + KE(I + (-1), J + (-1))) +(KE(I + (-1
     > ), J) + KE(I, J + (-1)))) * 2.5D-01
              IF(KEZPT .GT. 0.0D00) THEN
                USCL = VISCAHRE_MAX * SQRT(KEZPT * L2)
                U4SCL = VISCA4RE_MAX * L3 * SQRT(KEZPT)
              ELSE
                USCL = 0.0D00
                U4SCL = 0.0D00
              ENDIF
            ELSE
              USCL = 0.0D00
              U4SCL = 0.0D00
            ENDIF
            IF(CALCLEITH .AND. USEFULLLEITH) THEN
              GRDVRT = ((VRTDX(I, J) * VRTDX(I, J) + VRTDX(I + (-1), J)
     >  * VRTDX(I + (-1), J)) +(VRTDY(I, J) * VRTDY(I, J) + VRTDY(I, J
     >  + (-1)) * VRTDY(I, J + (-1)))) * 2.5D-01
              GRDDIV = ((DIVDX(I, J) * DIVDX(I, J) + DIVDX(I, J + (-1))
     >  * DIVDX(I, J + (-1))) +(DIVDY(I, J) * DIVDY(I, J) + DIVDY(I + (
     > -1), J) * DIVDY(I + (-1), J))) * 2.5D-01
              VISCAH_ZLTH(I, J) = (L3 * SQRT(GRDDIV * LEITHD2FAC +
     >  GRDVRT * LEITH2FAC))
              VISCA4_ZLTH(I, J) = (L5 * SQRT(GRDDIV * LEITHD4FAC +
     >  GRDVRT * LEITH4FAC))
              VISCAH_ZLTHD(I, J) = (L3 * SQRT(GRDDIV * LEITHD2FAC))
              VISCA4_ZLTHD(I, J) = (L5 * SQRT(GRDDIV * LEITHD4FAC))
            ELSE
              IF(CALCLEITH) THEN
                GRDVRT = MAX(ABS(VRTDX(I + (-1), J)), ABS(VRTDX(I, J)))
                GRDVRT = MAX(GRDVRT, ABS(VRTDY(I, J + (-1))))
                GRDVRT = MAX(GRDVRT, ABS(VRTDY(I, J)))
                GRDDIV = MAX(ABS(DIVDX(I, J)), ABS(DIVDX(I, J + (-1))))
                GRDDIV = MAX(GRDDIV, ABS(DIVDY(I, J)))
                GRDDIV = MAX(GRDDIV, ABS(DIVDY(I + (-1), J)))
                VISCAH_ZLTH(I, J) = (L3 *(GRDVRT * LEITH2FAC +(GRDDIV *
     >  LEITHD2FAC)))
                VISCA4_ZLTH(I, J) = (L5 *(GRDVRT * LEITH4FAC +(GRDDIV *
     >  LEITHD4FAC)))
                VISCAH_ZLTHD(I, J) = (L3 *(GRDDIV * LEITHD2FAC))
                VISCA4_ZLTHD(I, J) = (L5 *(GRDDIV * LEITHD4FAC))
              ELSE
                VISCAH_ZLTH(I, J) = 0.0D00
                VISCA4_ZLTH(I, J) = 0.0D00
                VISCAH_ZLTHD(I, J) = 0.0D00
                VISCA4_ZLTHD(I, J) = 0.0D00
              ENDIF
            ENDIF
            IF(CALCSMAG) THEN
              VISCAH_ZSMG(I, J) = (L2 * SQRT((STRAIN(I, J) ** 2) +((
     > TENSION(I, J) ** 2) +(TENSION(I, J + (-1)) ** 2) +(TENSION(I + (
     > -1), J) ** 2) +(TENSION(I + (-1), J + (-1)) ** 2)) * 2.5D-01))
              VISCA4_ZSMG(I, J) = (VISCAH_ZSMG(I, J) * L2 * SMAG4FAC)
              VISCAH_ZSMG(I, J) = (VISCAH_ZSMG(I, J) * SMAG2FAC)
            ENDIF
            ALIN = VISCAH_ZSMG(I, J) + VISCAH_ZLTH(I, J) + VISCAHZ +
     >  L2RDT * VISCAHGRID
            VISCAH_ZMIN(I, J) = MAX(USCL, L2RDT * VISCAHGRIDMIN)
            VISCAH_Z(I, J) = MAX(VISCAH_ZMIN(I, J), ALIN)
            VISCAH_ZMAX(I, J) = MIN(VISCAHMAX, L2RDT * VISCAHGRIDMAX)
            VISCAH_Z(I, J) = MIN(VISCAH_Z(I, J), VISCAH_ZMAX(I, J))
            ALIN = VISCA4_ZSMG(I, J) + VISCA4_ZLTH(I, J) + VISCA4Z +
     >  L4RDT * VISCA4GRID
            VISCA4_ZMIN(I, J) = MAX(U4SCL, L4RDT * VISCA4GRIDMIN)
            VISCA4_Z(I, J) = MAX(VISCA4_ZMIN(I, J), ALIN)
            VISCA4_ZMAX(I, J) = MIN(VISCA4MAX, L4RDT * VISCA4GRIDMAX)
            VISCA4_Z(I, J) = MIN(VISCA4_Z(I, J), VISCA4_ZMAX(I, J))
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            VISCAH_D(I, J) = VISCAHD
            VISCAH_Z(I, J) = VISCAHZ
            VISCA4_D(I, J) = VISCA4D
            VISCA4_Z(I, J) = VISCA4Z
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_hdissip(BI, BJ, K, HDIV, VORT3, TENSION, STRAIN,
     >  KE, HFACZ, VISCAH_S, VISCAH_T, VISCA4_S, VISCA4_T, HARMONIC,
     >  BIHARMONIC, USEVARIABLEVISCOSITY, UDISSIP, VDISSIP, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) HDIV(-2 : 93, -2 : 43)
      REAL(w2f__8) VORT3(-2 : 93, -2 : 43)
      REAL(w2f__8) TENSION(-2 : 93, -2 : 43)
      REAL(w2f__8) STRAIN(-2 : 93, -2 : 43)
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_S(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_T(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_S(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_T(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) HARMONIC
      LOGICAL(w2f__i4) BIHARMONIC
      LOGICAL(w2f__i4) USEVARIABLEVISCOSITY
      REAL(w2f__8) UDISSIP(-2 : 93, -2 : 43)
      REAL(w2f__8) VDISSIP(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(HARMONIC) THEN
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            UDISSIP(I, J) = (RECIP_DXC(I, J, BI, BJ) * RECIP_DYG(I, J,
     >  BI, BJ) * RECIP_DYG(I, J, BI, BJ) *(TENSION(I, J) * VISCAH_T(I,
     >  J) * DYF(I, J, BI, BJ) * DYF(I, J, BI, BJ) - TENSION(I + (-1),
     >  J) * VISCAH_T(I + (-1), J) * DYF(I + (-1), J, BI, BJ) * DYF(I +
     >  (-1), J, BI, BJ)) + RECIP_DYG(I, J, BI, BJ) * RECIP_DXC(I, J,
     >  BI, BJ) * RECIP_DXC(I, J, BI, BJ) *(STRAIN(I, J + 1) * VISCAH_S
     > (I, J + 1) * DXV(I, J + 1, BI, BJ) * DXV(I, J + 1, BI, BJ) -
     >  STRAIN(I, J) * VISCAH_S(I, J) * DXV(I, J, BI, BJ) * DXV(I, J,
     >  BI, BJ)))
            VDISSIP(I, J) = (RECIP_DXG(I, J, BI, BJ) * RECIP_DYC(I, J,
     >  BI, BJ) * RECIP_DYC(I, J, BI, BJ) *(STRAIN(I + 1, J) * VISCAH_S
     > (I + 1, J) * DYU(I + 1, J, BI, BJ) * DYU(I + 1, J, BI, BJ) -
     >  STRAIN(I, J) * VISCAH_S(I, J) * DYU(I, J, BI, BJ) * DYU(I, J,
     >  BI, BJ)) - RECIP_DYC(I, J, BI, BJ) * RECIP_DXG(I, J, BI, BJ) *
     >  RECIP_DXG(I, J, BI, BJ) *(TENSION(I, J) * VISCAH_T(I, J) * DXF(
     > I, J, BI, BJ) * DXF(I, J, BI, BJ) - TENSION(I, J + (-1)) *
     >  VISCAH_T(I, J + (-1)) * DXF(I, J + (-1), BI, BJ) * DXF(I, J + (
     > -1), BI, BJ)))
          END DO
        END DO
      ENDIF
      IF(BIHARMONIC) THEN
        WRITE(*, *) 'MOM_HDISSIP: BIHARMONIC NOT ALLOWED WITH STRAIN-'
     >  // 'TENSION'
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_quasihydrostatic(BI, BJ, K, UFLD, VFLD,
     >  EFFECTIVEBUOY, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) EFFECTIVEBUOY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      PARAMETER ( IMAX = 91)
      INTEGER(w2f__i4) IMIN
      PARAMETER ( IMIN = 0)
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      PARAMETER ( JMAX = 41)
      INTEGER(w2f__i4) JMIN
      PARAMETER ( JMIN = 0)
      REAL(w2f__8) SCALINGFACTOR
C
C     **** Statements ****
C
      SCALINGFACTOR = RECIP_GRAVITY * RHOCONST * GRAVITYSIGN
      IF(USE3DCORIOLIS) THEN
        DO J = 0, 41, 1
          DO I = 0, 91, 1
            EFFECTIVEBUOY(I, J) = (EFFECTIVEBUOY(I, J) + FCORICOS(I, J,
     >  BI, BJ) * SCALINGFACTOR *(ANGLECOSC(I, J, BI, BJ) * 5.0D-01 *(
     > UFLD(I, J, K, BI, BJ) + UFLD(I + 1, J, K, BI, BJ)) - ANGLESINC(I
     > , J, BI, BJ) * 5.0D-01 *(VFLD(I, J, K, BI, BJ) + VFLD(I, J + 1,
     >  K, BI, BJ))))
          END DO
        END DO
      ENDIF
      IF(USENHMTERMS) THEN
        DO J = 0, 41, 1
          DO I = 0, 91, 1
            EFFECTIVEBUOY(I, J) = (EFFECTIVEBUOY(I, J) + RECIP_DEEPFACC
     > (K) * RECIP_RSPHERE * SCALINGFACTOR *((UFLD(I, J, K, BI, BJ) *
     >  UFLD(I, J, K, BI, BJ) + UFLD(I + 1, J, K, BI, BJ) * UFLD(I + 1,
     >  J, K, BI, BJ)) +(VFLD(I, J, K, BI, BJ) * VFLD(I, J, K, BI, BJ)
     >  + VFLD(I, J + 1, K, BI, BJ) * VFLD(I, J + 1, K, BI, BJ))) *
     >  5.0D-01)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_coriolis_nh(BI, BJ, K, WFLD, UCORIOLISTERM,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) UCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) WMSK
C
C     **** Statements ****
C
      KP1 = MIN(K + 1, 15)
      WMSK = 1.0D00
      IF(K .eq. 15) THEN
        WMSK = 0.0D00
      ENDIF
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          UCORIOLISTERM(I, J) = (GRAVITYSIGN *(ANGLECOSC(I, J, BI, BJ)
     >  * FCORICOS(I, J, BI, BJ) * 5.0D-01 *(RVEL2WUNIT(K) * WFLD(I, J,
     >  K, BI, BJ) + WMSK * RVEL2WUNIT(KP1) * WFLD(I, J, KP1, BI, BJ))
     >  + ANGLECOSC(I + (-1), J, BI, BJ) * FCORICOS(I + (-1), J, BI, BJ
     > ) * 5.0D-01 *(RVEL2WUNIT(K) * WFLD(I + (-1), J, K, BI, BJ) +
     >  WMSK * RVEL2WUNIT(KP1) * WFLD(I + (-1), J, KP1, BI, BJ))) *
     >  5.0D-01)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_metric_nh(BI, BJ, K, UFLD, WFLD, UMETRICTERMS,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) UMETRICTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) WVELBOTTOMOVERRIDE
C
C     **** Statements ****
C
      KP1 = MIN(K + 1, 15)
      WVELBOTTOMOVERRIDE = 1.0D00
      IF(K .eq. 15) THEN
        WVELBOTTOMOVERRIDE = 0.0D00
      ENDIF
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          UMETRICTERMS(I, J) = (GRAVITYSIGN * RECIP_DEEPFACC(K) * UFLD(
     > I, J) * RECIP_RSPHERE * 2.5D-01 *(RVEL2WUNIT(K) *(WFLD(I, J, K,
     >  BI, BJ) + WFLD(I + (-1), J, K, BI, BJ)) + WVELBOTTOMOVERRIDE *
     >  RVEL2WUNIT(KP1) *(WFLD(I, J, KP1, BI, BJ) + WFLD(I + (-1), J,
     >  KP1, BI, BJ))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_bottomdrag(BI, BJ, K, UFLD, KE, KAPPARU,
     >  UDRAGTERMS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      REAL(w2f__8) KAPPARU(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) UDRAGTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DRAGFAC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KBOTTOM
      INTEGER(w2f__i4) KDOWN
      INTEGER(w2f__i4) KDOWNC
      REAL(w2f__8) MASKDOWN
      REAL(w2f__8) RDRCKP1
      REAL(w2f__8) VISCFAC
C
C     **** Statements ****
C
      IF(USINGZCOORDS) THEN
        KBOTTOM = 15
        KDOWN = MIN(KBOTTOM, K + 1)
        KDOWNC = KDOWN
        DRAGFAC = 1.0D00
      ELSE
        KBOTTOM = 1
        KDOWN = MAX(KBOTTOM, K +(-1))
        KDOWNC = K
        DRAGFAC = MASS2RUNIT * RHOCONST
      ENDIF
      RDRCKP1 = RECIP_DRC(KDOWNC)
      IF(K .eq. KBOTTOM) THEN
        RDRCKP1 = RECIP_DRF(K)
      ENDIF
      VISCFAC = 0.0D00
      IF(NO_SLIP_BOTTOM) THEN
        VISCFAC = 1.0D00
      ENDIF
      DO J = -2, 42, 1
        DO I = -1, 92, 1
          MASKDOWN = MASKW(I, J, KDOWN, BI, BJ)
          IF(K .eq. KBOTTOM) THEN
            MASKDOWN = 0.0D00
          ENDIF
          UDRAGTERMS(I, J) = (-(UFLD(I, J) * RECIP_DRF(K) * RECIP_HFACW
     > (I, J, K, BI, BJ) *(DRAGFAC * BOTTOMDRAGLINEAR + VISCFAC *
     >  RDRCKP1 * KAPPARU(I, J, KDOWNC) * 2.0D00) *(1.0D00 - MASKDOWN))
     > )
          IF((KE(I, J) + KE(I + (-1), J)) .ne. 0.0D00) THEN
            UDRAGTERMS(I, J) = (UDRAGTERMS(I, J) - UFLD(I, J) * DRAGFAC
     >  * SQRT(KE(I, J) + KE(I + (-1), J)) * BOTTOMDRAGQUADRATIC *
     >  RECIP_DRF(K) * RECIP_HFACW(I, J, K, BI, BJ) *(1.0D00 - MASKDOWN
     > ))
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_rviscflux(BI, BJ, K, UFLD, KAPPARU, RVISCFLUXU,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KAPPARU(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) RVISCFLUXU(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF((K .GT. 15) .OR.(K .LE. 1)) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            RVISCFLUXU(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 42, 1
          DO I = -2, 92, 1
            RVISCFLUXU(I, J) = (-(MASKW(I, J, K + (-1), BI, BJ) * MASKW
     > (I, J, K, BI, BJ) * RECIP_DRC(K) * RKSIGN * RHOFACF(K) *
     >  DEEPFAC2F(K) * KAPPARU(I, J, K) * RAW(I, J, BI, BJ) *(UFLD(I, J
     > , K, BI, BJ) - UFLD(I, J, K + (-1), BI, BJ))))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_u_sidedrag(BI, BJ, K, UFLD, DEL2U, HFACZ, VISCAH_Z
     > , VISCA4_Z, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY,
     >  UDRAGTERMS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2U(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) HARMONIC
      LOGICAL(w2f__i4) BIHARMONIC
      LOGICAL(w2f__i4) USEVARIABLEVISCOSITY
      REAL(w2f__8) UDRAGTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A4TMP
      REAL(w2f__8) AHTMP
      REAL(w2f__8) HFACZCLOSEDN
      REAL(w2f__8) HFACZCLOSEDS
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(SIDEDRAGFACTOR .LE. 0.0D00) THEN
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            HFACZCLOSEDS = HFACW(I, J, K, BI, BJ) - HFACZ(I, J)
            HFACZCLOSEDN = HFACW(I, J, K, BI, BJ) - HFACZ(I, J + 1)
            AHTMP = MIN(VISCAHMAX, VISCAH +((RAW(I, J, BI, BJ) *
     >  VISCAHGRID) / DELTATMOM))
            A4TMP = MIN(VISCA4MAX, VISCA4 +((VISCA4GRID *((RAW(I, J, BI
     > , BJ) ** 2))) / DELTATMOM))
            A4TMP = MIN(A4TMP, (VISCA4GRIDMAX *((RAW(I, J, BI, BJ) ** 2
     > ))) / DELTATMOM)
            A4TMP = MAX(A4TMP, (VISCA4GRIDMIN *((RAW(I, J, BI, BJ) ** 2
     > ))) / DELTATMOM)
            UDRAGTERMS(I, J) = (-(DRF(K) * RECIP_RAW(I, J, BI, BJ) *
     >  RECIP_DRF(K) * RECIP_HFACW(I, J, K, BI, BJ) *(RECIP_DYU(I, J,
     >  BI, BJ) * DXV(I, J, BI, BJ) * HFACZCLOSEDS + RECIP_DYU(I, J + 1
     > , BI, BJ) * DXV(I, J + 1, BI, BJ) * HFACZCLOSEDN) * 2.0D00 *(
     > UFLD(I, J) * AHTMP - DEL2U(I, J) * A4TMP)))
          END DO
        END DO
      ELSE
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            HFACZCLOSEDS = HFACW(I, J, K, BI, BJ) - HFACW(I, J + (-1),
     >  K, BI, BJ)
            HFACZCLOSEDN = HFACW(I, J, K, BI, BJ) - HFACW(I, J + 1, K,
     >  BI, BJ)
            HFACZCLOSEDS = MAX(HFACZCLOSEDS, 0.0D00)
            HFACZCLOSEDN = MAX(HFACZCLOSEDN, 0.0D00)
            UDRAGTERMS(I, J) = (-(SIDEDRAGFACTOR * DRF(K) * RECIP_RAW(I
     > , J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACW(I, J, K, BI, BJ) *(
     > RECIP_DYU(I, J, BI, BJ) * DXV(I, J, BI, BJ) * HFACZCLOSEDS *(
     > UFLD(I, J) * VISCAH_Z(I, J) - DEL2U(I, J) * VISCA4_Z(I, J)) +
     >  RECIP_DYU(I, J + 1, BI, BJ) * DXV(I, J + 1, BI, BJ) *
     >  HFACZCLOSEDN *(UFLD(I, J) * VISCAH_Z(I, J + 1) - DEL2U(I, J) *
     >  VISCA4_Z(I, J + 1)))))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_coriolis_nh(BI, BJ, K, WFLD, VCORIOLISTERM,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VCORIOLISTERM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) WMSK
C
C     **** Statements ****
C
      KP1 = MIN(K + 1, 15)
      WMSK = 1.0D00
      IF(K .eq. 15) THEN
        WMSK = 0.0D00
      ENDIF
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          VCORIOLISTERM(I, J) = (-(GRAVITYSIGN *(ANGLESINC(I, J, BI, BJ
     > ) * FCORICOS(I, J, BI, BJ) * 5.0D-01 *(RVEL2WUNIT(K) * WFLD(I, J
     > , K, BI, BJ) + WMSK * RVEL2WUNIT(KP1) * WFLD(I, J, KP1, BI, BJ))
     >  + ANGLESINC(I, J + (-1), BI, BJ) * FCORICOS(I, J + (-1), BI, BJ
     > ) * 5.0D-01 *(RVEL2WUNIT(K) * WFLD(I, J + (-1), K, BI, BJ) +
     >  WMSK * RVEL2WUNIT(KP1) * WFLD(I, J + (-1), KP1, BI, BJ))) *
     >  5.0D-01))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_metric_nh(BI, BJ, K, VFLD, WFLD, VMETRICTERMS,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VMETRICTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KP1
      REAL(w2f__8) WVELBOTTOMOVERRIDE
C
C     **** Statements ****
C
      KP1 = MIN(K + 1, 15)
      WVELBOTTOMOVERRIDE = 1.0D00
      IF(K .eq. 15) THEN
        WVELBOTTOMOVERRIDE = 0.0D00
      ENDIF
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          VMETRICTERMS(I, J) = (GRAVITYSIGN * RECIP_DEEPFACC(K) * VFLD(
     > I, J) * RECIP_RSPHERE * 2.5D-01 *(RVEL2WUNIT(K) *(WFLD(I, J, K,
     >  BI, BJ) + WFLD(I, J + (-1), K, BI, BJ)) + WVELBOTTOMOVERRIDE *
     >  RVEL2WUNIT(KP1) *(WFLD(I, J, KP1, BI, BJ) + WFLD(I, J + (-1),
     >  KP1, BI, BJ))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_bottomdrag(BI, BJ, K, VFLD, KE, KAPPARV,
     >  VDRAGTERMS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) KE(-2 : 93, -2 : 43)
      REAL(w2f__8) KAPPARV(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) VDRAGTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DRAGFAC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KBOTTOM
      INTEGER(w2f__i4) KDOWN
      INTEGER(w2f__i4) KDOWNC
      REAL(w2f__8) MASKDOWN
      REAL(w2f__8) RDRCKP1
      REAL(w2f__8) VISCFAC
C
C     **** Statements ****
C
      IF(USINGZCOORDS) THEN
        KBOTTOM = 15
        KDOWN = MIN(KBOTTOM, K + 1)
        KDOWNC = KDOWN
        DRAGFAC = 1.0D00
      ELSE
        KBOTTOM = 1
        KDOWN = MAX(KBOTTOM, K +(-1))
        KDOWNC = K
        DRAGFAC = MASS2RUNIT * RHOCONST
      ENDIF
      RDRCKP1 = RECIP_DRC(KDOWNC)
      VISCFAC = 0.0D00
      IF(NO_SLIP_BOTTOM) THEN
        VISCFAC = 1.0D00
      ENDIF
      IF(K .eq. KBOTTOM) THEN
        RDRCKP1 = RECIP_DRF(K)
      ENDIF
      DO J = -1, 42, 1
        DO I = -2, 92, 1
          MASKDOWN = MASKS(I, J, KDOWN, BI, BJ)
          IF(K .eq. KBOTTOM) THEN
            MASKDOWN = 0.0D00
          ENDIF
          VDRAGTERMS(I, J) = (-(VFLD(I, J) * RECIP_DRF(K) * RECIP_HFACS
     > (I, J, K, BI, BJ) *(DRAGFAC * BOTTOMDRAGLINEAR + VISCFAC *
     >  RDRCKP1 * KAPPARV(I, J, KDOWNC) * 2.0D00) *(1.0D00 - MASKDOWN))
     > )
          IF((KE(I, J) + KE(I, J + (-1))) .ne. 0.0D00) THEN
            VDRAGTERMS(I, J) = (VDRAGTERMS(I, J) - VFLD(I, J) * DRAGFAC
     >  * SQRT(KE(I, J) + KE(I, J + (-1))) * BOTTOMDRAGQUADRATIC *
     >  RECIP_DRF(K) * RECIP_HFACS(I, J, K, BI, BJ) *(1.0D00 - MASKDOWN
     > ))
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_rviscflux(BI, BJ, K, VFLD, KAPPARV, RVISCFLUXV,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) KAPPARV(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) RVISCFLUXV(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF((K .GT. 15) .OR.(K .LE. 1)) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            RVISCFLUXV(I, J) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 42, 1
          DO I = -2, 92, 1
            RVISCFLUXV(I, J) = (-(MASKS(I, J, K + (-1), BI, BJ) * MASKS
     > (I, J, K, BI, BJ) * RECIP_DRC(K) * RKSIGN * RHOFACF(K) *
     >  DEEPFAC2F(K) * KAPPARV(I, J, K) * RAS(I, J, BI, BJ) *(VFLD(I, J
     > , K, BI, BJ) - VFLD(I, J, K + (-1), BI, BJ))))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE mom_v_sidedrag(BI, BJ, K, VFLD, DEL2V, HFACZ, VISCAH_Z
     > , VISCA4_Z, HARMONIC, BIHARMONIC, USEVARIABLEVISCOSITY,
     >  VDRAGTERMS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) DEL2V(-2 : 93, -2 : 43)
      REAL(w2f__8) HFACZ(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCAH_Z(-2 : 93, -2 : 43)
      REAL(w2f__8) VISCA4_Z(-2 : 93, -2 : 43)
      LOGICAL(w2f__i4) HARMONIC
      LOGICAL(w2f__i4) BIHARMONIC
      LOGICAL(w2f__i4) USEVARIABLEVISCOSITY
      REAL(w2f__8) VDRAGTERMS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A4TMP
      REAL(w2f__8) AHTMP
      REAL(w2f__8) HFACZCLOSEDE
      REAL(w2f__8) HFACZCLOSEDW
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(SIDEDRAGFACTOR .LE. 0.0D00) THEN
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            HFACZCLOSEDW = HFACS(I, J, K, BI, BJ) - HFACZ(I, J)
            HFACZCLOSEDE = HFACS(I, J, K, BI, BJ) - HFACZ(I + 1, J)
            AHTMP = MIN(VISCAHMAX, VISCAH +((RAS(I, J, BI, BJ) *
     >  VISCAHGRID) / DELTATMOM))
            A4TMP = MIN(VISCA4MAX, VISCA4 +((VISCA4GRID *((RAS(I, J, BI
     > , BJ) ** 2))) / DELTATMOM))
            IF(VISCA4GRIDMAX .GT. 0.0D00) THEN
              A4TMP = MIN(A4TMP, (VISCA4GRIDMAX *((RAS(I, J, BI, BJ) **
     >  2))) / DELTATMOM)
            ENDIF
            A4TMP = MAX(A4TMP, (VISCA4GRIDMIN *((RAS(I, J, BI, BJ) ** 2
     > ))) / DELTATMOM)
            VDRAGTERMS(I, J) = (-(DRF(K) * RECIP_RAS(I, J, BI, BJ) *
     >  RECIP_DRF(K) * RECIP_HFACS(I, J, K, BI, BJ) *(RECIP_DXV(I, J,
     >  BI, BJ) * DYU(I, J, BI, BJ) * HFACZCLOSEDW + RECIP_DXV(I + 1, J
     > , BI, BJ) * DYU(I + 1, J, BI, BJ) * HFACZCLOSEDE) * 2.0D00 *(
     > COSFACV(J, BI, BJ) * VFLD(I, J) * AHTMP - COSFACV(J, BI, BJ) *
     >  DEL2V(I, J) * A4TMP)))
          END DO
        END DO
      ELSE
        DO J = -1, 42, 1
          DO I = -1, 92, 1
            HFACZCLOSEDW = HFACS(I, J, K, BI, BJ) - HFACS(I + (-1), J,
     >  K, BI, BJ)
            HFACZCLOSEDE = HFACS(I, J, K, BI, BJ) - HFACS(I + 1, J, K,
     >  BI, BJ)
            HFACZCLOSEDW = MAX(HFACZCLOSEDW, 0.0D00)
            HFACZCLOSEDE = MAX(HFACZCLOSEDE, 0.0D00)
            VDRAGTERMS(I, J) = (-(SIDEDRAGFACTOR * DRF(K) * RECIP_RAS(I
     > , J, BI, BJ) * RECIP_DRF(K) * RECIP_HFACS(I, J, K, BI, BJ) *(
     > RECIP_DXV(I, J, BI, BJ) * DYU(I, J, BI, BJ) * HFACZCLOSEDW *(
     > COSFACV(J, BI, BJ) * VFLD(I, J) * VISCAH_Z(I, J) - COSFACV(J, BI
     > , BJ) * DEL2V(I, J) * VISCA4_Z(I, J)) + RECIP_DXV(I + 1, J, BI,
     >  BJ) * DYU(I + 1, J, BI, BJ) * HFACZCLOSEDE *(COSFACV(J, BI, BJ)
     >  * VFLD(I, J) * VISCAH_Z(I + 1, J) - COSFACV(J, BI, BJ) * DEL2V(
     > I, J) * VISCA4_Z(I + 1, J)))))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE fill_cs_corner_tr_rl(FILL4DIR, WITHSIGNS, TRFLD, BI,
     >  BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) FILL4DIR
      LOGICAL(w2f__i4) WITHSIGNS
      REAL(w2f__8) TRFLD(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) NEGONE
      LOGICAL(w2f__i4) NORTHEASTCORNER
      LOGICAL(w2f__i4) NORTHWESTCORNER
      LOGICAL(w2f__i4) SOUTHEASTCORNER
      LOGICAL(w2f__i4) SOUTHWESTCORNER
C
C     **** Statements ****
C
      NEGONE = 1.0D00
      IF(WITHSIGNS) THEN
        NEGONE = -1.0D00
      ENDIF
      IF(USECUBEDSPHEREEXCHANGE) THEN
        SOUTHWESTCORNER = .TRUE.
        SOUTHEASTCORNER = .TRUE.
        NORTHWESTCORNER = .TRUE.
        NORTHEASTCORNER = .TRUE.
        IF(FILL4DIR .eq. 0) THEN
          IF(SOUTHWESTCORNER) THEN
            DO J = 1, 3, 1
              DO I = 1, 3, 1
                TRFLD(1 - I, 1 - J) = 0.0D00
              END DO
            END DO
          ENDIF
          IF(SOUTHEASTCORNER) THEN
            DO J = 1, 3, 1
              DO I = 1, 3, 1
                TRFLD(I + 90, 1 - J) = 0.0D00
              END DO
            END DO
          ENDIF
          IF(NORTHWESTCORNER) THEN
            DO J = 1, 3, 1
              DO I = 1, 3, 1
                TRFLD(1 - I, J + 40) = 0.0D00
              END DO
            END DO
          ENDIF
          IF(NORTHEASTCORNER) THEN
            DO J = 1, 3, 1
              DO I = 1, 3, 1
                TRFLD(I + 90, J + 40) = 0.0D00
              END DO
            END DO
          ENDIF
        ELSE
          IF(FILL4DIR .eq. 1) THEN
            IF(SOUTHWESTCORNER) THEN
              DO J = 1, 3, 1
                DO I = 1, 3, 1
                  TRFLD(1 - I, 1 - J) = (TRFLD(1 - J, I) * NEGONE)
                END DO
              END DO
            ENDIF
            IF(SOUTHEASTCORNER) THEN
              DO J = 1, 3, 1
                DO I = 1, 3, 1
                  TRFLD(I + 90, 1 - J) = (TRFLD(J + 90, I) * NEGONE)
                END DO
              END DO
            ENDIF
            IF(NORTHWESTCORNER) THEN
              DO J = 1, 3, 1
                DO I = 1, 3, 1
                  TRFLD(1 - I, J + 40) = (TRFLD(1 - J, 41 - I) * NEGONE
     > )
                END DO
              END DO
            ENDIF
            IF(NORTHEASTCORNER) THEN
              DO J = 1, 3, 1
                DO I = 1, 3, 1
                  TRFLD(I + 90, J + 40) = (TRFLD(J + 90, 41 - I) *
     >  NEGONE)
                END DO
              END DO
            ENDIF
          ELSE
            IF(FILL4DIR .eq. 2) THEN
              IF(SOUTHWESTCORNER) THEN
                DO J = 1, 3, 1
                  DO I = 1, 3, 1
                    TRFLD(1 - I, 1 - J) = (TRFLD(J, 1 - I) * NEGONE)
                  END DO
                END DO
              ENDIF
              IF(SOUTHEASTCORNER) THEN
                DO J = 1, 3, 1
                  DO I = 1, 3, 1
                    TRFLD(I + 90, 1 - J) = (TRFLD(91 - J, 1 - I) *
     >  NEGONE)
                  END DO
                END DO
              ENDIF
              IF(NORTHWESTCORNER) THEN
                DO J = 1, 3, 1
                  DO I = 1, 3, 1
                    TRFLD(1 - I, J + 40) = (TRFLD(J, I + 40) * NEGONE)
                  END DO
                END DO
              ENDIF
              IF(NORTHEASTCORNER) THEN
                DO J = 1, 3, 1
                  DO I = 1, 3, 1
                    TRFLD(I + 90, J + 40) = (TRFLD(91 - J, I + 40) *
     >  NEGONE)
                  END DO
                END DO
              ENDIF
            ELSE
              WRITE(*, *)
     >  'FILL_CS_CORNER_TR_RL: fill4dir has illegal value'
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE fill_cs_corner_uv_rs(WITHSIGNS, UFLD, VFLD, BI, BJ,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      LOGICAL(w2f__i4) WITHSIGNS
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) NEGONE
      LOGICAL(w2f__i4) NORTHEASTCORNER
      LOGICAL(w2f__i4) NORTHWESTCORNER
      LOGICAL(w2f__i4) SOUTHEASTCORNER
      LOGICAL(w2f__i4) SOUTHWESTCORNER
C
C     **** Statements ****
C
      IF(USECUBEDSPHEREEXCHANGE) THEN
        NEGONE = 1.0D00
        IF(WITHSIGNS) THEN
          NEGONE = -1.0D00
        ENDIF
        SOUTHWESTCORNER = .TRUE.
        SOUTHEASTCORNER = .TRUE.
        NORTHWESTCORNER = .TRUE.
        NORTHEASTCORNER = .TRUE.
        IF(SOUTHWESTCORNER) THEN
          DO J = 1, 3, 1
            DO I = 1, 3, 1
              UFLD(1 - I, 1 - J) = (VFLD(1 - J, I + 1) * NEGONE)
            END DO
          END DO
          DO J = 1, 3, 1
            DO I = 1, 3, 1
              VFLD(1 - I, 1 - J) = (UFLD(J + 1, 1 - I) * NEGONE)
            END DO
          END DO
        ENDIF
        IF(SOUTHEASTCORNER) THEN
          DO J = 1, 3, 1
            DO I = 2, 3, 1
              UFLD(I + 90, 1 - J) = VFLD(J + 90, I)
            END DO
          END DO
          DO J = 1, 3, 1
            DO I = 1, 3, 1
              VFLD(I + 90, 1 - J) = UFLD(91 - J, 1 - I)
            END DO
          END DO
        ENDIF
        IF(NORTHWESTCORNER) THEN
          DO J = 1, 3, 1
            DO I = 1, 3, 1
              UFLD(1 - I, J + 40) = VFLD(1 - J, 41 - I)
            END DO
          END DO
          DO J = 2, 3, 1
            DO I = 1, 3, 1
              VFLD(1 - I, J + 40) = UFLD(J, I + 40)
            END DO
          END DO
        ENDIF
        IF(NORTHEASTCORNER) THEN
          DO J = 1, 3, 1
            DO I = 2, 3, 1
              UFLD(I + 90, J + 40) = (VFLD(J + 90, 42 - I) * NEGONE)
            END DO
          END DO
          DO J = 2, 3, 1
            DO I = 1, 3, 1
              VFLD(I + 90, J + 40) = (UFLD(92 - J, I + 40) * NEGONE)
            END DO
          END DO
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE lef_zero(ARR, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) ARR(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ARR(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE adams_bashforth2(BI, BJ, K, GTRACER, GTRNM1, STARTAB,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) GTRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GTRNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) STARTAB
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) AB05
      REAL(w2f__8) AB15
      REAL(w2f__8) GTRTMP
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF((STARTAB .eq. 0) .AND.(MYITER .eq. NITER0)) THEN
        AB15 = 1.0D00
        AB05 = 0.0D00
      ELSE
        AB15 = ABEPS + 1.5D00
        AB05 = -(ABEPS + 5.0D-01)
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          GTRTMP = GTRACER(I, J, K, BI, BJ) * AB15 + GTRNM1(I, J, K, BI
     > , BJ) * AB05
          GTRNM1(I, J, K, BI, BJ) = GTRACER(I, J, K, BI, BJ)
          GTRACER(I, J, K, BI, BJ) = GTRTMP
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_3d_diffusivity(BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  TRIDENTITY, TRUSEGMREDI, TRUSEKPP, KAPPARTR, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) TRIDENTITY
      LOGICAL(w2f__i4) TRUSEGMREDI
      LOGICAL(w2f__i4) TRUSEKPP
      REAL(w2f__8) KAPPARTR(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL gmredi_calc_diff
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      REAL(w2f__8) KBRYANLEWIS79
      CHARACTER(512) MSGBUF
      EXTERNAL print_error
C
C     **** Statements ****
C
      IF(.NOT. TRUSEKPP) THEN
        DO K = 1, 15, 1
          KBRYANLEWIS79 = DIFFKRBL79SURF +((ATAN(-((RF(K) -
     >  DIFFKRBL79HO) / DIFFKRBL79SCL)) / 3.141592653589793116D00) +
     >  5.0D-01) *(DIFFKRBL79DEEP - DIFFKRBL79SURF)
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              KAPPARTR(I, J, K) = (KBRYANLEWIS79 + IVDCONVCOUNT(I, J, K
     > , BI, BJ) * IVDC_KAPPA)
            END DO
          END DO
        END DO
        IF(TRIDENTITY .eq. 1) THEN
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                KAPPARTR(I, J, K) = (DIFFKRNRT(K) + KAPPARTR(I, J, K))
              END DO
            END DO
          END DO
        ELSE
          IF(TRIDENTITY .eq. 2) THEN
            DO K = 1, 15, 1
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  KAPPARTR(I, J, K) = (DIFFKRNRS(K) + KAPPARTR(I, J, K)
     > )
                END DO
              END DO
            END DO
          ELSE
            WRITE(MSGBUF, '(A,I4)')
     >  ' CALC_3D_DIFFUSIVITY: Invalid tracer Id: ', TRIDENTITY
            CALL print_error(MSGBUF, MYTHID)
            WRITE(*, *) 'ABNORMAL END: S/R CALC_3D_DIFFUSIVITY'
          ENDIF
        ENDIF
      ENDIF
      IF(TRUSEGMREDI) THEN
        CALL gmredi_calc_diff(BI, BJ, IMIN, IMAX, JMIN, JMAX, (0), (15)
     > , KAPPARTR, TRIDENTITY, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_buoyancy(BI, BJ, IMIN, IMAX, JMIN, JMAX, K,
     >  RHOLOC, BUOY, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) RHOLOC(-2 : 93, -2 : 43)
      REAL(w2f__8) BUOY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(BUOYANCYRELATION .EQ. 'ATMOSPHERIC') THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            BUOY(I, J) = ((THETA(I, J, K, BI, BJ) - TREF(K)) / TREF(K))
          END DO
        END DO
      ELSE
        IF(BUOYANCYRELATION .EQ. 'OCEANIC') THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              BUOY(I, J) = (-(RHOLOC(I, J) * GRAVITY * RECIP_RHOCONST))
            END DO
          END DO
        ELSE
          IF(BUOYANCYRELATION .EQ. 'OCEANICP') THEN
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                IF(RHOLOC(I, J) .ne. 0.0D00) THEN
                  RHOLOC(I, J) = 1D00 / (RHOLOC(I, J))
                  BUOY(I, J) = RHOLOC(I, J)
                ENDIF
              END DO
            END DO
          ELSE
            WRITE(*, *)
     >  'CALC_BUOANCY: variable "buoyancyRelation" has an' //
     >  ' illegal value'
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_common_factors(UVEL, VVEL, UFLD, VFLD, UTRANS,
     >  VTRANS, XA, YA, K, BI, BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) UVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VVEL(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          XA(I, J) = (HFACW(I, J, K, BI, BJ) * DRF(K) * DEEPFACC(K) *
     >  DYG(I, J, BI, BJ))
          YA(I, J) = (HFACS(I, J, K, BI, BJ) * DRF(K) * DEEPFACC(K) *
     >  DXG(I, J, BI, BJ))
        END DO
      END DO
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          UFLD(I, J) = UVEL(I, J, K, BI, BJ)
          VFLD(I, J) = VVEL(I, J, K, BI, BJ)
        END DO
      END DO
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          UTRANS(I, J) = (RHOFACC(K) * UFLD(I, J) * XA(I, J))
          VTRANS(I, J) = (RHOFACC(K) * VFLD(I, J) * YA(I, J))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_diffusivity(BI, BJ, IMIN, IMAX, JMIN, JMAX, K,
     >  MASKUP, KAPPART, KAPPARS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) MASKUP(-2 : 93, -2 : 43)
      REAL(w2f__8) KAPPART(-2 : 93, -2 : 43)
      REAL(w2f__8) KAPPARS(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL gmredi_calc_diff
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) KBRYANLEWIS79
C
C     **** Statements ****
C
      IF(.NOT. USEKPP) THEN
        KBRYANLEWIS79 = DIFFKRBL79SURF +((ATAN(-((RF(K) - DIFFKRBL79HO)
     >  / DIFFKRBL79SCL)) / 3.141592653589793116D00) + 5.0D-01) *(
     > DIFFKRBL79DEEP - DIFFKRBL79SURF)
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            KAPPART(I, J) = (KBRYANLEWIS79 + DIFFKRNRT(K) +
     >  IVDCONVCOUNT(I, J, K, BI, BJ) * IVDC_KAPPA)
          END DO
        END DO
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            KAPPARS(I, J) = (KBRYANLEWIS79 + DIFFKRNRS(K) +
     >  IVDCONVCOUNT(I, J, K, BI, BJ) * IVDC_KAPPA)
          END DO
        END DO
      ENDIF
      IF(USEGMREDI) THEN
        CALL gmredi_calc_diff(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, (1),
     >  KAPPART, (1), MYTHID)
        CALL gmredi_calc_diff(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, (1),
     >  KAPPARS, (2), MYTHID)
      ENDIF
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          KAPPART(I, J) = (MASKUP(I, J) * KAPPART(I, J))
          KAPPARS(I, J) = (MASKUP(I, J) * KAPPARS(I, J))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_div_ghat(BI, BJ, K, CG2D_B, CG3D_B, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) CG2D_B(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) CG3D_B(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) PF(-2 : 93, -2 : 43)
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      DO J = 1, 41, 1
        DO I = 1, 91, 1
          XA(I, J) = (RHOFACC(K) * HFACW(I, J, K, BI, BJ) * DRF(K) *
     >  DEEPFACC(K) * DYG(I, J, BI, BJ))
          YA(I, J) = (RHOFACC(K) * HFACS(I, J, K, BI, BJ) * DRF(K) *
     >  DEEPFACC(K) * DXG(I, J, BI, BJ))
        END DO
      END DO
      IF(IMPLICDIV2DFLOW .eq. 1.0D00) THEN
        DO J = 1, 40, 1
          DO I = 1, 91, 1
            PF(I, J) = ((XA(I, J) * GU(I, J, K, BI, BJ)) / DELTATMOM)
          END DO
        END DO
      ELSE
        IF(EXACTCONSERV) THEN
          DO J = 1, 40, 1
            DO I = 1, 91, 1
              PF(I, J) = ((GU(I, J, K, BI, BJ) * XA(I, J) *
     >  IMPLICDIV2DFLOW) / DELTATMOM)
            END DO
          END DO
        ELSE
          DO J = 1, 40, 1
            DO I = 1, 91, 1
              PF(I, J) = ((XA(I, J) *(GU(I, J, K, BI, BJ) *
     >  IMPLICDIV2DFLOW + UVEL(I, J, K, BI, BJ) *(1.0D00 -
     >  IMPLICDIV2DFLOW))) / DELTATMOM)
            END DO
          END DO
        ENDIF
      ENDIF
      DO J = 1, 40, 1
        DO I = 1, 90, 1
          CG2D_B(I, J, BI, BJ) = (PF(I + 1, J) + CG2D_B(I, J, BI, BJ) -
     >  PF(I, J))
        END DO
      END DO
      IF(IMPLICDIV2DFLOW .eq. 1.0D00) THEN
        DO J = 1, 41, 1
          DO I = 1, 90, 1
            PF(I, J) = ((YA(I, J) * GV(I, J, K, BI, BJ)) / DELTATMOM)
          END DO
        END DO
      ELSE
        IF(EXACTCONSERV) THEN
          DO J = 1, 41, 1
            DO I = 1, 90, 1
              PF(I, J) = ((GV(I, J, K, BI, BJ) * YA(I, J) *
     >  IMPLICDIV2DFLOW) / DELTATMOM)
            END DO
          END DO
        ELSE
          DO J = 1, 41, 1
            DO I = 1, 90, 1
              PF(I, J) = ((YA(I, J) *(GV(I, J, K, BI, BJ) *
     >  IMPLICDIV2DFLOW + VVEL(I, J, K, BI, BJ) *(1.0D00 -
     >  IMPLICDIV2DFLOW))) / DELTATMOM)
            END DO
          END DO
        ENDIF
      ENDIF
      DO J = 1, 40, 1
        DO I = 1, 90, 1
          CG2D_B(I, J, BI, BJ) = (PF(I, J + 1) + CG2D_B(I, J, BI, BJ) -
     >  PF(I, J))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_grad_phi_hyd(K, BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  PHIHYDC, ALPHRHO, TFLD, SFLD, DPHIHYDX, DPHIHYDY, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) PHIHYDC(-2 : 93, -2 : 43)
      REAL(w2f__8) ALPHRHO(-2 : 93, -2 : 43)
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) DPHIHYDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DPHIHYDY(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) VARLOC(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      IF(.TRUE.) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            VARLOC(I, J) = (PHIHYDC(I, J) + PHI0SURF(I, J, BI, BJ))
          END DO
        END DO
      ENDIF
      DO J = JMIN, JMAX, 1
        DO I = IMIN + 1, IMAX, 1
          DPHIHYDX(I, J) = (RECIP_RHOFACC(K) * RECIP_DEEPFACC(K) *
     >  RECIP_DXC(I, J, BI, BJ) *(VARLOC(I, J) - VARLOC(I + (-1), J)))
        END DO
      END DO
      DO J = JMIN + 1, JMAX, 1
        DO I = IMIN, IMAX, 1
          DPHIHYDY(I, J) = (RECIP_RHOFACC(K) * RECIP_DEEPFACC(K) *
     >  RECIP_DYC(I, J, BI, BJ) *(VARLOC(I, J) - VARLOC(I, J + (-1))))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_grad_phi_surf(BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  ETAFLD, PHISURFX, PHISURFY, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) ETAFLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) PHISURFX(-2 : 93, -2 : 43)
      REAL(w2f__8) PHISURFY(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          PHISURFX(I, J) = (RECIP_DXC(I, J, BI, BJ) *(ETAFLD(I, J, BI,
     >  BJ) * BO_SURF(I, J, BI, BJ) - ETAFLD(I + (-1), J, BI, BJ) *
     >  BO_SURF(I + (-1), J, BI, BJ)))
        END DO
      END DO
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          PHISURFY(I, J) = (RECIP_DYC(I, J, BI, BJ) *(ETAFLD(I, J, BI,
     >  BJ) * BO_SURF(I, J, BI, BJ) - ETAFLD(I, J + (-1), BI, BJ) *
     >  BO_SURF(I, J + (-1), BI, BJ)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_gs(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KM1, KUP,
     >  KDOWN, XA, YA, MASKUP, UFLD, VFLD, WFLD, UTRANS, VTRANS, RTRANS
     > , RTRANSKP1, KAPPARS, FVERS, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use restart_mod
      use gad_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KUP
      INTEGER(w2f__i4) KDOWN
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKUP(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANSKP1(-2 : 93, -2 : 43)
      REAL(w2f__8) KAPPARS(-2 : 93, -2 : 43)
      REAL(w2f__8) FVERS(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL adams_bashforth2
      LOGICAL(w2f__i4) CALCADVECTION
      EXTERNAL external_forcing_s
      EXTERNAL gad_calc_rhs
      INTEGER(w2f__i4) ITERNB
C
C     **** Statements ****
C
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      ITDKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      KKEY = K + ITDKEY * 15 +(-15)
      CALCADVECTION = SALTADVECTION .AND.(.NOT. SALTMULTIDIMADVEC)
      ITERNB = MYITER
      IF(STAGGERTIMESTEP) THEN
        ITERNB = MYITER +(-1)
      ENDIF
      CALL gad_calc_rhs(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KM1, KUP,
     >  KDOWN, XA, YA, MASKUP, UFLD, VFLD, WFLD, UTRANS, VTRANS, RTRANS
     > , RTRANSKP1, DIFFKHS, DIFFK4S, KAPPARS, GSNM1, SALT, (2),
     >  SALTADVSCHEME, SALTVERTADVSCHEME, CALCADVECTION,
     >  SALTIMPLVERTADV, ADAMSBASHFORTH_S, USEGMREDI, USEKPP, FVERS, GS
     > , MYTIME, MYITER, MYTHID)
      IF(SALTFORCING .AND.(TRACFORCINGOUTAB .ne. 1)) THEN
        CALL external_forcing_s(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
      ENDIF
      IF(ADAMSBASHFORTHGS) THEN
        CALL adams_bashforth2(BI, BJ, K, GS, GSNM1, SALTSTARTAB, ITERNB
     > , MYTHID)
      ENDIF
      IF((TRACFORCINGOUTAB .eq. 1) .AND. SALTFORCING) THEN
        CALL external_forcing_s(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_gt(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KM1, KUP,
     >  KDOWN, XA, YA, MASKUP, UFLD, VFLD, WFLD, UTRANS, VTRANS, RTRANS
     > , RTRANSKP1, KAPPART, FVERT, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use restart_mod
      use gad_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KUP
      INTEGER(w2f__i4) KDOWN
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
      REAL(w2f__8) MASKUP(-2 : 93, -2 : 43)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANSKP1(-2 : 93, -2 : 43)
      REAL(w2f__8) KAPPART(-2 : 93, -2 : 43)
      REAL(w2f__8) FVERT(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL adams_bashforth2
      LOGICAL(w2f__i4) CALCADVECTION
      EXTERNAL external_forcing_t
      EXTERNAL gad_calc_rhs
      INTEGER(w2f__i4) ITERNB
C
C     **** Statements ****
C
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      ITDKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      KKEY = K + ITDKEY * 15 +(-15)
      CALCADVECTION = TEMPADVECTION .AND.(.NOT. TEMPMULTIDIMADVEC)
      ITERNB = MYITER
      IF(STAGGERTIMESTEP) THEN
        ITERNB = MYITER +(-1)
      ENDIF
      CALL gad_calc_rhs(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KM1, KUP,
     >  KDOWN, XA, YA, MASKUP, UFLD, VFLD, WFLD, UTRANS, VTRANS, RTRANS
     > , RTRANSKP1, DIFFKHT, DIFFK4T, KAPPART, GTNM1, THETA, (1),
     >  TEMPADVSCHEME, TEMPVERTADVSCHEME, CALCADVECTION,
     >  TEMPIMPLVERTADV, ADAMSBASHFORTH_T, USEGMREDI, USEKPP, FVERT, GT
     > , MYTIME, MYITER, MYTHID)
      IF(TEMPFORCING .AND.(TRACFORCINGOUTAB .ne. 1)) THEN
        CALL external_forcing_t(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
      ENDIF
      IF(ADAMSBASHFORTHGT) THEN
        CALL adams_bashforth2(BI, BJ, K, GT, GTNM1, TEMPSTARTAB, ITERNB
     > , MYTHID)
      ENDIF
      IF((TRACFORCINGOUTAB .eq. 1) .AND. TEMPFORCING) THEN
        CALL external_forcing_t(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_ivdc(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, RHOKM1,
     >  RHOKP1, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) RHOKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOKP1(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          IF((HFACC(I, J, K, BI, BJ) .GT. 0.0D00) .AND.((GRAVITYSIGN *
     >  RKSIGN *(RHOKM1(I, J) - RHOKP1(I, J))) .GT. 0.0D00)) THEN
            IVDCONVCOUNT(I, J, K, BI, BJ) = 1.0D00
          ELSE
            IVDCONVCOUNT(I, J, K, BI, BJ) = 0.0D00
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_phi_hyd(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, TFLD,
     >  SFLD, PHIHYDF, PHIHYDC, DPHIHYDX, DPHIHYDY, MYTIME, MYITER,
     >  MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      use tamc_mod
      use tamc_keys_mod
      use surface_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) PHIHYDF(-2 : 93, -2 : 43)
      REAL(w2f__8) PHIHYDC(-2 : 93, -2 : 43)
      REAL(w2f__8) DPHIHYDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DPHIHYDY(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      LOGICAL(w2f__i4) ADDSURFPHIANOM
      REAL(w2f__8) ALPHARHO(-2 : 93, -2 : 43)
      EXTERNAL calc_grad_phi_hyd
      REAL(w2f__8) DDPIM
      REAL(w2f__8) DDPIP
      REAL(w2f__8) DDRLOC
      EXTERNAL diags_phi_hyd
      EXTERNAL diags_phi_rlow
      REAL(w2f__8) DRLOCM
      REAL(w2f__8) DRLOCP
      EXTERNAL find_rho_2d
      REAL(w2f__8) HALF
      PARAMETER ( HALF = 5.0D-01)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) LOCALPHA
      EXTERNAL mom_quasihydrostatic
      REAL(w2f__8) ONE
      PARAMETER ( ONE = 1.0D00)
      REAL(w2f__8) REC_DRM
      REAL(w2f__8) REC_DRP
      REAL(w2f__8) SURFPHIFAC
      LOGICAL(w2f__i4) USEDIAGPHIRLOW
      REAL(w2f__8) ZERO
      PARAMETER ( ZERO = 0.0D00)
C
C     **** Statements ****
C
      USEDIAGPHIRLOW = .TRUE.
      ADDSURFPHIANOM = (SELECT_RSTAR .eq. 0) .AND.(NONLINFREESURF .GT.
     >  3)
      SURFPHIFAC = 0.0D00
      IF(ADDSURFPHIANOM) THEN
        SURFPHIFAC = 1.0D00
      ENDIF
      ACT1 = BI - MYBXLO(MYTHID)
      MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
      ACT2 = BJ - MYBYLO(MYTHID)
      MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
      ACT3 = MYTHID +(-1)
      MAX3 = NTX * NTY
      ACT4 = IKEY_DYNAMICS +(-1)
      IKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
      IF(K .eq. 1) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            PHIHYDF(I, J) = 0.0D00
          END DO
        END DO
      ENDIF
      IF(BUOYANCYRELATION .EQ. 'OCEANIC') THEN
        IF(IMPLICITINTGRAVWAVE .OR.(MYITER .LT. 0)) THEN
          KKEY = K + IKEY * 15 +(-15)
          CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, K, TFLD((-2), (-2),
     >  K, BI, BJ), SFLD((-2), (-2), K, BI, BJ), ALPHARHO, K, BI, BJ,
     >  MYTHID)
        ELSE
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              ALPHARHO(I, J) = RHOINSITU(I, J, K, BI, BJ)
            END DO
          END DO
        ENDIF
        IF(QUASIHYDROSTATIC) THEN
          CALL mom_quasihydrostatic(BI, BJ, K, UVEL, VVEL, ALPHARHO,
     >  MYTHID)
        ENDIF
        IF(INTEGR_GEOPOT .eq. 1) THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              PHIHYDC(I, J) = (PHIHYDF(I, J) + RECIP_RHOCONST *
     >  ALPHARHO(I, J) * GRAVITY * DRF(K) * 5.0D-01)
              PHIHYDF(I, J) = (PHIHYDF(I, J) + RECIP_RHOCONST *
     >  ALPHARHO(I, J) * DRF(K) * GRAVITY)
            END DO
          END DO
        ELSE
          DRLOCM = DRC(K) * 5.0D-01
          IF(K .eq. 1) THEN
            DRLOCM = RF(K) - RC(K)
          ENDIF
          IF(K .eq. 15) THEN
            DRLOCP = RC(K) - RF(K + 1)
          ELSE
            DRLOCP = DRC(K + 1) * 5.0D-01
          ENDIF
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              PHIHYDC(I, J) = (PHIHYDF(I, J) + RECIP_RHOCONST *
     >  ALPHARHO(I, J) * DRLOCM * GRAVITY)
              PHIHYDF(I, J) = (PHIHYDC(I, J) + RECIP_RHOCONST *
     >  ALPHARHO(I, J) * DRLOCP * GRAVITY)
            END DO
          END DO
        ENDIF
      ELSE
        IF(BUOYANCYRELATION .EQ. 'OCEANICP') THEN
          IF(IMPLICITINTGRAVWAVE .OR.(MYITER .LT. 0)) THEN
            KKEY = K + IKEY * 15 +(-15)
            CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, K, TFLD((-2), (-2)
     > , K, BI, BJ), SFLD((-2), (-2), K, BI, BJ), ALPHARHO, K, BI, BJ,
     >  MYTHID)
          ELSE
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                ALPHARHO(I, J) = RHOINSITU(I, J, K, BI, BJ)
              END DO
            END DO
          ENDIF
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              LOCALPHA = ALPHARHO(I, J) + RHOCONST
              ALPHARHO(I, J) = (MASKC(I, J, K, BI, BJ) *(1D00 /
     >  LOCALPHA - RECIP_RHOCONST))
            END DO
          END DO
          IF(INTEGR_GEOPOT .eq. 1) THEN
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                IF(KSURFC(I, J, BI, BJ) .eq. K) THEN
                  DDRLOC = RO_SURF(I, J, BI, BJ) - RC(K)
                  PHIHYDC(I, J) = (ALPHARHO(I, J) * DDRLOC)
                ELSE
                  PHIHYDC(I, J) = (PHIHYDF(I, J) + ALPHARHO(I, J) * DRF
     > (K) * 5.0D-01)
                ENDIF
                PHIHYDF(I, J) = (PHIHYDC(I, J) + ALPHARHO(I, J) * DRF(K
     > ) * 5.0D-01)
              END DO
            END DO
          ELSE
            DRLOCM = DRC(K) * 5.0D-01
            IF(K .eq. 1) THEN
              DRLOCM = RF(K) - RC(K)
            ENDIF
            IF(K .eq. 15) THEN
              DRLOCP = RC(K) - RF(K + 1)
            ELSE
              DRLOCP = DRC(K + 1) * 5.0D-01
            ENDIF
            REC_DRM = 1D00 / (RF(K) - RC(K))
            REC_DRP = 1D00 / (RC(K) - RF(K + 1))
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                IF(KSURFC(I, J, BI, BJ) .eq. K) THEN
                  DDRLOC = RO_SURF(I, J, BI, BJ) - RC(K)
                  PHIHYDC(I, J) = (ALPHARHO(I, J) *(DRLOCM * REC_DRM *
     >  MAX(DDRLOC, 0.0D00) + DRLOCP * REC_DRP * MIN(DDRLOC, 0.0D00)))
                ELSE
                  PHIHYDC(I, J) = (PHIHYDF(I, J) + ALPHARHO(I, J) *
     >  DRLOCM)
                ENDIF
                PHIHYDF(I, J) = (PHIHYDC(I, J) + ALPHARHO(I, J) *
     >  DRLOCP)
              END DO
            END DO
          ENDIF
        ELSE
          IF(BUOYANCYRELATION .EQ. 'ATMOSPHERIC') THEN
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                ALPHARHO(I, J) = (MASKC(I, J, K, BI, BJ) *(TFLD(I, J, K
     > , BI, BJ) *(SFLD(I, J, K, BI, BJ) * ATM_RQ + 1.0D00) - TREF(K)))
              END DO
            END DO
            IF(INTEGR_GEOPOT .eq. 0) THEN
              IF(K .eq. 1) THEN
                DDPIM = ATM_CP *((((RF(K) / ATM_PO) ** ATM_KAPPA)) -(((
     > RC(K) / ATM_PO) ** ATM_KAPPA)))
              ELSE
                DDPIM = ATM_CP *((((RC(K + (-1)) / ATM_PO) ** ATM_KAPPA
     > )) -(((RC(K) / ATM_PO) ** ATM_KAPPA))) * 5.0D-01
              ENDIF
              IF(K .eq. 15) THEN
                DDPIP = ATM_CP *((((RC(K) / ATM_PO) ** ATM_KAPPA)) -(((
     > RF(K + 1) / ATM_PO) ** ATM_KAPPA)))
              ELSE
                DDPIP = ATM_CP *((((RC(K) / ATM_PO) ** ATM_KAPPA)) -(((
     > RC(K + 1) / ATM_PO) ** ATM_KAPPA))) * 5.0D-01
              ENDIF
              DO J = JMIN, JMAX, 1
                DO I = IMIN, IMAX, 1
                  PHIHYDC(I, J) = (PHIHYDF(I, J) + ALPHARHO(I, J) *
     >  DDPIM)
                  PHIHYDF(I, J) = (PHIHYDC(I, J) + ALPHARHO(I, J) *
     >  DDPIP)
                END DO
              END DO
            ELSE
              IF(INTEGR_GEOPOT .eq. 1) THEN
                DDPIM = ATM_CP *((((RF(K) / ATM_PO) ** ATM_KAPPA)) -(((
     > RC(K) / ATM_PO) ** ATM_KAPPA)))
                DDPIP = ATM_CP *((((RC(K) / ATM_PO) ** ATM_KAPPA)) -(((
     > RF(K + 1) / ATM_PO) ** ATM_KAPPA)))
                DO J = JMIN, JMAX, 1
                  DO I = IMIN, IMAX, 1
                    IF(KSURFC(I, J, BI, BJ) .eq. K) THEN
                      DDRLOC = RO_SURF(I, J, BI, BJ) - RC(K)
                      PHIHYDC(I, J) = (ALPHARHO(I, J) * DDPIM *
     >  RECIP_DRF(K) * DDRLOC * 2.0D00)
                    ELSE
                      PHIHYDC(I, J) = (PHIHYDF(I, J) + ALPHARHO(I, J) *
     >  DDPIM)
                    ENDIF
                    PHIHYDF(I, J) = (PHIHYDC(I, J) + ALPHARHO(I, J) *
     >  DDPIP)
                  END DO
                END DO
              ELSE
                IF((INTEGR_GEOPOT .eq. 2) .OR.(INTEGR_GEOPOT .eq. 3))
     >  THEN
                  IF(K .eq. 1) THEN
                    DDPIM = ATM_CP *((((RF(K) / ATM_PO) ** ATM_KAPPA))
     >  -(((RC(K) / ATM_PO) ** ATM_KAPPA)))
                  ELSE
                    DDPIM = ATM_CP *((((RC(K + (-1)) / ATM_PO) **
     >  ATM_KAPPA)) -(((RC(K) / ATM_PO) ** ATM_KAPPA))) * 5.0D-01
                  ENDIF
                  IF(K .eq. 15) THEN
                    DDPIP = ATM_CP *((((RC(K) / ATM_PO) ** ATM_KAPPA))
     >  -(((RF(K + 1) / ATM_PO) ** ATM_KAPPA)))
                  ELSE
                    DDPIP = ATM_CP *((((RC(K) / ATM_PO) ** ATM_KAPPA))
     >  -(((RC(K + 1) / ATM_PO) ** ATM_KAPPA))) * 5.0D-01
                  ENDIF
                  REC_DRM = 1D00 / (RF(K) - RC(K))
                  REC_DRP = 1D00 / (RC(K) - RF(K + 1))
                  DO J = JMIN, JMAX, 1
                    DO I = IMIN, IMAX, 1
                      IF(KSURFC(I, J, BI, BJ) .eq. K) THEN
                        DDRLOC = RO_SURF(I, J, BI, BJ) - RC(K)
                        PHIHYDC(I, J) = (ALPHARHO(I, J) *(DDPIM *
     >  REC_DRM * MAX(DDRLOC, 0.0D00) + DDPIP * REC_DRP * MIN(DDRLOC,
     >  0.0D00)))
                      ELSE
                        PHIHYDC(I, J) = (PHIHYDF(I, J) + ALPHARHO(I, J)
     >  * DDPIM)
                      ENDIF
                      PHIHYDF(I, J) = (PHIHYDC(I, J) + ALPHARHO(I, J) *
     >  DDPIP)
                    END DO
                  END DO
                ELSE
                  WRITE(*, *)
     >  'CALC_PHI_HYD: Bad integr_GeoPot option !'
                ENDIF
              ENDIF
            ENDIF
          ELSE
            WRITE(*, *) 'CALC_PHI_HYD: Bad value of buoyancyRelation !'
          ENDIF
        ENDIF
      ENDIF
      IF(USEDIAGPHIRLOW) THEN
        CALL diags_phi_rlow(K, BI, BJ, IMIN, IMAX, JMIN, JMAX, PHIHYDF,
     >  PHIHYDC, ALPHARHO, TFLD, SFLD, MYTIME, MYITER, MYTHID)
      ENDIF
      CALL diags_phi_hyd(K, BI, BJ, IMIN, IMAX, JMIN, JMAX, PHIHYDC,
     >  MYTIME, MYITER, MYTHID)
      IF(MOMPRESSUREFORCING) THEN
        CALL calc_grad_phi_hyd(K, BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  PHIHYDC, ALPHARHO, TFLD, SFLD, DPHIHYDX, DPHIHYDY, MYTIME,
     >  MYITER, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_surf_dr(ETAFLD, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) ETAFLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_viscosity(BI, BJ, IMIN, IMAX, JMIN, JMAX, KAPPARU
     > , KAPPARV, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) KAPPARU(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) KAPPARV(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO K = 1, 15, 1
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            KAPPARU(I, J, K) = VISCAR
            KAPPARV(I, J, K) = VISCAR
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_wsurf_tr(THETAFLD, SALTFLD, WVELFLD, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) THETAFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) SALTFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WVELFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL global_sum_tile_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KS
      REAL(w2f__8) WS_MEAN
      REAL(w2f__8) WS_TILE(1 : 1, 1 : 1)
      REAL(w2f__8) WT_MEAN
      REAL(w2f__8) WT_TILE(1 : 1, 1 : 1)
C
C     **** Statements ****
C
      TSURFCOR = 0.0D00
      SSURFCOR = 0.0D00
      WT_MEAN = 0.0D00
      WS_MEAN = 0.0D00
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          WT_TILE(BI, BJ) = 0.0D00
          WS_TILE(BI, BJ) = 0.0D00
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              KS = KSURFC(I, J, BI, BJ)
              IF(KS .LE. 15) THEN
                WT_TILE(BI, BJ) = (WT_TILE(BI, BJ) + THETAFLD(I, J, KS,
     >  BI, BJ) * RA(I, J, BI, BJ) * WVELFLD(I, J, KS, BI, BJ))
                WS_TILE(BI, BJ) = (WS_TILE(BI, BJ) + SALTFLD(I, J, KS,
     >  BI, BJ) * RA(I, J, BI, BJ) * WVELFLD(I, J, KS, BI, BJ))
              ENDIF
            END DO
          END DO
        END DO
      END DO
      CALL global_sum_tile_rl(WT_TILE, WT_MEAN, MYTHID)
      CALL global_sum_tile_rl(WS_TILE, WS_MEAN, MYTHID)
      IF(GLOBALAREA .GT. 0.0D00) THEN
        IF(MYTHID .eq. 1) THEN
          TSURFCOR = WT_MEAN / GLOBALAREA
          SSURFCOR = WS_MEAN / GLOBALAREA
        ENDIF
      ENDIF
      CALL barrier(MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE cg2d_nsa(CG2D_B, CG2D_X, FIRSTRESIDUAL, LASTRESIDUAL,
     >  NUMITERS, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use cg2d_mod
      use surface_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) CG2D_B(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) CG2D_X(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) FIRSTRESIDUAL
      REAL(w2f__8) LASTRESIDUAL
      INTEGER(w2f__i4) NUMITERS
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE convective_adjustment(BI, BJ, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) CONVECTCOUNT(-2 : 93, -2 : 43, 1 : 15)
      EXTERNAL convectively_mixtracer
      EXTERNAL convective_weights
      INTEGER(w2f__i4) DELTAK
      EXTERNAL different_multiple
      LOGICAL(w2f__i4) different_multiple
      EXTERNAL find_rho_2d
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KBOTTOM
      INTEGER(w2f__i4) KDIR
      INTEGER(w2f__i4) KTOP
      REAL(w2f__8) RHOK(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) WEIGHTA(-2 : 93, -2 : 43)
      REAL(w2f__8) WEIGHTB(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      IF(different_multiple(CADJFREQ, MYTIME, DELTATCLOCK)) THEN
        IMIN = -2
        IMAX = 93
        JMIN = -2
        JMAX = 43
        KTOP = 0
        KBOTTOM = 0
        KDIR = 0
        DELTAK = 0
        DO K = 1, 15, 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              CONVECTCOUNT(I, J, K) = 0.0D00
            END DO
          END DO
        END DO
        ACT1 = BI - MYBXLO(MYTHID)
        MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
        ACT2 = BJ - MYBYLO(MYTHID)
        MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
        ACT3 = MYTHID +(-1)
        MAX3 = NTX * NTY
        ACT4 = IKEY_DYNAMICS +(-1)
        IKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
        IF((GRAVITYSIGN * RKSIGN) .GT. 0.0D00) THEN
          KTOP = 2
          KBOTTOM = 15
          KDIR = 1
          DELTAK = -1
        ELSE
          KTOP = 15
          KBOTTOM = 2
          KDIR = -1
          DELTAK = 0
        ENDIF
        DO K = KTOP, KBOTTOM, KDIR
          KKEY = K + IKEY * 15 +(-15)
          CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, (DELTAK + K), THETA(
     > (-2), (-2), K + (-1), BI, BJ), SALT((-2), (-2), K + (-1), BI, BJ
     > ), RHOKM1, (K +(-1)), BI, BJ, MYTHID)
          CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, (DELTAK + K), THETA(
     > (-2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOK, (K),
     >  BI, BJ, MYTHID)
          CALL convective_weights(BI, BJ, (K), RHOKM1, RHOK, WEIGHTA,
     >  WEIGHTB, CONVECTCOUNT, MYTHID)
          CALL convectively_mixtracer(BI, BJ, (K), WEIGHTA, WEIGHTB,
     >  THETA, MYTHID)
          CALL convectively_mixtracer(BI, BJ, (K), WEIGHTA, WEIGHTB,
     >  SALT, MYTHID)
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE convective_adjustment_ini(BI, BJ, MYTIME, MYITER,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) CONVECTCOUNT(-2 : 93, -2 : 43, 1 : 15)
      EXTERNAL convectively_mixtracer
      EXTERNAL convective_weights
      INTEGER(w2f__i4) DELTAK
      EXTERNAL different_multiple
      LOGICAL(w2f__i4) different_multiple
      EXTERNAL find_rho_2d
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KBOTTOM
      INTEGER(w2f__i4) KDIR
      INTEGER(w2f__i4) KTOP
      REAL(w2f__8) RHOK(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) WEIGHTA(-2 : 93, -2 : 43)
      REAL(w2f__8) WEIGHTB(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      IF(different_multiple(CADJFREQ, MYTIME, DELTATCLOCK)) THEN
        IMIN = -2
        IMAX = 93
        JMIN = -2
        JMAX = 43
        KTOP = 0
        KBOTTOM = 0
        KDIR = 0
        DELTAK = 0
        DO K = 1, 15, 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              CONVECTCOUNT(I, J, K) = 0.0D00
            END DO
          END DO
        END DO
        ACT1 = BI - MYBXLO(MYTHID)
        MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
        ACT2 = BJ - MYBYLO(MYTHID)
        MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
        ACT3 = MYTHID +(-1)
        MAX3 = NTX * NTY
        ACT4 = 0
        IKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 * MAX2 *
     >  ACT4 * MAX1 + 1
        IF((GRAVITYSIGN * RKSIGN) .GT. 0.0D00) THEN
          KTOP = 2
          KBOTTOM = 15
          KDIR = 1
          DELTAK = -1
        ELSE
          KTOP = 15
          KBOTTOM = 2
          KDIR = -1
          DELTAK = 0
        ENDIF
        DO K = KTOP, KBOTTOM, KDIR
          KKEY = K + IKEY * 15 +(-15)
          CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, (DELTAK + K), THETA(
     > (-2), (-2), K + (-1), BI, BJ), SALT((-2), (-2), K + (-1), BI, BJ
     > ), RHOKM1, (K +(-1)), BI, BJ, MYTHID)
          CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, (DELTAK + K), THETA(
     > (-2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOK, (K),
     >  BI, BJ, MYTHID)
          CALL convective_weights(BI, BJ, (K), RHOKM1, RHOK, WEIGHTA,
     >  WEIGHTB, CONVECTCOUNT, MYTHID)
          CALL convectively_mixtracer(BI, BJ, (K), WEIGHTA, WEIGHTB,
     >  THETA, MYTHID)
          CALL convectively_mixtracer(BI, BJ, (K), WEIGHTA, WEIGHTB,
     >  SALT, MYTHID)
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE convective_weights(BI, BJ, K, RHOKM1, RHOK, WEIGHTA,
     >  WEIGHTB, CONVECTCOUNT, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) RHOKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOK(-2 : 93, -2 : 43)
      REAL(w2f__8) WEIGHTA(-2 : 93, -2 : 43)
      REAL(w2f__8) WEIGHTB(-2 : 93, -2 : 43)
      REAL(w2f__8) CONVECTCOUNT(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) D1
      REAL(w2f__8) D2
      REAL(w2f__8) DS
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          IF(((HFACC(I, J, K, BI, BJ) * HFACC(I, J, K + (-1), BI, BJ))
     >  .GT. 0.0D00) .AND.((GRAVITYSIGN * RKSIGN *(RHOKM1(I, J) - RHOK(
     > I, J))) .GT. 0.0D00)) THEN
            D1 = DRF(K + (-1)) * HFACC(I, J, K + (-1), BI, BJ)
            D2 = DRF(K) * HFACC(I, J, K, BI, BJ)
            DS = D1 + D2
            WEIGHTA(I, J) = (D2 / DS)
            WEIGHTB(I, J) = (D1 / DS)
            CONVECTCOUNT(I, J, K) = (CONVECTCOUNT(I, J, K) + 1.0D00)
          ELSE
            WEIGHTA(I, J) = 0.0D00
            WEIGHTB(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE convectively_mixtracer(BI, BJ, K, WEIGHTA, WEIGHTB,
     >  TRACER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) WEIGHTA(-2 : 93, -2 : 43)
      REAL(w2f__8) WEIGHTB(-2 : 93, -2 : 43)
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DELTRAC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          DELTRAC = TRACER(I, J, K, BI, BJ) - TRACER(I, J, K + (-1), BI
     > , BJ)
          TRACER(I, J, K + (-1), BI, BJ) = (TRACER(I, J, K + (-1), BI,
     >  BJ) + WEIGHTA(I, J) * DELTRAC)
          TRACER(I, J, K, BI, BJ) = (TRACER(I, J, K, BI, BJ) - WEIGHTB(
     > I, J) * DELTRAC)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE correction_step(BI, BJ, IMIN, IMAX, JMIN, JMAX, K,
     >  PHISURFX, PHISURFY, MYTIME, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) PHISURFX(-2 : 93, -2 : 43)
      REAL(w2f__8) PHISURFY(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) HX3DFAC
      REAL(w2f__8) HXFAC
      REAL(w2f__8) HY3DFAC
      REAL(w2f__8) HYFAC
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      HXFAC = RECIP_RHOFACC(K) * RECIP_DEEPFACC(K) * PFFACMOM
      HYFAC = RECIP_RHOFACC(K) * RECIP_DEEPFACC(K) * PFFACMOM
      IF(USE3DSOLVER) THEN
        HX3DFAC = RECIP_RHOFACC(K) * RECIP_DEEPFACC(K) * PFFACMOM
        HY3DFAC = RECIP_RHOFACC(K) * RECIP_DEEPFACC(K) * PFFACMOM
      ELSE
        HX3DFAC = 0.0D00
        HY3DFAC = 0.0D00
      ENDIF
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          UVEL(I, J, K, BI, BJ) = (MASKW(I, J, K, BI, BJ) *(GU(I, J, K,
     >  BI, BJ) - PHISURFX(I, J) * IMPLICSURFPRESS * HXFAC * DELTATMOM)
     > )
        END DO
      END DO
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          VVEL(I, J, K, BI, BJ) = (MASKS(I, J, K, BI, BJ) *(GV(I, J, K,
     >  BI, BJ) - PHISURFY(I, J) * IMPLICSURFPRESS * HYFAC * DELTATMOM)
     > )
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE cycle_tracer(BI, BJ, TRACER, GTRACER, MYTIME, MYITER,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GTRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO K = 1, 15, 1
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            TRACER(I, J, K, BI, BJ) = GTRACER(I, J, K, BI, BJ)
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE diags_phi_hyd(K, BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  PHIHYDC, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) PHIHYDC(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          TOTPHIHYD(I, J, K, BI, BJ) = (PHI0SURF(I, J, BI, BJ) +
     >  PHIHYDC(I, J) + ETAN(I, J, BI, BJ) * BO_SURF(I, J, BI, BJ))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE diags_phi_rlow(K, BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  PHIHYDF, PHIHYDC, ALPHRHO, TFLD, SFLD, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) PHIHYDF(-2 : 93, -2 : 43)
      REAL(w2f__8) PHIHYDC(-2 : 93, -2 : 43)
      REAL(w2f__8) ALPHRHO(-2 : 93, -2 : 43)
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DDRLOC
      REAL(w2f__8) HALF
      PARAMETER ( HALF = 5.0D-01)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) ONE
      PARAMETER ( ONE = 1.0D00)
      REAL(w2f__8) RATIORM
      REAL(w2f__8) RATIORP
      REAL(w2f__8) ZERO
      PARAMETER ( ZERO = 0.0D00)
C
C     **** Statements ****
C
      IF(BUOYANCYRELATION .EQ. 'OCEANIC') THEN
        IF(INTEGR_GEOPOT .eq. 1) THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              IF(KLOWC(I, J, BI, BJ) .eq. K) THEN
                DDRLOC = RC(K) - R_LOW(I, J, BI, BJ)
                PHIHYDLOW(I, J, BI, BJ) = (PHIHYDC(I, J) +
     >  RECIP_RHOCONST * ALPHRHO(I, J) * DDRLOC * GRAVITY)
              ENDIF
            END DO
          END DO
        ELSE
          RATIORM = 1.0D00
          RATIORP = 1.0D00
          IF(K .GT. 1) THEN
            RATIORM = (DRC(K) * 5.0D-01) /(RF(K) - RC(K))
          ENDIF
          IF(K .LT. 15) THEN
            RATIORP = (DRC(K + 1) * 5.0D-01) /(RC(K) - RF(K + 1))
          ENDIF
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              IF(KLOWC(I, J, BI, BJ) .eq. K) THEN
                DDRLOC = RC(K) - R_LOW(I, J, BI, BJ)
                PHIHYDLOW(I, J, BI, BJ) = (PHIHYDC(I, J) +
     >  RECIP_RHOCONST * ALPHRHO(I, J) * GRAVITY *(RATIORM * MIN(DDRLOC
     > , 0.0D00) + RATIORP * MAX(DDRLOC, 0.0D00)))
              ENDIF
            END DO
          END DO
        ENDIF
      ENDIF
      IF(K .eq. 15) THEN
        IF((BUOYANCYRELATION .EQ. 'OCEANICP') .OR.(BUOYANCYRELATION
     >  .EQ. 'ATMOSPHERIC')) THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              PHIHYDLOW(I, J, BI, BJ) = PHIHYDF(I, J)
            END DO
          END DO
        ENDIF
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            PHIHYDLOW(I, J, BI, BJ) = (PHI0SURF(I, J, BI, BJ) +
     >  PHIHYDLOW(I, J, BI, BJ) + ETAN(I, J, BI, BJ) * BO_SURF(I, J, BI
     > , BJ))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE diags_rho_l(K, BI, BJ, RHOK, RHOKM1, WFLD, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) RHOK(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE diags_rho_g(RHO3D, UFLD, VFLD, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) RHO3D(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE do_atmospheric_phys(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_enter
      EXTERNAL debug_leave
C
C     **** Statements ****
C
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_enter('DO_ATMOSPHERIC_PHYS', MYTHID)
      ENDIF
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_leave('DO_ATMOSPHERIC_PHYS', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE do_fields_blocking_exchanges(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use gad_mod
      use cd_code_vars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL exch_3d_rl
      EXTERNAL exch_uv_xyz_rl
      EXTERNAL exch_xyz_rl
      EXTERNAL gad_som_exchanges
C
C     **** Statements ****
C
      IF(.NOT. USEOFFLINE) THEN
        IF(.NOT.(STAGGERTIMESTEP .AND. USEMULTIDIMADVEC)) THEN
          CALL exch_uv_xyz_rl(UVEL, VVEL, (.TRUE.), MYTHID)
          IF(.NOT. IMPLICITINTGRAVWAVE) THEN
            CALL exch_xyz_rl(WVEL, MYTHID)
          ENDIF
        ENDIF
        IF(.NOT. IMPLICITINTGRAVWAVE) THEN
          CALL exch_xyz_rl(THETA, MYTHID)
          CALL exch_xyz_rl(SALT, MYTHID)
        ENDIF
        IF(SALTSOM_ADVECTION .OR. TEMPSOM_ADVECTION) THEN
          CALL gad_som_exchanges(MYTHID)
        ENDIF
        CALL exch_3d_rl(UVELD, (15), MYTHID)
        CALL exch_3d_rl(VVELD, (15), MYTHID)
        IF(USEDYNP_INEOS_ZC) THEN
          CALL exch_xyz_rl(TOTPHIHYD, MYTHID)
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE do_oceanic_phys(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use tamc_mod
      use tamc_keys_mod
      use ffields_mod
      use surface_mod
      use eos_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL calc_ivdc
      EXTERNAL calc_oce_mxlayer
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL debug_msg
      INTEGER(w2f__i4) DODIAGSRHO
      EXTERNAL external_forcing_surf
      EXTERNAL find_rho_2d
      EXTERNAL freeze_surface
      EXTERNAL gmredi_calc_tensor
      EXTERNAL gmredi_calc_tensor_dummy
      EXTERNAL grad_sigma
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) K
      REAL(w2f__8) RHOKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOKP1(-2 : 93, -2 : 43)
      REAL(w2f__8) SIGMAR(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAX(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAY(-2 : 93, -2 : 43, 1 : 15)
C
C     **** Statements ****
C
      ITDKEY = 1
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_enter('DO_OCEANIC_PHYS', MYTHID)
      ENDIF
      DODIAGSRHO = 0
      IF(ALLOWFREEZING) THEN
        CALL freeze_surface(MYTIME, MYITER, MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          ACT1 = BI - MYBXLO(MYTHID)
          MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
          ACT2 = BJ - MYBYLO(MYTHID)
          MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
          ACT3 = MYTHID +(-1)
          MAX3 = NTX * NTY
          ACT4 = IKEY_DYNAMICS +(-1)
          ITDKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 *
     >  MAX2 * ACT4 * MAX1 + 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              RHOKM1(I, J) = 0.0D00
              RHOKP1(I, J) = 0.0D00
            END DO
          END DO
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                SIGMAX(I, J, K) = 0.0D00
                SIGMAY(I, J, K) = 0.0D00
                SIGMAR(I, J, K) = 0.0D00
                IVDCONVCOUNT(I, J, K, BI, BJ) = 0.0D00
                KWX(I, J, K, BI, BJ) = 0.0D00
                KWY(I, J, K, BI, BJ) = 0.0D00
                KWZ(I, J, K, BI, BJ) = 0.0D00
                KUX(I, J, K, BI, BJ) = 0.0D00
                KVY(I, J, K, BI, BJ) = 0.0D00
                KUZ(I, J, K, BI, BJ) = 0.0D00
                KVZ(I, J, K, BI, BJ) = 0.0D00
                GM_PSIX(I, J, K, BI, BJ) = 0.0D00
                GM_PSIY(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
            END DO
          END DO
          IMIN = -2
          IMAX = 93
          JMIN = -2
          JMAX = 43
          IF(DEBUGLEVEL .GE. 2) THEN
            CALL debug_msg('ENTERING UPWARD K LOOP', MYTHID)
          ENDIF
          DO K = 15, 1, (-1)
            KKEY = K + ITDKEY * 15 +(-15)
            IF(DEBUGLEVEL .GE. 2) THEN
              CALL debug_call('FIND_RHO_2D', MYTHID)
            ENDIF
            IF(FLUIDISWATER) THEN
              CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, (K), THETA((-2),
     >  (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOINSITU((-2),
     >  (-2), K, BI, BJ), (K), (BI), (BJ), MYTHID)
            ELSE
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  RHOINSITU(I, J, K, BI, BJ) = 0.0D00
                END DO
              END DO
            ENDIF
            IF((DODIAGSRHO .GE. 1) .OR.(USESALT_PLUME .OR.(USEGMREDI
     >  .OR.((K .GT. 1) .AND.(IVDC_KAPPA .ne. 0.0D00))))) THEN
              IF(K .GT. 1) THEN
                CALL find_rho_2d(IMIN, IMAX, JMIN, JMAX, (K), THETA((-2
     > ), (-2), K + (-1), BI, BJ), SALT((-2), (-2), K + (-1), BI, BJ),
     >  RHOKM1, (K +(-1)), (BI), (BJ), MYTHID)
              ENDIF
              IF(DEBUGLEVEL .GE. 2) THEN
                CALL debug_call('GRAD_SIGMA', MYTHID)
              ENDIF
              DO J = JMIN, JMAX, 1
                DO I = IMIN, IMAX, 1
                  RHOKP1(I, J) = RHOINSITU(I, J, K, BI, BJ)
                END DO
              END DO
              CALL grad_sigma((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K),
     >  RHOINSITU((-2), (-2), K, BI, BJ), RHOKM1, RHOKP1, SIGMAX,
     >  SIGMAY, SIGMAR, MYTHID)
            ENDIF
            IF((K .GT. 1) .AND.(IVDC_KAPPA .ne. 0.0D00)) THEN
              IF(DEBUGLEVEL .GE. 2) THEN
                CALL debug_call('CALC_IVDC', MYTHID)
              ENDIF
              CALL calc_ivdc((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K),
     >  RHOKM1, RHOINSITU((-2), (-2), K, BI, BJ), MYTIME, MYITER,
     >  MYTHID)
            ENDIF
          END DO
          IF((DODIAGSRHO .GE. 4) .OR. USEGMREDI) THEN
            CALL calc_oce_mxlayer(RHOINSITU((-2), (-2), 1, BI, BJ),
     >  SIGMAR, (BI), (BJ), MYTIME, MYITER, MYTHID)
          ENDIF
          IF(DEBUGLEVEL .GE. 2) THEN
            CALL debug_call('EXTERNAL_FORCING_SURF', MYTHID)
          ENDIF
          CALL external_forcing_surf((BI), (BJ), IMIN, IMAX, JMIN, JMAX
     > , MYTIME, MYITER, MYTHID)
          IF(USEGMREDI) THEN
            IF(DEBUGLEVEL .GE. 2) THEN
              CALL debug_call('GMREDI_CALC_TENSOR', MYTHID)
            ENDIF
            CALL gmredi_calc_tensor(IMIN, IMAX, JMIN, JMAX, SIGMAX,
     >  SIGMAY, SIGMAR, (BI), (BJ), MYTIME, MYITER, MYTHID)
          ELSE
            CALL gmredi_calc_tensor_dummy(IMIN, IMAX, JMIN, JMAX,
     >  SIGMAX, SIGMAY, SIGMAR, (BI), (BJ), MYTIME, MYITER, MYTHID)
          ENDIF
        END DO
      END DO
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_leave('DO_OCEANIC_PHYS', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE do_stagger_fields_exchanges(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL exch_uv_xyz_rl
      EXTERNAL exch_xyz_rl
C
C     **** Statements ****
C
      IF(STAGGERTIMESTEP .AND. USEMULTIDIMADVEC) THEN
        CALL exch_uv_xyz_rl(UVEL, VVEL, (.TRUE.), MYTHID)
        IF(.NOT. IMPLICITINTGRAVWAVE) THEN
          CALL exch_xyz_rl(WVEL, MYTHID)
        ENDIF
      ENDIF
      IF(IMPLICITINTGRAVWAVE) THEN
        CALL exch_xyz_rl(GT, MYTHID)
        CALL exch_xyz_rl(GS, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE dynamics(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use cd_code_vars_mod
      use grid_mod
      use tamc_mod
      use tamc_keys_mod
      use ffields_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL calc_grad_phi_surf
      EXTERNAL calc_phi_hyd
      EXTERNAL calc_viscosity
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL debug_stats_rl
      REAL(w2f__8) DPHIHYDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DPHIHYDY(-2 : 93, -2 : 43)
      REAL(w2f__8) FVERU(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) FVERV(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) GUDISSIP(-2 : 93, -2 : 43)
      REAL(w2f__8) GVDISSIP(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      EXTERNAL impldiff
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) K
      REAL(w2f__8) KAPPARU(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) KAPPARV(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) KDOWN
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KP1
      INTEGER(w2f__i4) KUP
      EXTERNAL mom_fluxform
      EXTERNAL mom_vecinv
      REAL(w2f__8) PHIHYDC(-2 : 93, -2 : 43)
      REAL(w2f__8) PHIHYDF(-2 : 93, -2 : 43)
      REAL(w2f__8) PHISURFX(-2 : 93, -2 : 43)
      REAL(w2f__8) PHISURFY(-2 : 93, -2 : 43)
      EXTERNAL timestep
C
C     **** Statements ****
C
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_enter('DYNAMICS', MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          ACT1 = BI - MYBXLO(MYTHID)
          MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
          ACT2 = BJ - MYBYLO(MYTHID)
          MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
          ACT3 = MYTHID +(-1)
          MAX3 = NTX * NTY
          ACT4 = IKEY_DYNAMICS +(-1)
          IDYNKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 *
     >  MAX2 * ACT4 * MAX1 + 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                KAPPARU(I, J, K) = 0.0D00
                KAPPARV(I, J, K) = 0.0D00
                GU(I, J, K, BI, BJ) = 0.0D00
                GV(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              FVERU(I, J, 1) = 0.0D00
              FVERU(I, J, 2) = 0.0D00
              FVERV(I, J, 1) = 0.0D00
              FVERV(I, J, 2) = 0.0D00
              PHIHYDF(I, J) = 0.0D00
              PHIHYDC(I, J) = 0.0D00
              DPHIHYDX(I, J) = 0.0D00
              DPHIHYDY(I, J) = 0.0D00
              PHISURFX(I, J) = 0.0D00
              PHISURFY(I, J) = 0.0D00
              GUDISSIP(I, J) = 0.0D00
              GVDISSIP(I, J) = 0.0D00
            END DO
          END DO
          IMIN = 0
          IMAX = 91
          JMIN = 0
          JMAX = 41
          IF(IMPLICSURFPRESS .ne. 1.0D00) THEN
            CALL calc_grad_phi_surf((BI), (BJ), IMIN, IMAX, JMIN, JMAX,
     >  ETAN, PHISURFX, PHISURFY, MYTHID)
          ENDIF
          CALL calc_viscosity((BI), (BJ), IMIN, IMAX, JMIN, JMAX,
     >  KAPPARU, KAPPARV, MYTHID)
          DO K = 1, 15, 1
            KM1 = MAX(K +(-1), 1)
            KP1 = MIN(K + 1, 15)
            KUP = MOD(K + 1, 2) + 1
            KDOWN = MOD(K, 2) + 1
            KKEY = K + IDYNKEY * 15 +(-15)
            IF(IMPLICITINTGRAVWAVE) THEN
              CALL calc_phi_hyd((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K)
     > , GT, GS, PHIHYDF, PHIHYDC, DPHIHYDX, DPHIHYDY, MYTIME, MYITER,
     >  MYTHID)
            ELSE
              CALL calc_phi_hyd((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K)
     > , THETA, SALT, PHIHYDF, PHIHYDC, DPHIHYDX, DPHIHYDY, MYTIME,
     >  MYITER, MYTHID)
            ENDIF
            IF(MOMSTEPPING) THEN
              IF(.NOT. VECTORINVARIANTMOMENTUM) THEN
                CALL mom_fluxform((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (
     > K), KUP, KDOWN, KAPPARU, KAPPARV, FVERU, FVERV, GUDISSIP,
     >  GVDISSIP, MYTIME, MYITER, MYTHID)
              ELSE
                CALL mom_vecinv((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K)
     > , KUP, KDOWN, KAPPARU, KAPPARV, FVERU, FVERV, GUDISSIP, GVDISSIP
     > , MYTIME, MYITER, MYTHID)
              ENDIF
              CALL timestep((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K),
     >  DPHIHYDX, DPHIHYDY, PHISURFX, PHISURFY, GUDISSIP, GVDISSIP,
     >  MYTIME, MYITER, MYTHID)
            ENDIF
          END DO
          IF(IMPLICITVISCOSITY) THEN
            CALL impldiff((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (-1),
     >  KAPPARU, RECIP_HFACW, GU, MYTHID)
            CALL impldiff((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (-2),
     >  KAPPARV, RECIP_HFACS, GV, MYTHID)
          ENDIF
          IF(IMPLICITVISCOSITY .AND. USECDSCHEME) THEN
            CALL impldiff((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (0),
     >  KAPPARU, RECIP_HFACW, VVELD, MYTHID)
            CALL impldiff((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (0),
     >  KAPPARV, RECIP_HFACS, UVELD, MYTHID)
          ENDIF
        END DO
      END DO
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_stats_rl((1), ETAN, 'EtaN (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), UVEL, 'Uvel (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), VVEL, 'Vvel (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), WVEL, 'Wvel (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), THETA, 'Theta (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), SALT, 'Salt (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GU, 'Gu (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GV, 'Gv (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GT, 'Gt (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GS, 'Gs (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GUNM1, 'GuNm1 (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GVNM1, 'GvNm1 (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GTNM1, 'GtNm1 (DYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GSNM1, 'GsNm1 (DYNAMICS)', MYTHID)
      ENDIF
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_leave('DYNAMICS', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE external_fields_load(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use ffields_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) AWGHT
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) BWGHT
      EXTERNAL exch_uv_xy_rs
      EXTERNAL exch_xy_rs
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IFCYC
      INTEGER(w2f__i4) IFPRD
      INTEGER(w2f__i4) IFTM
      INTEGER(w2f__i4) IMYTM
      INTEGER(w2f__i4) INTIME0
      INTEGER(w2f__i4) INTIME1
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) NFORCINGPERIODS
      REAL(w2f__8) RDT
      EXTERNAL read_rec_xy_rs
      REAL(w2f__8) TMP1WGHT
      REAL(w2f__8) TMP2WGHT
C
C     **** Statements ****
C
      IF(PERIODICEXTERNALFORCING) THEN
        RDT = 1D00 / DELTATCLOCK
        NFORCINGPERIODS = NINT(EXTERNFORCINGCYCLE / EXTERNFORCINGPERIOD
     > )
        IMYTM = NINT(MYTIME * RDT)
        IFPRD = NINT(RDT * EXTERNFORCINGPERIOD)
        IFCYC = NINT(RDT * EXTERNFORCINGCYCLE)
        IMYTM = IMYTM + IFCYC *(1 - NINT(MYTIME / EXTERNFORCINGCYCLE))
        IFTM = MOD(IFCYC + IMYTM -(IFPRD / 2), IFCYC)
        INTIME0 = INT(IFTM / IFPRD) + 1
        INTIME1 = MOD(INTIME0, NFORCINGPERIODS) + 1
        TMP1WGHT = FLOAT(IFTM - IFPRD *(INTIME0 +(-1)))
        TMP2WGHT = FLOAT(IFPRD)
        AWGHT = TMP1WGHT / TMP2WGHT
        BWGHT = 1.0D00 - AWGHT
        IF((MYITER .eq. NITER0) .OR.((IFTM - IFPRD *(INTIME0 +(-1)))
     >  .eq. 0)) THEN
          CALL barrier(MYTHID)
          IF(MYTHID .eq. 1) THEN
            WRITE(STANDARDMESSAGEUNIT, '(A,2I5,I10,1P1E20.12)')
     >  'S/R EXTERNAL_FIELDS_LOAD: Reading new data:', INTIME0, INTIME1
     > , MYITER, MYTIME
          ENDIF
          IF(ZONALWINDFILE .NE. ' ') THEN
            CALL read_rec_xy_rs(ZONALWINDFILE, TAUX0, INTIME0, MYITER,
     >  MYTHID)
            CALL read_rec_xy_rs(ZONALWINDFILE, TAUX1, INTIME1, MYITER,
     >  MYTHID)
          ENDIF
          IF(MERIDWINDFILE .NE. ' ') THEN
            CALL read_rec_xy_rs(MERIDWINDFILE, TAUY0, INTIME0, MYITER,
     >  MYTHID)
            CALL read_rec_xy_rs(MERIDWINDFILE, TAUY1, INTIME1, MYITER,
     >  MYTHID)
          ENDIF
          IF(SURFQFILE .NE. ' ') THEN
            CALL read_rec_xy_rs(SURFQFILE, QNET0, INTIME0, MYITER,
     >  MYTHID)
            CALL read_rec_xy_rs(SURFQFILE, QNET1, INTIME1, MYITER,
     >  MYTHID)
          ELSE
            IF(SURFQNETFILE .NE. ' ') THEN
              CALL read_rec_xy_rs(SURFQNETFILE, QNET0, INTIME0, MYITER,
     >  MYTHID)
              CALL read_rec_xy_rs(SURFQNETFILE, QNET1, INTIME1, MYITER,
     >  MYTHID)
            ENDIF
          ENDIF
          IF(EMPMRFILE .NE. ' ') THEN
            CALL read_rec_xy_rs(EMPMRFILE, EMPMR0, INTIME0, MYITER,
     >  MYTHID)
            CALL read_rec_xy_rs(EMPMRFILE, EMPMR1, INTIME1, MYITER,
     >  MYTHID)
            CALL barrier(MYTHID)
            DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
              DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
                DO J = -2, 43, 1
                  DO I = -2, 93, 1
                    EMPMR0(I, J, BI, BJ) = (EMPMR0(I, J, BI, BJ) *
     >  RHOCONSTFRESH)
                    EMPMR1(I, J, BI, BJ) = (EMPMR1(I, J, BI, BJ) *
     >  RHOCONSTFRESH)
                  END DO
                END DO
              END DO
            END DO
          ENDIF
          IF(SALTFLUXFILE .NE. ' ') THEN
            CALL read_rec_xy_rs(SALTFLUXFILE, SALTFLUX0, INTIME0,
     >  MYITER, MYTHID)
            CALL read_rec_xy_rs(SALTFLUXFILE, SALTFLUX1, INTIME1,
     >  MYITER, MYTHID)
          ENDIF
          IF(THETACLIMFILE .NE. ' ') THEN
            CALL read_rec_xy_rs(THETACLIMFILE, SST0, INTIME0, MYITER,
     >  MYTHID)
            CALL read_rec_xy_rs(THETACLIMFILE, SST1, INTIME1, MYITER,
     >  MYTHID)
          ENDIF
          IF(SALTCLIMFILE .NE. ' ') THEN
            CALL read_rec_xy_rs(SALTCLIMFILE, SSS0, INTIME0, MYITER,
     >  MYTHID)
            CALL read_rec_xy_rs(SALTCLIMFILE, SSS1, INTIME1, MYITER,
     >  MYTHID)
          ENDIF
          CALL exch_xy_rs(SST0, MYTHID)
          CALL exch_xy_rs(SST1, MYTHID)
          CALL exch_xy_rs(SSS0, MYTHID)
          CALL exch_xy_rs(SSS1, MYTHID)
          CALL exch_uv_xy_rs(TAUX0, TAUY0, (.TRUE.), MYTHID)
          CALL exch_uv_xy_rs(TAUX1, TAUY1, (.TRUE.), MYTHID)
          CALL exch_xy_rs(QNET0, MYTHID)
          CALL exch_xy_rs(QNET1, MYTHID)
          CALL exch_xy_rs(EMPMR0, MYTHID)
          CALL exch_xy_rs(EMPMR1, MYTHID)
          CALL exch_xy_rs(SALTFLUX0, MYTHID)
          CALL exch_xy_rs(SALTFLUX1, MYTHID)
        ENDIF
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            IF(THETACLIMFILE .NE. ' ') THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  SST(I, J, BI, BJ) = (SST0(I, J, BI, BJ) * BWGHT +
     >  SST1(I, J, BI, BJ) * AWGHT)
                END DO
              END DO
            ENDIF
            IF(SALTCLIMFILE .NE. ' ') THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  SSS(I, J, BI, BJ) = (SSS0(I, J, BI, BJ) * BWGHT +
     >  SSS1(I, J, BI, BJ) * AWGHT)
                END DO
              END DO
            ENDIF
            IF(ZONALWINDFILE .NE. ' ') THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  FU(I, J, BI, BJ) = (TAUX0(I, J, BI, BJ) * BWGHT +
     >  TAUX1(I, J, BI, BJ) * AWGHT)
                END DO
              END DO
            ENDIF
            IF(MERIDWINDFILE .NE. ' ') THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  FV(I, J, BI, BJ) = (TAUY0(I, J, BI, BJ) * BWGHT +
     >  TAUY1(I, J, BI, BJ) * AWGHT)
                END DO
              END DO
            ENDIF
            IF((SURFQFILE .NE. ' ') .OR.(SURFQNETFILE .NE. ' ')) THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  QNET(I, J, BI, BJ) = (QNET0(I, J, BI, BJ) * BWGHT +
     >  QNET1(I, J, BI, BJ) * AWGHT)
                END DO
              END DO
            ENDIF
            IF(EMPMRFILE .NE. ' ') THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  EMPMR(I, J, BI, BJ) = (EMPMR0(I, J, BI, BJ) * BWGHT +
     >  EMPMR1(I, J, BI, BJ) * AWGHT)
                END DO
              END DO
            ENDIF
            IF(SALTFLUXFILE .NE. ' ') THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  SALTFLUX(I, J, BI, BJ) = (SALTFLUX0(I, J, BI, BJ) *
     >  BWGHT + SALTFLUX1(I, J, BI, BJ) * AWGHT)
                END DO
              END DO
            ENDIF
          END DO
        END DO
        IF((DEBUGLEVEL .GE. 1) .AND.(MYTIME .LT. 6.2208D+07)) THEN
          IF(MYTHID .eq. 1) THEN
            WRITE(STANDARDMESSAGEUNIT, '(a,1p7e12.4,2i6,2e12.4)')
     >  'time,SST,SSS,fu,fv,Q,E-P,i0,i1,a,b = ', MYTIME, SST(1, 40, 1,
     >  1), SSS(1, 40, 1, 1), FU(1, 40, 1, 1), FV(1, 40, 1, 1), QNET(1,
     >  40, 1, 1), EMPMR(1, 40, 1, 1), INTIME0, INTIME1, AWGHT, BWGHT
            WRITE(STANDARDMESSAGEUNIT, '(a,1p4e12.4,2E23.15)')
     >  'time,fu0,fu1,fu = ', MYTIME, TAUX0(1, 40, 1, 1), TAUX1(1, 40,
     >  1, 1), FU(1, 40, 1, 1), AWGHT, BWGHT
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE external_forcing_u(IMIN, IMAX, JMIN, JMAX, BI, BJ,
     >  KLEV, MYTIME, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) KLEV
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KSURFACE
C
C     **** Statements ****
C
      IF(FLUIDISAIR) THEN
        KSURFACE = 0
      ELSE
        IF(USINGPCOORDS) THEN
          KSURFACE = 15
        ELSE
          KSURFACE = 1
        ENDIF
      ENDIF
      IF(KLEV .eq. KSURFACE) THEN
        DO J = 0, 41, 1
          DO I = 1, 91, 1
            GU(I, J, KLEV, BI, BJ) = (GU(I, J, KLEV, BI, BJ) +
     >  RECIP_HFACW(I, J, KLEV, BI, BJ) * RECIP_DRF(KLEV) *
     >  SURFACEFORCINGU(I, J, BI, BJ) * FOFACMOM)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE external_forcing_v(IMIN, IMAX, JMIN, JMAX, BI, BJ,
     >  KLEV, MYTIME, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) KLEV
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KSURFACE
C
C     **** Statements ****
C
      IF(FLUIDISAIR) THEN
        KSURFACE = 0
      ELSE
        IF(USINGPCOORDS) THEN
          KSURFACE = 15
        ELSE
          KSURFACE = 1
        ENDIF
      ENDIF
      IF(KLEV .eq. KSURFACE) THEN
        DO J = 1, 41, 1
          DO I = 0, 91, 1
            GV(I, J, KLEV, BI, BJ) = (GV(I, J, KLEV, BI, BJ) +
     >  RECIP_HFACS(I, J, KLEV, BI, BJ) * RECIP_DRF(KLEV) *
     >  SURFACEFORCINGV(I, J, BI, BJ) * FOFACMOM)
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE external_forcing_t(IMIN, IMAX, JMIN, JMAX, BI, BJ,
     >  KLEV, MYTIME, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) KLEV
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KSURFACE
C
C     **** Statements ****
C
      IF(FLUIDISAIR) THEN
        KSURFACE = 0
      ELSE
        IF(USINGPCOORDS) THEN
          KSURFACE = 15
        ELSE
          KSURFACE = 1
        ENDIF
      ENDIF
      IF(KLEV .eq. KSURFACE) THEN
        DO J = 1, 40, 1
          DO I = 1, 90, 1
            GT(I, J, KLEV, BI, BJ) = (GT(I, J, KLEV, BI, BJ) +
     >  RECIP_HFACC(I, J, KLEV, BI, BJ) * RECIP_DRF(KLEV) *
     >  SURFACEFORCINGT(I, J, BI, BJ))
          END DO
        END DO
      ENDIF
      IF(LINFSCONSERVETR) THEN
        DO J = 1, 40, 1
          DO I = 1, 90, 1
            IF(KSURFC(I, J, BI, BJ) .eq. KLEV) THEN
              GT(I, J, KLEV, BI, BJ) = (GT(I, J, KLEV, BI, BJ) +
     >  RECIP_HFACC(I, J, KLEV, BI, BJ) * RECIP_DRF(KLEV) * TSURFCOR)
            ENDIF
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE external_forcing_s(IMIN, IMAX, JMIN, JMAX, BI, BJ,
     >  KLEV, MYTIME, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) KLEV
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KSURFACE
C
C     **** Statements ****
C
      IF(FLUIDISAIR) THEN
        KSURFACE = 0
      ELSE
        IF(USINGPCOORDS) THEN
          KSURFACE = 15
        ELSE
          KSURFACE = 1
        ENDIF
      ENDIF
      IF(KLEV .eq. KSURFACE) THEN
        DO J = 1, 40, 1
          DO I = 1, 90, 1
            GS(I, J, KLEV, BI, BJ) = (GS(I, J, KLEV, BI, BJ) +
     >  RECIP_HFACC(I, J, KLEV, BI, BJ) * RECIP_DRF(KLEV) *
     >  SURFACEFORCINGS(I, J, BI, BJ))
          END DO
        END DO
      ENDIF
      IF(LINFSCONSERVETR) THEN
        DO J = 1, 40, 1
          DO I = 1, 90, 1
            IF(KSURFC(I, J, BI, BJ) .eq. KLEV) THEN
              GS(I, J, KLEV, BI, BJ) = (GS(I, J, KLEV, BI, BJ) +
     >  RECIP_HFACC(I, J, KLEV, BI, BJ) * RECIP_DRF(KLEV) * SSURFCOR)
            ENDIF
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE external_forcing_surf(BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use ffields_mod
      use dynvars_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) KS
C
C     **** Statements ****
C
      IF(USINGPCOORDS) THEN
        KS = 15
      ELSE
        KS = 1
      ENDIF
      IF(DOSALTCLIMRELAX .OR. DOTHETACLIMRELAX) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            SURFACEFORCINGT(I, J, BI, BJ) = (-(HFACC(I, J, KS, BI, BJ)
     >  * DRF(KS) * LAMBDATHETACLIMRELAX(I, J, BI, BJ) *(THETA(I, J, KS
     > , BI, BJ) - SST(I, J, BI, BJ))))
            SURFACEFORCINGS(I, J, BI, BJ) = (-(HFACC(I, J, KS, BI, BJ)
     >  * DRF(KS) * LAMBDASALTCLIMRELAX(I, J, BI, BJ) *(SALT(I, J, KS,
     >  BI, BJ) - SSS(I, J, BI, BJ))))
          END DO
        END DO
      ELSE
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            SURFACEFORCINGT(I, J, BI, BJ) = 0.0D00
            SURFACEFORCINGS(I, J, BI, BJ) = 0.0D00
          END DO
        END DO
      ENDIF
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          SURFACEFORCINGU(I, J, BI, BJ) = (FU(I, J, BI, BJ) *
     >  MASS2RUNIT)
          SURFACEFORCINGV(I, J, BI, BJ) = (FV(I, J, BI, BJ) *
     >  MASS2RUNIT)
          SURFACEFORCINGT(I, J, BI, BJ) = (SURFACEFORCINGT(I, J, BI, BJ
     > ) - MASS2RUNIT * RECIP_CP *(QNET(I, J, BI, BJ)))
          SURFACEFORCINGS(I, J, BI, BJ) = (SURFACEFORCINGS(I, J, BI, BJ
     > ) - SALTFLUX(I, J, BI, BJ) * MASS2RUNIT)
        END DO
      END DO
      IF(USEREALFRESHWATERFLUX) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            EMPMR(I, J, BI, BJ) = (EMPMR(I, J, BI, BJ) * MASKH(I, J, BI
     > , BJ))
          END DO
        END DO
      ENDIF
      IF(.TRUE.) THEN
        IF(CONVERTFW2SALT .eq.(-1.0D00)) THEN
          IF(TEMP_EVPRRN .ne. 1.2345669999999999709D+05) THEN
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                SURFACEFORCINGT(I, J, BI, BJ) = (SURFACEFORCINGT(I, J,
     >  BI, BJ) + MASS2RUNIT * EMPMR(I, J, BI, BJ) *(THETA(I, J, KS, BI
     > , BJ) - TEMP_EVPRRN))
              END DO
            END DO
          ENDIF
          IF(SALT_EVPRRN .ne. 1.2345669999999999709D+05) THEN
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                SURFACEFORCINGS(I, J, BI, BJ) = (SURFACEFORCINGS(I, J,
     >  BI, BJ) + MASS2RUNIT * EMPMR(I, J, BI, BJ) *(SALT(I, J, KS, BI,
     >  BJ) - SALT_EVPRRN))
              END DO
            END DO
          ENDIF
        ELSE
          IF(TEMP_EVPRRN .ne. 1.2345669999999999709D+05) THEN
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                SURFACEFORCINGT(I, J, BI, BJ) = (SURFACEFORCINGT(I, J,
     >  BI, BJ) + MASS2RUNIT * EMPMR(I, J, BI, BJ) *(TREF(KS) -
     >  TEMP_EVPRRN))
              END DO
            END DO
          ENDIF
          IF(SALT_EVPRRN .ne. 1.2345669999999999709D+05) THEN
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                SURFACEFORCINGS(I, J, BI, BJ) = (SURFACEFORCINGS(I, J,
     >  BI, BJ) + MASS2RUNIT * EMPMR(I, J, BI, BJ) *(CONVERTFW2SALT -
     >  SALT_EVPRRN))
              END DO
            END DO
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE find_alpha(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KREF,
     >  ALPHALOC, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KREF
      REAL(w2f__8) ALPHALOC(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) BULKMOD(-2 : 93, -2 : 43)
      REAL(w2f__8) DDEN_DTHETA
      REAL(w2f__8) DKDTHETA
      REAL(w2f__8) DKDTHETAFRESH
      REAL(w2f__8) DKDTHETAPRES
      REAL(w2f__8) DKDTHETASALT
      REAL(w2f__8) DNUM_DTHETA
      REAL(w2f__8) DRHOP0DTHETA
      REAL(w2f__8) DRHOP0DTHETAFRESH
      REAL(w2f__8) DRHOP0DTHETASALT
      EXTERNAL find_bulkmod
      EXTERNAL find_rhoden
      EXTERNAL find_rhonum
      EXTERNAL find_rhop0
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) LOCPRES(-2 : 93, -2 : 43)
      REAL(w2f__8) P1
      REAL(w2f__8) P1T1
      REAL(w2f__8) P2
      EXTERNAL pressure_for_eos
      REAL(w2f__8) REFSALT
      REAL(w2f__8) REFTEMP
      REAL(w2f__8) RHODEN(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOLOC(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOP0(-2 : 93, -2 : 43)
      REAL(w2f__8) S1
      REAL(w2f__8) S3O2
      REAL(w2f__8) SP
      REAL(w2f__8) SP5
      REAL(w2f__8) T1
      REAL(w2f__8) T2
      REAL(w2f__8) T3
      REAL(w2f__8) TP
C
C     **** Statements ****
C
      IF(EQUATIONOFSTATE .EQ. 'LINEAR') THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            ALPHALOC(I, J) = (-(RHONIL * TALPHA))
          END DO
        END DO
      ELSE
        IF(EQUATIONOFSTATE .EQ. 'POLY3') THEN
          REFTEMP = EOSREFT(KREF)
          REFSALT = EOSREFS(KREF)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              TP = THETA(I, J, K, BI, BJ) - REFTEMP
              SP = SALT(I, J, K, BI, BJ) - REFSALT
              ALPHALOC(I, J) = (EOSC(1, KREF) + SP *(EOSC(4, KREF) +
     >  EOSC(8, KREF) * SP) + TP *(EOSC(6, KREF) * TP * 3.0D00 +(EOSC(3
     > , KREF) + EOSC(7, KREF) * SP) * 2.0D00))
            END DO
          END DO
        ELSE
          IF((EQUATIONOFSTATE(1_w2f__i8 : 5) .EQ. 'JMD95') .OR.(
     > EQUATIONOFSTATE .EQ. 'UNESCO')) THEN
            CALL pressure_for_eos(BI, BJ, IMIN, IMAX, JMIN, JMAX, KREF,
     >  LOCPRES, MYTHID)
            CALL find_rhop0(IMIN, IMAX, JMIN, JMAX, THETA((-2), (-2), K
     > , BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOP0, MYTHID)
            CALL find_bulkmod(IMIN, IMAX, JMIN, JMAX, LOCPRES, THETA((
     > -2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), BULKMOD,
     >  MYTHID)
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                T1 = THETA(I, J, K, BI, BJ)
                T2 = T1 * T1
                T3 = T1 * T2
                S1 = SALT(I, J, K, BI, BJ)
                IF(S1 .GT. 0.0D00) THEN
                  S3O2 = SQRT(S1 * S1 * S1)
                ELSE
                  S1 = 0.0D00
                  S3O2 = 0.0D00
                ENDIF
                P1 = LOCPRES(I, J) * 1.0000000000000000818D-05
                P2 = P1 * P1
                DRHOP0DTHETAFRESH = EOSJMDCFW(2) + T1 * EOSJMDCFW(3) *
     >  2.0D00 + T2 * EOSJMDCFW(4) * 3.0D00 + T3 * EOSJMDCFW(5) *
     >  4.0D00 + T1 * T3 * EOSJMDCFW(6) * 5.0D00
                DRHOP0DTHETASALT = S1 *(EOSJMDCSW(2) + T1 * EOSJMDCSW(3
     > ) * 2.0D00 + T2 * EOSJMDCSW(4) * 3.0D00 + T3 * EOSJMDCSW(5) *
     >  4.0D00) + S3O2 *(EOSJMDCSW(7) + T1 * EOSJMDCSW(8) * 2.0D00)
                DKDTHETAFRESH = EOSJMDCKFW(2) + T1 * EOSJMDCKFW(3) *
     >  2.0D00 + T2 * EOSJMDCKFW(4) * 3.0D00 + T3 * EOSJMDCKFW(5) *
     >  4.0D00
                DKDTHETASALT = S1 *(EOSJMDCKSW(2) + T1 * EOSJMDCKSW(3)
     >  * 2.0D00 + T2 * EOSJMDCKSW(4) * 3.0D00) + S3O2 *(EOSJMDCKSW(6)
     >  + T1 * EOSJMDCKSW(7) * 2.0D00)
                DKDTHETAPRES = P1 *(EOSJMDCKP(2) + T1 * EOSJMDCKP(3) *
     >  2.0D00 + T2 * EOSJMDCKP(4) * 3.0D00) + P1 * S1 *(EOSJMDCKP(6) +
     >  T1 * EOSJMDCKP(7) * 2.0D00) + P2 *(EOSJMDCKP(10) + T1 *
     >  EOSJMDCKP(11) * 2.0D00) + P2 * S1 *(EOSJMDCKP(13) + T1 *
     >  EOSJMDCKP(14) * 2.0D00)
                DRHOP0DTHETA = DRHOP0DTHETAFRESH + DRHOP0DTHETASALT
                DKDTHETA = DKDTHETAPRES + DKDTHETAFRESH + DKDTHETASALT
                ALPHALOC(I, J) = ((DRHOP0DTHETA *(BULKMOD(I, J) ** 2) -
     >  DRHOP0DTHETA * BULKMOD(I, J) * P1 - DKDTHETA * RHOP0(I, J) * P1
     > ) /((BULKMOD(I, J) - P1) ** 2))
              END DO
            END DO
          ELSE
            IF(EQUATIONOFSTATE .EQ. 'MDJWF') THEN
              CALL pressure_for_eos(BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  KREF, LOCPRES, MYTHID)
              CALL find_rhonum(IMIN, IMAX, JMIN, JMAX, LOCPRES, THETA((
     > -2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOLOC,
     >  MYTHID)
              CALL find_rhoden(IMIN, IMAX, JMIN, JMAX, LOCPRES, THETA((
     > -2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHODEN,
     >  MYTHID)
              DO J = JMIN, JMAX, 1
                DO I = IMIN, IMAX, 1
                  T1 = THETA(I, J, K, BI, BJ)
                  T2 = T1 * T1
                  S1 = SALT(I, J, K, BI, BJ)
                  IF(S1 .GT. 0.0D00) THEN
                    SP5 = SQRT(S1)
                  ELSE
                    S1 = 0.0D00
                    SP5 = 0.0D00
                  ENDIF
                  P1 = LOCPRES(I, J) * 1.00000000000000004792D-04
                  P1T1 = P1 * T1
                  DNUM_DTHETA = EOSMDJWFNUM(1) + T1 *(EOSMDJWFNUM(2) *
     >  2.0D00 + T1 * EOSMDJWFNUM(3) * 3.0D00) + EOSMDJWFNUM(5) * S1 +
     >  P1T1 *(EOSMDJWFNUM(8) * 2.0D00 + P1 * EOSMDJWFNUM(11) * 2.0D00)
                  DDEN_DTHETA = EOSMDJWFDEN(1) + T1 *(EOSMDJWFDEN(2) *
     >  2.0D00 + T1 *(EOSMDJWFDEN(3) * 3.0D00 + T1 * EOSMDJWFDEN(4) *
     >  4.0D00)) + S1 *(EOSMDJWFDEN(6) + T1 *(SP5 * EOSMDJWFDEN(9) *
     >  2.0D00 + T1 * EOSMDJWFDEN(7) * 3.0D00)) + P1 * P1 *(EOSMDJWFDEN
     > (12) * P1 + T2 * EOSMDJWFDEN(11) * 3.0D00)
                  ALPHALOC(I, J) = (RHODEN(I, J) *(DNUM_DTHETA -
     >  DDEN_DTHETA *(RHODEN(I, J) * RHOLOC(I, J))))
                END DO
              END DO
            ELSE
              WRITE(*, *) 'FIND_ALPHA: equationOfState = ',
     >  EQUATIONOFSTATE
              WRITE(*, *)
     >  'FIND_ALPHA: "equationOfState" has illegal value'
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE find_beta(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, KREF,
     >  BETALOC, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KREF
      REAL(w2f__8) BETALOC(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) BULKMOD(-2 : 93, -2 : 43)
      REAL(w2f__8) DDEN_DSALT
      REAL(w2f__8) DKDS
      REAL(w2f__8) DKDSPRES
      REAL(w2f__8) DKDSSALT
      REAL(w2f__8) DNUM_DSALT
      REAL(w2f__8) DRHOP0DS
      EXTERNAL find_bulkmod
      EXTERNAL find_rhoden
      EXTERNAL find_rhonum
      EXTERNAL find_rhop0
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) LOCPRES(-2 : 93, -2 : 43)
      REAL(w2f__8) P1
      REAL(w2f__8) P1T1
      EXTERNAL pressure_for_eos
      REAL(w2f__8) REFSALT
      REAL(w2f__8) REFTEMP
      REAL(w2f__8) RHODEN(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOLOC(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOP0(-2 : 93, -2 : 43)
      REAL(w2f__8) S1
      REAL(w2f__8) S3O2
      REAL(w2f__8) SP
      REAL(w2f__8) SP5
      REAL(w2f__8) T1
      REAL(w2f__8) T2
      REAL(w2f__8) T3
      REAL(w2f__8) TP
C
C     **** Statements ****
C
      IF(EQUATIONOFSTATE .EQ. 'LINEAR') THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            BETALOC(I, J) = (RHONIL * SBETA)
          END DO
        END DO
      ELSE
        IF(EQUATIONOFSTATE .EQ. 'POLY3') THEN
          REFTEMP = EOSREFT(KREF)
          REFSALT = EOSREFS(KREF)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              TP = THETA(I, J, K, BI, BJ) - REFTEMP
              SP = SALT(I, J, K, BI, BJ) - REFSALT
              BETALOC(I, J) = (EOSC(2, KREF) + SP *(EOSC(5, KREF) *
     >  2.0D00 + EOSC(9, KREF) * SP * 3.0D00) + TP *(EOSC(4, KREF) +
     >  EOSC(7, KREF) * TP + EOSC(8, KREF) * SP * 2.0D00))
            END DO
          END DO
        ELSE
          IF((EQUATIONOFSTATE(1_w2f__i8 : 5) .EQ. 'JMD95') .OR.(
     > EQUATIONOFSTATE .EQ. 'UNESCO')) THEN
            CALL pressure_for_eos(BI, BJ, IMIN, IMAX, JMIN, JMAX, KREF,
     >  LOCPRES, MYTHID)
            CALL find_rhop0(IMIN, IMAX, JMIN, JMAX, THETA((-2), (-2), K
     > , BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOP0, MYTHID)
            CALL find_bulkmod(IMIN, IMAX, JMIN, JMAX, LOCPRES, THETA((
     > -2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), BULKMOD,
     >  MYTHID)
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                T1 = THETA(I, J, K, BI, BJ)
                T2 = T1 * T1
                T3 = T1 * T2
                S1 = SALT(I, J, K, BI, BJ)
                IF(S1 .GT. 0.0D00) THEN
                  S3O2 = SQRT(S1) * 1.5D00
                ELSE
                  S1 = 0.0D00
                  S3O2 = 0.0D00
                ENDIF
                P1 = LOCPRES(I, J) * 1.0000000000000000818D-05
                DRHOP0DS = 0.0D00
                DRHOP0DS = EOSJMDCSW(1) + DRHOP0DS + EOSJMDCSW(2) * T1
     >  + EOSJMDCSW(3) * T2 + EOSJMDCSW(4) * T3 + T1 * EOSJMDCSW(5) *
     >  T3 + S3O2 *(EOSJMDCSW(6) + EOSJMDCSW(7) * T1 + EOSJMDCSW(8) *
     >  T2) + S1 * EOSJMDCSW(9) * 2.0D00
                DKDS = 0.0D00
                DKDSSALT = EOSJMDCKSW(1) + EOSJMDCKSW(2) * T1 +
     >  EOSJMDCKSW(3) * T2 + EOSJMDCKSW(4) * T3 + S3O2 *(EOSJMDCKSW(5)
     >  + EOSJMDCKSW(6) * T1 + EOSJMDCKSW(7) * T2)
                DKDSPRES = EOSJMDCKP(8) * P1 * S3O2 + P1 *(EOSJMDCKP(5)
     >  + EOSJMDCKP(6) * T1 + EOSJMDCKP(7) * T2) + P1 * P1 *(EOSJMDCKP(
     > 12) + EOSJMDCKP(13) * T1 + EOSJMDCKP(14) * T2)
                DKDS = DKDSPRES + DKDSSALT
                BETALOC(I, J) = ((DRHOP0DS *(BULKMOD(I, J) ** 2) -
     >  DRHOP0DS * BULKMOD(I, J) * P1 - DKDS * RHOP0(I, J) * P1) /((
     > BULKMOD(I, J) - P1) ** 2))
              END DO
            END DO
          ELSE
            IF(EQUATIONOFSTATE .EQ. 'MDJWF') THEN
              CALL pressure_for_eos(BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  KREF, LOCPRES, MYTHID)
              CALL find_rhonum(IMIN, IMAX, JMIN, JMAX, LOCPRES, THETA((
     > -2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHOLOC,
     >  MYTHID)
              CALL find_rhoden(IMIN, IMAX, JMIN, JMAX, LOCPRES, THETA((
     > -2), (-2), K, BI, BJ), SALT((-2), (-2), K, BI, BJ), RHODEN,
     >  MYTHID)
              DO J = JMIN, JMAX, 1
                DO I = IMIN, IMAX, 1
                  T1 = THETA(I, J, K, BI, BJ)
                  T2 = T1 * T1
                  S1 = SALT(I, J, K, BI, BJ)
                  IF(S1 .GT. 0.0D00) THEN
                    SP5 = SQRT(S1)
                  ELSE
                    S1 = 0.0D00
                    SP5 = 0.0D00
                  ENDIF
                  P1 = LOCPRES(I, J) * 1.00000000000000004792D-04
                  P1T1 = P1 * T1
                  DNUM_DSALT = EOSMDJWFNUM(4) + EOSMDJWFNUM(5) * T1 +
     >  S1 * EOSMDJWFNUM(6) * 2.0D00 + EOSMDJWFNUM(9) * P1
                  DDEN_DSALT = EOSMDJWFDEN(5) + T1 *(EOSMDJWFDEN(6) +
     >  EOSMDJWFDEN(7) * T2) + SP5 * 1.5D00 *(EOSMDJWFDEN(8) +
     >  EOSMDJWFDEN(9) * T2)
                  BETALOC(I, J) = (RHODEN(I, J) *(DNUM_DSALT -
     >  DDEN_DSALT *(RHODEN(I, J) * RHOLOC(I, J))))
                END DO
              END DO
            ELSE
              WRITE(*, *) 'FIND_BETA: equationOfState = ',
     >  EQUATIONOFSTATE
              WRITE(*, *)
     >  'FIND_BETA: "equationOfState" has illegal value'
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE find_rho_2d(IMIN, IMAX, JMIN, JMAX, KREF, TFLD, SFLD,
     >  RHOLOC, K, BI, BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) KREF
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOLOC(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) BULKMOD(-2 : 93, -2 : 43)
      REAL(w2f__8) DELTASIG
      REAL(w2f__8) DRHO
      EXTERNAL find_bulkmod
      EXTERNAL find_rhoden
      EXTERNAL find_rhonum
      EXTERNAL find_rhop0
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) LOCPRES(-2 : 93, -2 : 43)
      CHARACTER(512) MSGBUF
      EXTERNAL pressure_for_eos
      EXTERNAL print_error
      REAL(w2f__8) REFSALT
      REAL(w2f__8) REFTEMP
      REAL(w2f__8) RHODEN(-2 : 93, -2 : 43)
      REAL(w2f__8) RHONUM(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOP0(-2 : 93, -2 : 43)
      REAL(w2f__8) SIGREF
      REAL(w2f__8) SP
      REAL(w2f__8) TP
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          RHOLOC(I, J) = 0.0D00
          RHOP0(I, J) = 0.0D00
          BULKMOD(I, J) = 0.0D00
        END DO
      END DO
      IF(EQUATIONOFSTATE .EQ. 'LINEAR') THEN
        REFTEMP = TREF(KREF)
        REFSALT = SREF(KREF)
        DRHO = RHONIL - RHOCONST
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            RHOLOC(I, J) = (DRHO + RHONIL *(SBETA *(SFLD(I, J) -
     >  REFSALT) - TALPHA *(TFLD(I, J) - REFTEMP)))
          END DO
        END DO
      ELSE
        IF(EQUATIONOFSTATE .EQ. 'POLY3') THEN
          REFTEMP = EOSREFT(KREF)
          REFSALT = EOSREFS(KREF)
          SIGREF = EOSSIG0(KREF) +(1.0D+03 - RHOCONST)
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              TP = TFLD(I, J) - REFTEMP
              SP = SFLD(I, J) - REFSALT
              DELTASIG = SP *(EOSC(2, KREF) + SP *(EOSC(5, KREF) + EOSC
     > (9, KREF) * SP)) + TP *(EOSC(1, KREF) + SP *(EOSC(4, KREF) +
     >  EOSC(8, KREF) * SP) + TP *(EOSC(3, KREF) + EOSC(6, KREF) * TP +
     >  EOSC(7, KREF) * SP))
              RHOLOC(I, J) = (DELTASIG + SIGREF)
            END DO
          END DO
        ELSE
          IF((EQUATIONOFSTATE(1_w2f__i8 : 5) .EQ. 'JMD95') .OR.(
     > EQUATIONOFSTATE .EQ. 'UNESCO')) THEN
            CALL pressure_for_eos(BI, BJ, IMIN, IMAX, JMIN, JMAX, KREF,
     >  LOCPRES, MYTHID)
            CALL find_rhop0(IMIN, IMAX, JMIN, JMAX, TFLD, SFLD, RHOP0,
     >  MYTHID)
            CALL find_bulkmod(IMIN, IMAX, JMIN, JMAX, LOCPRES, TFLD,
     >  SFLD, BULKMOD, MYTHID)
            DO J = JMIN, JMAX, 1
              DO I = IMIN, IMAX, 1
                RHOLOC(I, J) = ((RHOP0(I, J) /(1.0D00 -((LOCPRES(I, J)
     >  * 1.0000000000000000818D-05) / BULKMOD(I, J)))) - RHOCONST)
              END DO
            END DO
          ELSE
            IF(EQUATIONOFSTATE .EQ. 'MDJWF') THEN
              CALL pressure_for_eos(BI, BJ, IMIN, IMAX, JMIN, JMAX,
     >  KREF, LOCPRES, MYTHID)
              CALL find_rhonum(IMIN, IMAX, JMIN, JMAX, LOCPRES, TFLD,
     >  SFLD, RHONUM, MYTHID)
              CALL find_rhoden(IMIN, IMAX, JMIN, JMAX, LOCPRES, TFLD,
     >  SFLD, RHODEN, MYTHID)
              DO J = JMIN, JMAX, 1
                DO I = IMIN, IMAX, 1
                  RHOLOC(I, J) = (RHODEN(I, J) * RHONUM(I, J) -
     >  RHOCONST)
                END DO
              END DO
            ELSE
              IF(EQUATIONOFSTATE .EQ. 'IDEALG') THEN
              ELSE
                WRITE(MSGBUF, '(3a)')
     >  ' FIND_RHO_2D: equationOfState = "', EQUATIONOFSTATE, '"'
                CALL print_error(MSGBUF, MYTHID)
                WRITE(*, *) 'ABNORMAL END: S/R FIND_RHO_2D'
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE find_rhop0(IMIN, IMAX, JMIN, JMAX, TFLD, SFLD, RHOP0,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) RHOP0(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RFRESH
      REAL(w2f__8) RSALT
      REAL(w2f__8) S
      REAL(w2f__8) S3O2
      REAL(w2f__8) T
      REAL(w2f__8) T2
      REAL(w2f__8) T3
      REAL(w2f__8) T4
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          T = TFLD(I, J)
          T2 = T * T
          T3 = T * T2
          T4 = T * T3
          S = SFLD(I, J)
          IF(S .GT. 0.0D00) THEN
            S3O2 = S * SQRT(S)
          ELSE
            S = 0.0D00
            S3O2 = 0.0D00
          ENDIF
          RFRESH = EOSJMDCFW(1) + EOSJMDCFW(2) * T + EOSJMDCFW(3) * T2
     >  + EOSJMDCFW(4) * T3 + EOSJMDCFW(5) * T4 + T * EOSJMDCFW(6) * T4
          RSALT = S *(EOSJMDCSW(1) + EOSJMDCSW(2) * T + EOSJMDCSW(3) *
     >  T2 + EOSJMDCSW(4) * T3 + EOSJMDCSW(5) * T4) + S3O2 *(EOSJMDCSW(
     > 6) + EOSJMDCSW(7) * T + EOSJMDCSW(8) * T2) + S * EOSJMDCSW(9) *
     >  S
          RHOP0(I, J) = (RFRESH + RSALT)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE find_bulkmod(IMIN, IMAX, JMIN, JMAX, LOCPRES, TFLD,
     >  SFLD, BULKMOD, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) LOCPRES(-2 : 93, -2 : 43)
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) BULKMOD(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) BMFRESH
      REAL(w2f__8) BMPRES
      REAL(w2f__8) BMSALT
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) P
      REAL(w2f__8) P2
      REAL(w2f__8) S
      REAL(w2f__8) S3O2
      REAL(w2f__8) T
      REAL(w2f__8) T2
      REAL(w2f__8) T3
      REAL(w2f__8) T4
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          T = TFLD(I, J)
          T2 = T * T
          T3 = T * T2
          T4 = T * T3
          S = SFLD(I, J)
          IF(S .GT. 0.0D00) THEN
            S3O2 = S * SQRT(S)
          ELSE
            S = 0.0D00
            S3O2 = 0.0D00
          ENDIF
          P = LOCPRES(I, J) * 1.0000000000000000818D-05
          P2 = P * P
          BMFRESH = EOSJMDCKFW(1) + EOSJMDCKFW(2) * T + EOSJMDCKFW(3) *
     >  T2 + EOSJMDCKFW(4) * T3 + EOSJMDCKFW(5) * T4
          BMSALT = S *(EOSJMDCKSW(1) + EOSJMDCKSW(2) * T + EOSJMDCKSW(3
     > ) * T2 + EOSJMDCKSW(4) * T3) + S3O2 *(EOSJMDCKSW(5) + EOSJMDCKSW
     > (6) * T + EOSJMDCKSW(7) * T2)
          BMPRES = P *(EOSJMDCKP(1) + EOSJMDCKP(2) * T + EOSJMDCKP(3) *
     >  T2 + EOSJMDCKP(4) * T3) + P * S *(EOSJMDCKP(5) + EOSJMDCKP(6) *
     >  T + EOSJMDCKP(7) * T2) + EOSJMDCKP(8) * P * S3O2 + P2 *(
     > EOSJMDCKP(9) + EOSJMDCKP(10) * T + EOSJMDCKP(11) * T2) + P2 * S
     >  *(EOSJMDCKP(12) + EOSJMDCKP(13) * T + EOSJMDCKP(14) * T2)
          BULKMOD(I, J) = (BMPRES + BMFRESH + BMSALT)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE find_rhonum(IMIN, IMAX, JMIN, JMAX, LOCPRES, TFLD,
     >  SFLD, RHONUM, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) LOCPRES(-2 : 93, -2 : 43)
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) RHONUM(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) P1
      REAL(w2f__8) S1
      REAL(w2f__8) T1
      REAL(w2f__8) T2
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          T1 = TFLD(I, J)
          T2 = T1 * T1
          S1 = SFLD(I, J)
          P1 = LOCPRES(I, J) * 1.00000000000000004792D-04
          RHONUM(I, J) = (EOSMDJWFNUM(0) + T1 *(EOSMDJWFNUM(1) + T1 *(
     > EOSMDJWFNUM(2) + EOSMDJWFNUM(3) * T1)) + S1 *(EOSMDJWFNUM(4) +
     >  EOSMDJWFNUM(5) * T1 + EOSMDJWFNUM(6) * S1) + P1 *(EOSMDJWFNUM(7
     > ) + EOSMDJWFNUM(8) * T2 + EOSMDJWFNUM(9) * S1 + P1 *(EOSMDJWFNUM
     > (10) + EOSMDJWFNUM(11) * T2)))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE find_rhoden(IMIN, IMAX, JMIN, JMAX, LOCPRES, TFLD,
     >  SFLD, RHODEN, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) LOCPRES(-2 : 93, -2 : 43)
      REAL(w2f__8) TFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) RHODEN(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) DEN
      REAL(w2f__8) EPSLN
      PARAMETER ( EPSLN = 0.0D00)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) P1
      REAL(w2f__8) P1T1
      REAL(w2f__8) S1
      REAL(w2f__8) SP5
      REAL(w2f__8) T1
      REAL(w2f__8) T2
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          T1 = TFLD(I, J)
          T2 = T1 * T1
          S1 = SFLD(I, J)
          IF(S1 .GT. 0.0D00) THEN
            SP5 = SQRT(S1)
          ELSE
            S1 = 0.0D00
            SP5 = 0.0D00
          ENDIF
          P1 = LOCPRES(I, J) * 1.00000000000000004792D-04
          P1T1 = P1 * T1
          DEN = EOSMDJWFDEN(0) + T1 *(EOSMDJWFDEN(1) + T1 *(EOSMDJWFDEN
     > (2) + T1 *(EOSMDJWFDEN(3) + EOSMDJWFDEN(4) * T1))) + S1 *(
     > EOSMDJWFDEN(5) + T1 *(EOSMDJWFDEN(6) + EOSMDJWFDEN(7) * T2) +
     >  SP5 *(EOSMDJWFDEN(8) + EOSMDJWFDEN(9) * T2)) + P1 *(EOSMDJWFDEN
     > (10) + P1T1 *(EOSMDJWFDEN(11) * T2 + EOSMDJWFDEN(12) * P1))
          RHODEN(I, J) = 1D00 / (DEN)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE look_for_neg_salinity(IMIN, IMAX, JMIN, JMAX, SFLD, K,
     >  BI, BJ, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      REAL(w2f__8) SFLD(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) LOCALWARNING
C
C     **** Statements ****
C
      LOCALWARNING = 0
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          IF(SFLD(I, J) .LT. 0.0D00) THEN
            LOCALWARNING = LOCALWARNING + 1
            SFLD(I, J) = 0.0D00
          ENDIF
        END DO
      END DO
      IF(LOCALWARNING .GT. 0) THEN
        WRITE(STANDARDMESSAGEUNIT, '(A,I6,A)')
     >  'S/R LOOK_FOR_NEG_SALINITY: found', LOCALWARNING,
     >  ' negative salinity values and reset them to zero' // '.'
        WRITE(STANDARDMESSAGEUNIT, '(A,I3)')
     >  'S/R LOOK_FOR_NEG_SALINITY: current level is k = ', K
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE forward_step(ILOOP, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use sigreg_mod
      use ffields_mod
      use surface_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      use eos_mod
      use cd_code_vars_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) ILOOP
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL autodiff_inadmode_set
      EXTERNAL autodiff_inadmode_unset
      EXTERNAL cost_tile
      EXTERNAL ctrl_map_forcing
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL do_atmospheric_phys
      EXTERNAL do_fields_blocking_exchanges
      EXTERNAL do_oceanic_phys
      EXTERNAL do_stagger_fields_exchanges
      EXTERNAL do_the_model_io
      EXTERNAL do_write_pickup
      EXTERNAL dummy_in_stepping
      EXTERNAL dynamics
      EXTERNAL load_fields_driver
      LOGICAL(w2f__i4) MODELEND
      EXTERNAL momentum_correction_step
      EXTERNAL solve_for_pressure
      EXTERNAL thermodynamics
      EXTERNAL timer_start
      EXTERNAL timer_stop
      EXTERNAL tracers_correction_step
C
C     **** Statements ****
C
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_enter('FORWARD_STEP', MYTHID)
      ENDIF
      CALL autodiff_inadmode_unset(MYTHID)
      MYITER = ILOOP + NITER0 +(-1)
      MYTIME = STARTTIME + DELTATCLOCK * FLOAT(ILOOP +(-1))
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_call('LOAD_FIELDS_DRIVER', MYTHID)
      ENDIF
      CALL timer_start('LOAD_FIELDS_DRIVER  [FORWARD_STEP]', MYTHID)
      CALL load_fields_driver(MYTIME, MYITER, MYTHID)
      CALL timer_stop('LOAD_FIELDS_DRIVER  [FORWARD_STEP]', MYTHID)
      IF(MYITER .eq. NITER0) THEN
        CALL ctrl_map_forcing(MYTHID)
      ENDIF
      CALL dummy_in_stepping(MYTIME, MYITER, MYTHID)
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_call('DO_ATMOSPHERIC_PHYS', MYTHID)
      ENDIF
      CALL timer_start('DO_ATMOSPHERIC_PHYS [FORWARD_STEP]', MYTHID)
      CALL do_atmospheric_phys(MYTIME, MYITER, MYTHID)
      CALL timer_stop('DO_ATMOSPHERIC_PHYS [FORWARD_STEP]', MYTHID)
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_call('DO_OCEANIC_PHYS', MYTHID)
      ENDIF
      CALL timer_start('DO_OCEANIC_PHYS     [FORWARD_STEP]', MYTHID)
      CALL do_oceanic_phys(MYTIME, MYITER, MYTHID)
      CALL timer_stop('DO_OCEANIC_PHYS     [FORWARD_STEP]', MYTHID)
      IF(.NOT. STAGGERTIMESTEP) THEN
        IF(DEBUGLEVEL .GE. 2) THEN
          CALL debug_call('THERMODYNAMICS', MYTHID)
        ENDIF
        CALL timer_start('THERMODYNAMICS      [FORWARD_STEP]', MYTHID)
        CALL thermodynamics(MYTIME, MYITER, MYTHID)
        CALL timer_stop('THERMODYNAMICS      [FORWARD_STEP]', MYTHID)
      ENDIF
      IF(IMPLICITINTGRAVWAVE) THEN
        CALL timer_start('BLOCKING_EXCHANGES  [FORWARD_STEP]', MYTHID)
        CALL do_stagger_fields_exchanges(MYTIME, MYITER, MYTHID)
        CALL timer_stop('BLOCKING_EXCHANGES  [FORWARD_STEP]', MYTHID)
      ENDIF
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_call('DYNAMICS', MYTHID)
      ENDIF
      CALL timer_start('DYNAMICS            [FORWARD_STEP]', MYTHID)
      CALL dynamics(MYTIME, MYITER, MYTHID)
      CALL timer_stop('DYNAMICS            [FORWARD_STEP]', MYTHID)
      MYITER = ILOOP + NITER0
      MYTIME = STARTTIME + DELTATCLOCK * FLOAT(ILOOP)
      IF(MOMSTEPPING) THEN
        CALL timer_start('SOLVE_FOR_PRESSURE  [FORWARD_STEP]', MYTHID)
        CALL solve_for_pressure(MYTIME, MYITER, MYTHID)
        CALL timer_stop('SOLVE_FOR_PRESSURE  [FORWARD_STEP]', MYTHID)
      ENDIF
      CALL timer_start('MOM_CORRECTION_STEP [FORWARD_STEP]', MYTHID)
      CALL momentum_correction_step(MYTIME, MYITER, MYTHID)
      CALL timer_stop('MOM_CORRECTION_STEP [FORWARD_STEP]', MYTHID)
      IF(STAGGERTIMESTEP) THEN
        IF(DEBUGLEVEL .GE. 2) THEN
          CALL debug_call('DO_STAGGER_FIELDS_EXCH.', MYTHID)
        ENDIF
        CALL timer_start('BLOCKING_EXCHANGES  [FORWARD_STEP]', MYTHID)
        CALL do_stagger_fields_exchanges(MYTIME, MYITER, MYTHID)
        CALL timer_stop('BLOCKING_EXCHANGES  [FORWARD_STEP]', MYTHID)
        IF(DEBUGLEVEL .GE. 2) THEN
          CALL debug_call('THERMODYNAMICS', MYTHID)
        ENDIF
        CALL timer_start('THERMODYNAMICS      [FORWARD_STEP]', MYTHID)
        CALL thermodynamics(MYTIME, MYITER, MYTHID)
        CALL timer_stop('THERMODYNAMICS      [FORWARD_STEP]', MYTHID)
      ENDIF
      CALL timer_start('TRC_CORRECTION_STEP [FORWARD_STEP]', MYTHID)
      CALL tracers_correction_step(MYTIME, MYITER, MYTHID)
      CALL timer_stop('TRC_CORRECTION_STEP [FORWARD_STEP]', MYTHID)
      CALL timer_start('BLOCKING_EXCHANGES  [FORWARD_STEP]', MYTHID)
      CALL do_fields_blocking_exchanges(MYTHID)
      CALL timer_stop('BLOCKING_EXCHANGES  [FORWARD_STEP]', MYTHID)
      CALL timer_start('COST_TILE           [FORWARD_STEP]', MYTHID)
      CALL cost_tile(MYTIME, MYITER, MYTHID)
      CALL timer_stop('COST_TILE           [FORWARD_STEP]', MYTHID)
      CALL timer_start('DO_THE_MODEL_IO     [FORWARD_STEP]', MYTHID)
      CALL do_the_model_io(MYTIME, MYITER, MYTHID)
      CALL timer_stop('DO_THE_MODEL_IO     [FORWARD_STEP]', MYTHID)
      MODELEND = (MYITER .eq. NENDITER) .OR.(MYTIME .eq. ENDTIME)
      IF(USESIGREG) THEN
        MODELEND = (I_GOT_SIGNAL .GT. 0) .OR. MODELEND
      ENDIF
      CALL timer_start('DO_WRITE_PICKUP     [FORWARD_STEP]', MYTHID)
      CALL do_write_pickup(MODELEND, MYTIME, MYITER, MYTHID)
      CALL timer_stop('DO_WRITE_PICKUP     [FORWARD_STEP]', MYTHID)
      IF(USESIGREG) THEN
        IF((I_GOT_SIGNAL .GT. 0) .AND. MODELEND) THEN
          WRITE(*, *)
     >  'Checkpoint completed -- killed by signal handler'
        ENDIF
      ENDIF
      CALL autodiff_inadmode_set(MYTHID)
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_leave('FORWARD_STEP', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE freesurf_rescale_g(BI, BJ, K, GTRACER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) GTRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE freeze(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) TFREEZING
C
C     **** Statements ****
C
      TFREEZING = -1.89999999999999991118D00
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          IF(GT(I, J, K, BI, BJ) .LT. TFREEZING) THEN
            GT(I, J, K, BI, BJ) = TFREEZING
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE freeze_surface(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use ffields_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      REAL(w2f__8) TFREEZING
C
C     **** Statements ****
C
      IF(USINGPCOORDS) THEN
        K = 15
      ELSE
        K = 1
      ENDIF
      TFREEZING = -1.89999999999999991118D00
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              IF(THETA(I, J, K, BI, BJ) .LT. TFREEZING) THEN
                SURFACEFORCINGTICE(I, J, BI, BJ) = ((HFACC(I, J, K, BI,
     >  BJ) * DRF(K) *(TFREEZING - THETA(I, J, K, BI, BJ))) /
     >  DTTRACERLEV(K))
                THETA(I, J, K, BI, BJ) = TFREEZING
              ELSE
                SURFACEFORCINGTICE(I, J, BI, BJ) = 0.0D00
              ENDIF
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE grad_sigma(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, RHOK,
     >  SIGKM1, SIGKP1, SIGMAX, SIGMAY, SIGMAR, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) RHOK(-2 : 93, -2 : 43)
      REAL(w2f__8) SIGKM1(-2 : 93, -2 : 43)
      REAL(w2f__8) SIGKP1(-2 : 93, -2 : 43)
      REAL(w2f__8) SIGMAX(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAY(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) SIGMAR(-2 : 93, -2 : 43, 1 : 15)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL fill_cs_corner_tr_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) RHOLOC(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          RHOLOC(I, J) = RHOK(I, J)
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE) THEN
        CALL fill_cs_corner_tr_rl((1), (.FALSE.), RHOLOC, BI, BJ,
     >  MYTHID)
      ENDIF
      DO J = -2, 43, 1
        DO I = -1, 93, 1
          SIGMAX(I, J, K) = (RECIP_DXC(I, J, BI, BJ) * MASKW(I, J, K,
     >  BI, BJ) *(RHOLOC(I, J) - RHOLOC(I + (-1), J)))
        END DO
      END DO
      IF(USECUBEDSPHEREEXCHANGE) THEN
        CALL fill_cs_corner_tr_rl((2), (.FALSE.), RHOLOC, BI, BJ,
     >  MYTHID)
      ENDIF
      DO J = -1, 43, 1
        DO I = -2, 93, 1
          SIGMAY(I, J, K) = (RECIP_DYC(I, J, BI, BJ) * MASKS(I, J, K,
     >  BI, BJ) *(RHOLOC(I, J) - RHOLOC(I, J + (-1))))
        END DO
      END DO
      IF(K .eq. 1) THEN
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            SIGMAR(I, J, K) = 0.0D00
          END DO
        END DO
      ELSE
        DO J = -2, 43, 1
          DO I = -2, 93, 1
            SIGMAR(I, J, K) = (RKSIGN * RECIP_DRC(K) * MASKC(I, J, K,
     >  BI, BJ) *(SIGKP1(I, J) - SIGKM1(I, J)))
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE impldiff(BI, BJ, IMIN, IMAX, JMIN, JMAX, TRACERID,
     >  KAPPARX, RECIP_HFAC, GXNM1, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) TRACERID
      REAL(w2f__8) KAPPARX(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) RECIP_HFAC(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GXNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) B(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) BET(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) C(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) DELTATX(1 : 15)
      REAL(w2f__8) GAM(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) GYNM1(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      IF(TRACERID .GE. 1) THEN
        DO K = 1, 15, 1
          DELTATX(K) = DTTRACERLEV(K)
        END DO
      ELSE
        DO K = 1, 15, 1
          DELTATX(K) = DELTATMOM
        END DO
      ENDIF
      DO K = 1, 15, 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GYNM1(I, J, K, BI, BJ) = 0.0D00
          END DO
        END DO
      END DO
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          A(I, J, 1) = 0.0D00
        END DO
      END DO
      DO K = 2, 15, 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            A(I, J, K) = (-(RHOFACF(K) * DEEPFAC2F(K) * RECIP_DRC(K) *
     >  KAPPARX(I, J, K) * RECIP_RHOFACC(K) * RECIP_DEEPFAC2C(K) *
     >  RECIP_DRF(K) * DELTATX(K) * RECIP_HFAC(I, J, K, BI, BJ)))
            IF(RECIP_HFAC(I, J, K + (-1), BI, BJ) .eq. 0.0D00) THEN
              A(I, J, K) = 0.0D00
            ENDIF
          END DO
        END DO
      END DO
      DO K = 1, 14, 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            C(I, J, K) = (-(RHOFACF(K + 1) * DEEPFAC2F(K + 1) *
     >  RECIP_DRC(K + 1) * KAPPARX(I, J, K + 1) * RECIP_RHOFACC(K) *
     >  RECIP_DEEPFAC2C(K) * RECIP_DRF(K) * DELTATX(K) * RECIP_HFAC(I,
     >  J, K, BI, BJ)))
            IF(RECIP_HFAC(I, J, K + 1, BI, BJ) .eq. 0.0D00) THEN
              C(I, J, K) = 0.0D00
            ENDIF
          END DO
        END DO
      END DO
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          C(I, J, 15) = 0.0D00
        END DO
      END DO
      DO K = 1, 15, 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            B(I, J, K) = (1.0D00 - C(I, J, K) - A(I, J, K))
          END DO
        END DO
      END DO
      DO K = 1, 15, 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            BET(I, J, K) = 1.0D00
            GAM(I, J, K) = 0.0D00
          END DO
        END DO
      END DO
      IF(.TRUE.) THEN
        K = 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            IF(B(I, J, 1) .ne. 0.0D00) THEN
              BET(I, J, 1) = 1D00 / (B(I, J, 1))
            ENDIF
          END DO
        END DO
      ENDIF
      IF(.TRUE.) THEN
        DO K = 2, 15, 1
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GAM(I, J, K) = (BET(I, J, K + (-1)) * C(I, J, K + (-1)))
              IF((B(I, J, K) - A(I, J, K) * GAM(I, J, K)) .ne. 0.0D00)
     >  THEN
                BET(I, J, K) = 1D00 / (B(I, J, K) - A(I, J, K) * GAM(I,
     >  J, K))
              ENDIF
            END DO
          END DO
        END DO
      ENDIF
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          GYNM1(I, J, 1, BI, BJ) = (BET(I, J, 1) * GXNM1(I, J, 1, BI,
     >  BJ))
        END DO
      END DO
      DO K = 2, 15, 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GYNM1(I, J, K, BI, BJ) = (BET(I, J, K) *(GXNM1(I, J, K, BI,
     >  BJ) - A(I, J, K) * GYNM1(I, J, K + (-1), BI, BJ)))
          END DO
        END DO
      END DO
      DO K = 14, 1, (-1)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GYNM1(I, J, K, BI, BJ) = (GYNM1(I, J, K, BI, BJ) - GAM(I, J
     > , K + 1) * GYNM1(I, J, K + 1, BI, BJ))
          END DO
        END DO
      END DO
      DO K = 1, 15, 1
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GXNM1(I, J, K, BI, BJ) = GYNM1(I, J, K, BI, BJ)
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_autodiff(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use ffields_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      TSURFCOR = 0.0D00
      SSURFCOR = 0.0D00
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
              END DO
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
            END DO
          END DO
        END DO
      END DO
      END SUBROUTINE

      SUBROUTINE ini_cartesian_grid(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IG
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JG
      REAL(w2f__8) XG0
      REAL(w2f__8) XGLOC(-2 : 94, -2 : 44)
      REAL(w2f__8) YG0
      REAL(w2f__8) YGLOC(-2 : 94, -2 : 44)
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          JG = MYYGLOBALLO + BJ * 40 +(-40)
          IG = MYXGLOBALLO + BI * 90 +(-90)
          XG0 = XGORIGIN
          DO I = 1, (IG +(-1)), 1
            XG0 = DELX(I) + XG0
          END DO
          DO I = 1, 3, 1
            XG0 = XG0 - DELX(MOD(IG - I + 269, 90) + 1)
          END DO
          YG0 = YGORIGIN
          DO J = 1, (JG +(-1)), 1
            YG0 = DELY(J) + YG0
          END DO
          DO J = 1, 3, 1
            YG0 = YG0 - DELY(MOD(JG - J + 119, 40) + 1)
          END DO
          DO J = -2, 44, 1
            XGLOC((-2), J) = XG0
            DO I = -2, 93, 1
              XGLOC(I + 1, J) = (DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) *
     >  90 + 268, 90) + 1) + XGLOC(I, J))
            END DO
          END DO
          DO I = -2, 94, 1
            YGLOC(I, (-2)) = YG0
            DO J = -2, 43, 1
              YGLOC(I, J + 1) = (DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) *
     >  40 + 118, 40) + 1) + YGLOC(I, J))
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XG(I, J, BI, BJ) = XGLOC(I, J)
              YG(I, J, BI, BJ) = YGLOC(I, J)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XC(I, J, BI, BJ) = ((XGLOC(I + 1, J + 1) + XGLOC(I, J + 1
     > ) + XGLOC(I, J) + XGLOC(I + 1, J)) * 2.5D-01)
              YC(I, J, BI, BJ) = ((YGLOC(I + 1, J + 1) + YGLOC(I, J + 1
     > ) + YGLOC(I, J) + YGLOC(I + 1, J)) * 2.5D-01)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              DXF(I, J, BI, BJ) = DELX(MOD(I + MYXGLOBALLO +(BI +(-1))
     >  * 90 + 268, 90) + 1)
              DYF(I, J, BI, BJ) = DELY(MOD(J + MYYGLOBALLO +(BJ +(-1))
     >  * 40 + 118, 40) + 1)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              DXG(I, J, BI, BJ) = DELX(MOD(I + MYXGLOBALLO +(BI +(-1))
     >  * 90 + 268, 90) + 1)
              DYG(I, J, BI, BJ) = DELY(MOD(J + MYYGLOBALLO +(BJ +(-1))
     >  * 40 + 118, 40) + 1)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              DXC(I, J, BI, BJ) = 0.0D00
              DYC(I, J, BI, BJ) = 0.0D00
              DXV(I, J, BI, BJ) = 0.0D00
              DYU(I, J, BI, BJ) = 0.0D00
              RAW(I, J, BI, BJ) = 0.0D00
              RAS(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              DXC(I, J, BI, BJ) = ((DXF(I, J, BI, BJ) + DXF(I + (-1), J
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              DYC(I, J, BI, BJ) = ((DYF(I, J, BI, BJ) + DYF(I, J + (-1)
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -1, 93, 1
              DXV(I, J, BI, BJ) = ((DXG(I, J, BI, BJ) + DXG(I + (-1), J
     > , BI, BJ)) * 5.0D-01)
              DYU(I, J, BI, BJ) = ((DYG(I, J, BI, BJ) + DYG(I, J + (-1)
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              RA(I, J, BI, BJ) = (DXF(I, J, BI, BJ) * DYF(I, J, BI, BJ)
     > )
              RAW(I, J, BI, BJ) = (DXC(I, J, BI, BJ) * DYG(I, J, BI, BJ
     > ))
              RAS(I, J, BI, BJ) = (DXG(I, J, BI, BJ) * DYC(I, J, BI, BJ
     > ))
              RAZ(I, J, BI, BJ) = (DXV(I, J, BI, BJ) * DYU(I, J, BI, BJ
     > ))
              TANPHIATU(I, J, BI, BJ) = 0.0D00
              TANPHIATV(I, J, BI, BJ) = 0.0D00
              ANGLECOSC(I, J, BI, BJ) = 1.0D00
              ANGLESINC(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            COSFACU(J, BI, BJ) = 1.0D00
            COSFACV(J, BI, BJ) = 1.0D00
            SQCOSFACU(J, BI, BJ) = 1.0D00
            SQCOSFACV(J, BI, BJ) = 1.0D00
          END DO
        END DO
      END DO
      IF(MYTHID .eq. 1) THEN
        IF(LATBANDCLIMRELAX .eq. 1.2345669999999999709D+05) THEN
          LATBANDCLIMRELAX = 0.0D00
          DO J = 1, 40, 1
            LATBANDCLIMRELAX = DELY(J) + LATBANDCLIMRELAX
          END DO
          LATBANDCLIMRELAX = LATBANDCLIMRELAX * 3.0D00
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_cg2d(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use cg2d_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) AC
      REAL(w2f__8) ACS
      REAL(w2f__8) ACW
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_uv_xy_rs
      EXTERNAL exch_xy_rs
      REAL(w2f__8) FACEAREA
      EXTERNAL global_max_r8
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KS
      CHARACTER(512) MSGBUF
      REAL(w2f__8) MYNORM
      EXTERNAL print_message
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              AW2D(I, J, BI, BJ) = 0.0D00
              AS2D(I, J, BI, BJ) = 0.0D00
              AC2D(I, J, BI, BJ) = 0.0D00
              PW(I, J, BI, BJ) = 0.0D00
              PS(I, J, BI, BJ) = 0.0D00
              PC(I, J, BI, BJ) = 0.0D00
              CG2D_Q(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO J = 0, 41, 1
            DO I = 0, 91, 1
              CG2D_R(I, J, BI, BJ) = 0.0D00
              CG2D_S(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      MYNORM = 0.0D00
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              AW2D(I, J, BI, BJ) = 0.0D00
              AS2D(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO K = 1, 15, 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                FACEAREA = HFACW(I, J, K, BI, BJ) * DRF(K) * DYG(I, J,
     >  BI, BJ)
                AW2D(I, J, BI, BJ) = (AW2D(I, J, BI, BJ) + RECIP_DXC(I,
     >  J, BI, BJ) * FACEAREA * IMPLICDIV2DFLOW * IMPLICSURFPRESS)
                FACEAREA = HFACS(I, J, K, BI, BJ) * DRF(K) * DXG(I, J,
     >  BI, BJ)
                AS2D(I, J, BI, BJ) = (AS2D(I, J, BI, BJ) + RECIP_DYC(I,
     >  J, BI, BJ) * FACEAREA * IMPLICDIV2DFLOW * IMPLICSURFPRESS)
              END DO
            END DO
          END DO
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              MYNORM = MAX(MYNORM, ABS(AW2D(I, J, BI, BJ)))
              MYNORM = MAX(MYNORM, ABS(AS2D(I, J, BI, BJ)))
            END DO
          END DO
        END DO
      END DO
      CALL global_max_r8(MYNORM, MYTHID)
      IF(MYNORM .ne. 0.0D00) THEN
        MYNORM = 1D00 / MYNORM
      ELSE
        MYNORM = 1.0D00
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              AW2D(I, J, BI, BJ) = (AW2D(I, J, BI, BJ) * MYNORM)
              AS2D(I, J, BI, BJ) = (AS2D(I, J, BI, BJ) * MYNORM)
            END DO
          END DO
        END DO
      END DO
      CALL exch_uv_xy_rs(AW2D, AS2D, (.FALSE.), MYTHID)
      IF(MYTHID .eq. 1) THEN
        CG2DNORM = MYNORM
        CG2DNORMALISERHS = CG2DTARGETRESWUNIT .LE. 0.0D00
        IF(CG2DNORMALISERHS) THEN
          CG2DTOLERANCE = CG2DTARGETRESIDUAL
        ELSE
          CG2DTOLERANCE = (GLOBALAREA * CG2DTARGETRESWUNIT * CG2DNORM)
     >  / DELTATMOM
        ENDIF
      ENDIF
      IF(MYTHID .eq. 1) THEN
        WRITE(MSGBUF, '(2A,1PE23.16)') 'INI_CG2D: ',
     >  'CG2D normalisation factor = ', CG2DNORM
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
        IF(.NOT. CG2DNORMALISERHS) THEN
          WRITE(MSGBUF, '(2A,1PE22.15,A,1PE16.10,A)') 'INI_CG2D: ',
     >  'cg2dTolerance =', CG2DTOLERANCE, ' (Area=', GLOBALAREA, ')'
          CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
        ENDIF
        WRITE(MSGBUF, *) ' '
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              KS = KSURFC(I, J, BI, BJ)
              PC(I, J, BI, BJ) = 1.0D00
              AC = -(AS2D(I, J + 1, BI, BJ) + AS2D(I, J, BI, BJ) + AW2D
     > (I, J, BI, BJ) + AW2D(I + 1, J, BI, BJ) +(((RA(I, J, BI, BJ) *
     >  DEEPFAC2F(KS) * RECIP_BO(I, J, BI, BJ) * MYNORM * FREESURFFAC)
     >  / DELTATMOM) / DELTATFREESURF))
              ACS = -(AS2D(I, J, BI, BJ) + AS2D(I, J + (-1), BI, BJ) +
     >  AW2D(I, J + (-1), BI, BJ) + AW2D(I + 1, J + (-1), BI, BJ) +(((
     > RA(I, J + (-1), BI, BJ) * DEEPFAC2F(KS) * RECIP_BO(I, J + (-1),
     >  BI, BJ) * MYNORM * FREESURFFAC) / DELTATMOM) / DELTATFREESURF))
              ACW = -(AS2D(I + (-1), J + 1, BI, BJ) + AS2D(I + (-1), J,
     >  BI, BJ) + AW2D(I, J, BI, BJ) + AW2D(I + (-1), J, BI, BJ) +(((RA
     > (I + (-1), J, BI, BJ) * DEEPFAC2F(KS) * RECIP_BO(I + (-1), J, BI
     > , BJ) * MYNORM * FREESURFFAC) / DELTATMOM) / DELTATFREESURF))
              IF(AC .eq. 0.0D00) THEN
                PC(I, J, BI, BJ) = 1.0D00
              ELSE
                PC(I, J, BI, BJ) = 1D00 / AC
              ENDIF
              IF((AC + ACW) .eq. 0.0D00) THEN
                PW(I, J, BI, BJ) = 0.0D00
              ELSE
                PW(I, J, BI, BJ) = (-(AW2D(I, J, BI, BJ) /(((
     > CG2DPCOFFDFAC *(AC + ACW)) ** 2))))
              ENDIF
              IF((AC + ACS) .eq. 0.0D00) THEN
                PS(I, J, BI, BJ) = 0.0D00
              ELSE
                PS(I, J, BI, BJ) = (-(AS2D(I, J, BI, BJ) /(((
     > CG2DPCOFFDFAC *(AC + ACS)) ** 2))))
              ENDIF
              AC2D(I, J, BI, BJ) = AC
            END DO
          END DO
        END DO
      END DO
      CALL exch_xy_rs(PC, MYTHID)
      CALL exch_uv_xy_rs(PW, PS, (.FALSE.), MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_cori(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_xy_rs
      EXTERNAL exch_z_3d_rs
      REAL(w2f__8) FACGRID
      CHARACTER(512) FNAME
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IG
      INTEGER(w2f__i4) ILEN
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) J
      EXTERNAL mds_facef_read_rs
      CHARACTER(512) MSGBUF
      INTEGER(w2f__i4) MYTILE
      EXTERNAL print_message
      EXTERNAL read_rec_xy_rs
C
C     **** Statements ****
C
      IF(USECONSTANTF) THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                FCORI(I, J, BI, BJ) = F0
                FCORIG(I, J, BI, BJ) = F0
                FCORICOS(I, J, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
        END DO
      ELSE
        IF(USEBETAPLANEF) THEN
          FACGRID = 1.0D00
          IF(USINGCURVILINEARGRID .OR. USINGSPHERICALPOLARGRID) THEN
            FACGRID = RSPHERE * 1.74532925199432954744D-02
          ENDIF
          DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
            DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  FCORI(I, J, BI, BJ) = (F0 + FACGRID * YC(I, J, BI, BJ
     > ) * BETA)
                  FCORIG(I, J, BI, BJ) = (F0 + FACGRID * YG(I, J, BI,
     >  BJ) * BETA)
                  FCORICOS(I, J, BI, BJ) = 0.0D00
                END DO
              END DO
            END DO
          END DO
        ELSE
          IF(USESPHEREF) THEN
            DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
              DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
                DO J = -2, 43, 1
                  DO I = -2, 93, 1
                    FCORI(I, J, BI, BJ) = (SIN(YC(I, J, BI, BJ) *
     >  1.74532925199432954744D-02) * OMEGA * 2.0D00)
                    FCORIG(I, J, BI, BJ) = (SIN(YG(I, J, BI, BJ) *
     >  1.74532925199432954744D-02) * OMEGA * 2.0D00)
                    FCORICOS(I, J, BI, BJ) = (COS(YC(I, J, BI, BJ) *
     >  1.74532925199432954744D-02) * OMEGA * 2.0D00)
                  END DO
                END DO
              END DO
            END DO
          ELSE
            DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
              DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
                DO J = -2, 43, 1
                  DO I = -2, 93, 1
                    FCORI(I, J, BI, BJ) = 0.0D00
                    FCORIG(I, J, BI, BJ) = 0.0D00
                    FCORICOS(I, J, BI, BJ) = 0.0D00
                  END DO
                END DO
              END DO
            END DO
            CALL barrier(MYTHID)
            CALL read_rec_xy_rs('fCoriC.bin', FCORI, (1), (0), MYTHID)
            CALL read_rec_xy_rs('fCorCs.bin', FCORICOS, (1), (0),
     >  MYTHID)
            IF(.NOT. USECUBEDSPHEREEXCHANGE) THEN
              CALL read_rec_xy_rs('fCoriG.bin', FCORIG, (1), (0),
     >  MYTHID)
            ELSE
              IF(MYTHID .eq. 1) THEN
                DO BJ = 1, 1, 1
                  DO BI = 1, 1, 1
                    IG = BI +((MYXGLOBALLO +(-1)) / 90)
                    MYTILE = IG
                    WRITE(FNAME, '(2A,I3.3,A)') 'fCoriG', '.face', IG,
     >  '.bin'
                    ILEN = ilnblnk(FNAME)
                    WRITE(MSGBUF, '(A,I6,2A)') ' Reading tile:', MYTILE
     > , ' from file ', FNAME(1_w2f__i8 : ILEN)
                    CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R'
     > , MYTHID)
                    CALL mds_facef_read_rs(FNAME, READBINARYPREC, (1),
     >  FCORIG, (BI), (BJ), MYTHID)
                  END DO
                END DO
              ENDIF
            ENDIF
            CALL exch_xy_rs(FCORI, MYTHID)
            CALL exch_xy_rs(FCORICOS, MYTHID)
            CALL exch_z_3d_rs(FCORIG, (1), MYTHID)
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_curvilinear_grid(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Global Variables & Derived Type Definitions ****
C
      SAVE /local_ini_curvilinear_grid/
      COMMON /local_ini_curvilinear_grid/ ANGLESARESET
      LOGICAL(w2f__i4) ANGLESARESET
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL calc_angles
      EXTERNAL exch_uv_agrid_3d_rs
      EXTERNAL exch_uv_bgrid_3d_rs
      EXTERNAL exch_uv_xy_rs
      EXTERNAL exch_xy_rs
      EXTERNAL exch_z_3d_rs
      CHARACTER(512) FNAME
      INTEGER(w2f__i4) FP
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IG
      INTEGER(w2f__i4) IL
      INTEGER(w2f__i4) ILEN
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JG
      EXTERNAL mds_facef_read_rs
      CHARACTER(512) MSGBUF
      EXTERNAL plot_field_xyrs
      EXTERNAL print_error
      EXTERNAL print_message
      CHARACTER(512) TMPBUF
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XC(I, J, BI, BJ) = 0.0D00
              YC(I, J, BI, BJ) = 0.0D00
              XG(I, J, BI, BJ) = 0.0D00
              YG(I, J, BI, BJ) = 0.0D00
              DXC(I, J, BI, BJ) = 0.0D00
              DYC(I, J, BI, BJ) = 0.0D00
              DXG(I, J, BI, BJ) = 0.0D00
              DYG(I, J, BI, BJ) = 0.0D00
              DXF(I, J, BI, BJ) = 0.0D00
              DYF(I, J, BI, BJ) = 0.0D00
              DXV(I, J, BI, BJ) = 0.0D00
              DYU(I, J, BI, BJ) = 0.0D00
              RA(I, J, BI, BJ) = 0.0D00
              RAZ(I, J, BI, BJ) = 0.0D00
              RAW(I, J, BI, BJ) = 0.0D00
              RAS(I, J, BI, BJ) = 0.0D00
              TANPHIATU(I, J, BI, BJ) = 0.0D00
              TANPHIATV(I, J, BI, BJ) = 0.0D00
              ANGLECOSC(I, J, BI, BJ) = 1.0D00
              ANGLESINC(I, J, BI, BJ) = 0.0D00
              COSFACU(J, BI, BJ) = 1.0D00
              COSFACV(J, BI, BJ) = 1.0D00
              SQCOSFACU(J, BI, BJ) = 1.0D00
              SQCOSFACV(J, BI, BJ) = 1.0D00
            END DO
          END DO
        END DO
      END DO
      CALL barrier(MYTHID)
      IF(MYTHID .eq. 1) THEN
        FP = 64
        DO BJ = 1, 1, 1
          DO BI = 1, 1, 1
            IG = BI +((MYXGLOBALLO +(-1)) / 90)
            JG = BJ +((MYYGLOBALLO +(-1)) / 40)
            WRITE(TMPBUF, '(2(A,I3))') 'tile:', IG, ' ,', JG
            IG = IG + JG +(-1)
            ILEN = ilnblnk(HORIZGRIDFILE)
            IF(ILEN .eq. 0) THEN
              WRITE(FNAME, '("tile",I3.3,".mitgrid")') IG
            ELSE
              WRITE(FNAME, '(2A,I3.3,A)') HORIZGRIDFILE(1_w2f__i8 :
     >  ILEN), '.face', IG, '.bin'
            ENDIF
            ILEN = ilnblnk(FNAME)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(3A)') TMPBUF(1_w2f__i8 : IL),
     >  ' ; Read from file ', FNAME(1_w2f__i8 : ILEN)
            CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID
     > )
            WRITE(MSGBUF, '(A)') '  =>'
            CALL mds_facef_read_rs(FNAME, FP, (1), XC, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'xC'
            CALL mds_facef_read_rs(FNAME, FP, (2), YC, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'yC'
            CALL mds_facef_read_rs(FNAME, FP, (3), DXF, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'dxF'
            CALL mds_facef_read_rs(FNAME, FP, (4), DYF, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'dyF'
            CALL mds_facef_read_rs(FNAME, FP, (5), RA, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'rA'
            CALL mds_facef_read_rs(FNAME, FP, (6), XG, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'xG'
            CALL mds_facef_read_rs(FNAME, FP, (7), YG, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'yG'
            CALL mds_facef_read_rs(FNAME, FP, (8), DXV, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'dxV'
            CALL mds_facef_read_rs(FNAME, FP, (9), DYU, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'dyU'
            CALL mds_facef_read_rs(FNAME, FP, (10), RAZ, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'rAz'
            CALL mds_facef_read_rs(FNAME, FP, (11), DXC, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'dxC'
            CALL mds_facef_read_rs(FNAME, FP, (12), DYC, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'dyC'
            CALL mds_facef_read_rs(FNAME, FP, (13), RAW, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'rAw'
            CALL mds_facef_read_rs(FNAME, FP, (14), RAS, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'rAs'
            CALL mds_facef_read_rs(FNAME, FP, (15), DXG, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(MSGBUF)
            WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL), 'dxG'
            CALL mds_facef_read_rs(FNAME, FP, (16), DYG, (BI), (BJ),
     >  MYTHID)
            IL = ilnblnk(TMPBUF)
            WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL), 'dyG'
            ILEN = ilnblnk(HORIZGRIDFILE)
            IF(ILEN .GT. 0) THEN
              CALL mds_facef_read_rs(FNAME, FP, (17), ANGLECOSC, (BI),
     >  (BJ), MYTHID)
              IL = ilnblnk(MSGBUF)
              WRITE(TMPBUF, '(A,1X,A)') MSGBUF(1_w2f__i8 : IL),
     >  'AngleCS'
              CALL mds_facef_read_rs(FNAME, FP, (18), ANGLESINC, (BI),
     >  (BJ), MYTHID)
              IL = ilnblnk(TMPBUF)
              WRITE(MSGBUF, '(A,1X,A)') TMPBUF(1_w2f__i8 : IL),
     >  'AngleSN'
              ANGLESARESET = .TRUE.
            ELSE
              ANGLESARESET = .FALSE.
            ENDIF
            CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID
     > )
          END DO
        END DO
      ENDIF
      CALL exch_xy_rs(XC, MYTHID)
      CALL exch_xy_rs(YC, MYTHID)
      CALL exch_uv_agrid_3d_rs(DXF, DYF, (.FALSE.), (1), MYTHID)
      CALL exch_xy_rs(RA, MYTHID)
      CALL exch_z_3d_rs(XG, (1), MYTHID)
      CALL exch_z_3d_rs(YG, (1), MYTHID)
      CALL exch_uv_bgrid_3d_rs(DXV, DYU, (.FALSE.), (1), MYTHID)
      CALL exch_z_3d_rs(RAZ, (1), MYTHID)
      CALL exch_uv_xy_rs(DXC, DYC, (.FALSE.), MYTHID)
      CALL exch_uv_xy_rs(RAW, RAS, (.FALSE.), MYTHID)
      CALL exch_uv_xy_rs(DYG, DXG, (.FALSE.), MYTHID)
      IF(.NOT. ANGLESARESET) THEN
        CALL calc_angles(MYTHID)
        CALL barrier(MYTHID)
        IF(MYTHID .eq. 1) THEN
          ANGLESARESET = .TRUE.
        ENDIF
      ENDIF
      CALL exch_uv_agrid_3d_rs(ANGLESINC, ANGLECOSC, (.TRUE.), (1),
     >  MYTHID)
      IF(MYTHID .eq. 1) THEN
        IF(USE3DCORIOLIS .AND.(.NOT. ANGLESARESET)) THEN
          WRITE(MSGBUF, '(2A)')
     >  'INI_CURVILINEAR_GRID: Angle of CurvilinearGrid n' // 'ot set',
     >  ' but needed for 3-D Coriolis'
          CALL print_error(MSGBUF, MYTHID)
          WRITE(*, *) 'ABNORMAL END: S/R INI_CURVILINEAR_GRID'
        ENDIF
      ENDIF
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL plot_field_xyrs(XC, 'Current xC      ', (0), MYTHID)
        CALL plot_field_xyrs(YC, 'Current yC      ', (0), MYTHID)
        CALL plot_field_xyrs(DXF, 'Current dxF     ', (0), MYTHID)
        CALL plot_field_xyrs(DYF, 'Current dyF     ', (0), MYTHID)
        CALL plot_field_xyrs(RA, 'Current rA      ', (0), MYTHID)
        CALL plot_field_xyrs(XG, 'Current xG      ', (0), MYTHID)
        CALL plot_field_xyrs(YG, 'Current yG      ', (0), MYTHID)
        CALL plot_field_xyrs(DXV, 'Current dxV     ', (0), MYTHID)
        CALL plot_field_xyrs(DYU, 'Current dyU     ', (0), MYTHID)
        CALL plot_field_xyrs(RAZ, 'Current rAz     ', (0), MYTHID)
        CALL plot_field_xyrs(DXC, 'Current dxC     ', (0), MYTHID)
        CALL plot_field_xyrs(DYC, 'Current dyC     ', (0), MYTHID)
        CALL plot_field_xyrs(RAW, 'Current rAw     ', (0), MYTHID)
        CALL plot_field_xyrs(RAS, 'Current rAs     ', (0), MYTHID)
        CALL plot_field_xyrs(DXG, 'Current dxG     ', (0), MYTHID)
        CALL plot_field_xyrs(DYG, 'Current dyG     ', (0), MYTHID)
        CALL plot_field_xyrs(ANGLECOSC, 'Current AngleCS ', (0), MYTHID
     > )
        CALL plot_field_xyrs(ANGLESINC, 'Current AngleSN ', (0), MYTHID
     > )
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_cylinder_grid(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) DTHETA
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IG
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JG
      REAL(w2f__8) THISRAD
      REAL(w2f__8) XG0
      REAL(w2f__8) XGLOC(-2 : 94, -2 : 44)
      REAL(w2f__8) YG0
      REAL(w2f__8) YGLOC(-2 : 94, -2 : 44)
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          JG = MYYGLOBALLO + BJ * 40 +(-40)
          IG = MYXGLOBALLO + BI * 90 +(-90)
          XG0 = XGORIGIN
          DO I = 1, (IG +(-1)), 1
            XG0 = DELX(I) + XG0
          END DO
          DO I = 1, 3, 1
            XG0 = XG0 - DELX(MOD(IG - I + 269, 90) + 1)
          END DO
          YG0 = YGORIGIN
          DO J = 1, (JG +(-1)), 1
            YG0 = DELY(J) + YG0
          END DO
          DO J = 1, 3, 1
            YG0 = YG0 - DELY(MOD(JG - J + 119, 40) + 1)
          END DO
          DO J = -2, 44, 1
            XGLOC((-2), J) = XG0
            DO I = -2, 93, 1
              XGLOC(I + 1, J) = (DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) *
     >  90 + 268, 90) + 1) + XGLOC(I, J))
            END DO
          END DO
          DO I = -2, 94, 1
            YGLOC(I, (-2)) = YG0
            DO J = -2, 43, 1
              YGLOC(I, J + 1) = (DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) *
     >  40 + 118, 40) + 1) + YGLOC(I, J))
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XG(I, J, BI, BJ) = XGLOC(I, J)
              YG(I, J, BI, BJ) = YGLOC(I, J)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XC(I, J, BI, BJ) = ((XGLOC(I + 1, J + 1) + XGLOC(I, J + 1
     > ) + XGLOC(I, J) + XGLOC(I + 1, J)) * 2.5D-01)
              YC(I, J, BI, BJ) = ((YGLOC(I + 1, J + 1) + YGLOC(I, J + 1
     > ) + YGLOC(I, J) + YGLOC(I + 1, J)) * 2.5D-01)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              THISRAD = YC(I, J, BI, BJ)
              DTHETA = DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) * 90 + 268,
     >  90) + 1)
              DXF(I, J, BI, BJ) = (DTHETA * THISRAD *
     >  1.74532925199432954744D-02)
              DYF(I, J, BI, BJ) = DELY(MOD(J + MYYGLOBALLO +(BJ +(-1))
     >  * 40 + 118, 40) + 1)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              THISRAD = (YGLOC(I, J) + YGLOC(I + 1, J)) * 5.0D-01
              DTHETA = DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) * 90 + 268,
     >  90) + 1)
              DXG(I, J, BI, BJ) = (DTHETA * THISRAD *
     >  1.74532925199432954744D-02)
              DYG(I, J, BI, BJ) = DELY(MOD(J + MYYGLOBALLO +(BJ +(-1))
     >  * 40 + 118, 40) + 1)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              DXC(I, J, BI, BJ) = 0.0D00
              DYC(I, J, BI, BJ) = 0.0D00
              DXV(I, J, BI, BJ) = 0.0D00
              DYU(I, J, BI, BJ) = 0.0D00
              RAW(I, J, BI, BJ) = 0.0D00
              RAS(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              DXC(I, J, BI, BJ) = ((DXF(I, J, BI, BJ) + DXF(I + (-1), J
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              DYC(I, J, BI, BJ) = ((DYF(I, J, BI, BJ) + DYF(I, J + (-1)
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -1, 93, 1
              DXV(I, J, BI, BJ) = ((DXG(I, J, BI, BJ) + DXG(I + (-1), J
     > , BI, BJ)) * 5.0D-01)
              DYU(I, J, BI, BJ) = ((DYG(I, J, BI, BJ) + DYG(I, J + (-1)
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              RA(I, J, BI, BJ) = (DXF(I, J, BI, BJ) * DYF(I, J, BI, BJ)
     > )
              RAW(I, J, BI, BJ) = (DXC(I, J, BI, BJ) * DYG(I, J, BI, BJ
     > ))
              RAS(I, J, BI, BJ) = (DXG(I, J, BI, BJ) * DYC(I, J, BI, BJ
     > ))
              RAZ(I, J, BI, BJ) = (DXV(I, J, BI, BJ) * DYU(I, J, BI, BJ
     > ))
              TANPHIATU(I, J, BI, BJ) = 0.0D00
              TANPHIATV(I, J, BI, BJ) = 0.0D00
              ANGLECOSC(I, J, BI, BJ) = 1.0D00
              ANGLESINC(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            COSFACU(J, BI, BJ) = 1.0D00
            COSFACV(J, BI, BJ) = 1.0D00
            SQCOSFACU(J, BI, BJ) = 1.0D00
            SQCOSFACV(J, BI, BJ) = 1.0D00
          END DO
        END DO
      END DO
      IF(LATBANDCLIMRELAX .eq. 1.2345669999999999709D+05) THEN
        IF(MYTHID .eq. 1) THEN
          LATBANDCLIMRELAX = 0.0D00
          DO J = 1, 40, 1
            LATBANDCLIMRELAX = DELY(J) + LATBANDCLIMRELAX
          END DO
          LATBANDCLIMRELAX = LATBANDCLIMRELAX * 3.0D00
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_depths(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_xy_rs
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IG
      EXTERNAL ini_p_ground
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JG
      CHARACTER(512) MSGBUF
      EXTERNAL plot_field_xyrs
      EXTERNAL print_error
      EXTERNAL read_rec_xy_rs
C
C     **** Statements ****
C
      IF((TOPOFILE .NE. ' ') .AND.(USINGPCOORDS .AND.(BATHYFILE .NE.
     >  ' '))) THEN
        WRITE(MSGBUF, '(A,A)')
     >  'S/R INI_DEPTHS: both bathyFile & topoFile are sp' //
     >  'ecified:', ' select the right one !'
        CALL print_error(MSGBUF, MYTHID)
        WRITE(*, *) 'ABNORMAL END: S/R INI_DEPTHS'
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              R_LOW(I, J, BI, BJ) = 0.0D00
              RO_SURF(I, J, BI, BJ) = 0.0D00
              TOPOZ(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      CALL barrier(MYTHID)
      IF(USINGPCOORDS .OR.(BATHYFILE .EQ. ' ')) THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                R_LOW(I, J, BI, BJ) = RF(16)
              END DO
            END DO
          END DO
        END DO
      ELSE
        CALL read_rec_xy_rs(BATHYFILE, R_LOW, (1), (0), MYTHID)
      ENDIF
      CALL exch_xy_rs(R_LOW, MYTHID)
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL plot_field_xyrs(R_LOW, 'Bottom depths (ini_depths)', (-1),
     >  MYTHID)
      ENDIF
      IF(USINGPCOORDS .AND.(BATHYFILE .NE. ' ')) THEN
        CALL read_rec_xy_rs(BATHYFILE, RO_SURF, (1), (0), MYTHID)
      ELSE
        IF(TOPOFILE .EQ. ' ') THEN
          DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
            DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
              DO J = 1, 40, 1
                DO I = 1, 90, 1
                  RO_SURF(I, J, BI, BJ) = RF(1)
                END DO
              END DO
            END DO
          END DO
        ELSE
          CALL read_rec_xy_rs(TOPOFILE, TOPOZ, (1), (0), MYTHID)
          CALL barrier(MYTHID)
          IF(BUOYANCYRELATION .EQ. 'ATMOSPHERIC') THEN
            CALL ini_p_ground((2), TOPOZ, RO_SURF, MYTHID)
          ELSE
            IF(BUOYANCYRELATION .EQ. 'OCEANICP') THEN
              WRITE(MSGBUF, '(A,A)') 'S/R INI_DEPTHS: ',
     >  'from topoFile (in m) to ref.bottom pressure: Not' //
     >  ' yet coded'
              CALL print_error(MSGBUF, MYTHID)
              WRITE(*, *) 'ABNORMAL END: S/R INI_DEPTHS'
            ELSE
              DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
                DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
                  DO J = 1, 40, 1
                    DO I = 1, 90, 1
                      RO_SURF(I, J, BI, BJ) = TOPOZ(I, J, BI, BJ)
                    END DO
                  END DO
                END DO
              END DO
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      CALL exch_xy_rs(RO_SURF, MYTHID)
      IF(USINGPCOORDS) THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IG = I + MYXGLOBALLO + BI * 90 +(-91)
                JG = J + MYYGLOBALLO + BJ * 40 +(-41)
                IF(USINGSPHERICALPOLARGRID .AND.(ABS(YC(I, J, BI, BJ))
     >  .GE. 9.0D+01)) THEN
                  RO_SURF(I, J, BI, BJ) = RF(16)
                ENDIF
              END DO
            END DO
          END DO
        END DO
      ELSE
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IG = I + MYXGLOBALLO + BI * 90 +(-91)
                JG = J + MYYGLOBALLO + BJ * 40 +(-41)
                IF(USINGSPHERICALPOLARGRID .AND.(ABS(YC(I, J, BI, BJ))
     >  .GE. 9.0D+01)) THEN
                  R_LOW(I, J, BI, BJ) = RF(1)
                ENDIF
              END DO
            END DO
          END DO
        END DO
      ENDIF
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL plot_field_xyrs(RO_SURF,
     >  'Surface reference r-position (ini_depths)', (-1), MYTHID)
      ENDIF
      CALL barrier(MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_fields(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL ini_pnh
      EXTERNAL ini_pressure
      EXTERNAL ini_psurf
      EXTERNAL ini_salt
      EXTERNAL ini_theta
      EXTERNAL ini_vel
      EXTERNAL read_pickup
C
C     **** Statements ****
C
      IF((PICKUPSUFF .EQ. ' ') .AND.((NITER0 .eq. 0) .AND.(BASETIME
     >  .eq. STARTTIME))) THEN
        CALL ini_vel(MYTHID)
        CALL ini_theta(MYTHID)
        CALL ini_salt(MYTHID)
        CALL ini_psurf(MYTHID)
        CALL ini_pressure(MYTHID)
        IF(NONHYDROSTATIC) THEN
          CALL ini_pnh(MYTHID)
        ENDIF
      ELSE
        IF(.NOT. USEOFFLINE) THEN
          CALL read_pickup(NITER0, MYTHID)
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_forcing(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use ffields_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_uv_xy_rs
      EXTERNAL exch_xy_rs
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      EXTERNAL read_fld_xy_rs
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              FU(I, J, BI, BJ) = 0.0D00
              FV(I, J, BI, BJ) = 0.0D00
              QNET(I, J, BI, BJ) = 0.0D00
              EMPMR(I, J, BI, BJ) = 0.0D00
              SALTFLUX(I, J, BI, BJ) = 0.0D00
              SST(I, J, BI, BJ) = 0.0D00
              SSS(I, J, BI, BJ) = 0.0D00
              QSW(I, J, BI, BJ) = 0.0D00
              PLOAD(I, J, BI, BJ) = 0.0D00
              SICELOAD(I, J, BI, BJ) = 0.0D00
              SURFACEFORCINGU(I, J, BI, BJ) = 0.0D00
              SURFACEFORCINGV(I, J, BI, BJ) = 0.0D00
              SURFACEFORCINGT(I, J, BI, BJ) = 0.0D00
              SURFACEFORCINGS(I, J, BI, BJ) = 0.0D00
              SURFACEFORCINGTICE(I, J, BI, BJ) = 0.0D00
              TAUX0(I, J, BI, BJ) = 0.0D00
              TAUX1(I, J, BI, BJ) = 0.0D00
              TAUY0(I, J, BI, BJ) = 0.0D00
              TAUY1(I, J, BI, BJ) = 0.0D00
              QNET0(I, J, BI, BJ) = 0.0D00
              QNET1(I, J, BI, BJ) = 0.0D00
              EMPMR0(I, J, BI, BJ) = 0.0D00
              EMPMR1(I, J, BI, BJ) = 0.0D00
              SALTFLUX0(I, J, BI, BJ) = 0.0D00
              SALTFLUX1(I, J, BI, BJ) = 0.0D00
              SST0(I, J, BI, BJ) = 0.0D00
              SST1(I, J, BI, BJ) = 0.0D00
              SSS0(I, J, BI, BJ) = 0.0D00
              SSS1(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              IF(DOTHETACLIMRELAX .AND.(LATBANDCLIMRELAX .GE. ABS(YC(I,
     >  J, BI, BJ)))) THEN
                LAMBDATHETACLIMRELAX(I, J, BI, BJ) = 1D00 /
     >  TAUTHETACLIMRELAX
              ELSE
                LAMBDATHETACLIMRELAX(I, J, BI, BJ) = 0.0D00
              ENDIF
              IF(DOSALTCLIMRELAX .AND.(LATBANDCLIMRELAX .GE. ABS(YC(I,
     >  J, BI, BJ)))) THEN
                LAMBDASALTCLIMRELAX(I, J, BI, BJ) = 1D00 /
     >  TAUSALTCLIMRELAX
              ELSE
                LAMBDASALTCLIMRELAX(I, J, BI, BJ) = 0.0D00
              ENDIF
            END DO
          END DO
        END DO
      END DO
      CALL barrier(MYTHID)
      IF(ZONALWINDFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(ZONALWINDFILE, ' ', FU, (0), MYTHID)
      ENDIF
      IF(MERIDWINDFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(MERIDWINDFILE, ' ', FV, (0), MYTHID)
      ENDIF
      IF(SURFQFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(SURFQFILE, ' ', QNET, (0), MYTHID)
      ELSE
        IF(SURFQNETFILE .NE. ' ') THEN
          CALL read_fld_xy_rs(SURFQNETFILE, ' ', QNET, (0), MYTHID)
        ENDIF
      ENDIF
      IF(EMPMRFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(EMPMRFILE, ' ', EMPMR, (0), MYTHID)
        CALL barrier(MYTHID)
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                EMPMR(I, J, BI, BJ) = (EMPMR(I, J, BI, BJ) *
     >  RHOCONSTFRESH)
              END DO
            END DO
          END DO
        END DO
      ENDIF
      IF(SALTFLUXFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(SALTFLUXFILE, ' ', SALTFLUX, (0), MYTHID)
      ENDIF
      IF(THETACLIMFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(THETACLIMFILE, ' ', SST, (0), MYTHID)
      ENDIF
      IF(SALTCLIMFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(SALTCLIMFILE, ' ', SSS, (0), MYTHID)
      ENDIF
      IF(LAMBDATHETAFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(LAMBDATHETAFILE, ' ', LAMBDATHETACLIMRELAX,
     >  (0), MYTHID)
      ENDIF
      IF(LAMBDASALTFILE .NE. ' ') THEN
        CALL read_fld_xy_rs(LAMBDASALTFILE, ' ', LAMBDASALTCLIMRELAX, (
     > 0), MYTHID)
      ENDIF
      CALL exch_uv_xy_rs(FU, FV, (.TRUE.), MYTHID)
      CALL exch_xy_rs(QNET, MYTHID)
      CALL exch_xy_rs(EMPMR, MYTHID)
      CALL exch_xy_rs(SALTFLUX, MYTHID)
      CALL exch_xy_rs(SST, MYTHID)
      CALL exch_xy_rs(SSS, MYTHID)
      CALL exch_xy_rs(LAMBDATHETACLIMRELAX, MYTHID)
      CALL exch_xy_rs(LAMBDASALTCLIMRELAX, MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_grid(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      EXTERNAL ini_cartesian_grid
      EXTERNAL ini_curvilinear_grid
      EXTERNAL ini_cylinder_grid
      EXTERNAL ini_spherical_polar_grid
      EXTERNAL ini_vertical_grid
      EXTERNAL load_grid_spacing
      CHARACTER(512) MSGBUF
      EXTERNAL print_error
C
C     **** Statements ****
C
      CALL load_grid_spacing(MYTHID)
      CALL ini_vertical_grid(MYTHID)
      IF(USINGCARTESIANGRID) THEN
        CALL ini_cartesian_grid(MYTHID)
      ELSE
        IF(USINGSPHERICALPOLARGRID) THEN
          CALL ini_spherical_polar_grid(MYTHID)
        ELSE
          IF(USINGCURVILINEARGRID) THEN
            CALL ini_curvilinear_grid(MYTHID)
          ELSE
            IF(USINGCYLINDRICALGRID) THEN
              CALL ini_cylinder_grid(MYTHID)
            ELSE
              IF(MYTHID .eq. 1) THEN
                WRITE(MSGBUF, '(2A)') 'S/R INI_GRID: ',
     >  'No grid coordinate system has been selected'
                CALL print_error(MSGBUF, MYTHID)
                WRITE(*, *) 'ABNORMAL END: S/R INI_GRID'
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      CALL barrier(MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_hfac(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                HFACC(I, J, K, BI, BJ) = 0.0D00
                HFACS(I, J, K, BI, BJ) = 0.0D00
                HFACW(I, J, K, BI, BJ) = 0.0D00
                MASKC(I, J, K, BI, BJ) = 0.0D00
                MASKS(I, J, K, BI, BJ) = 0.0D00
                MASKW(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_linear_phisurf(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) DPIDP
      EXTERNAL exch_xy_rl
      EXTERNAL find_rho_scalar
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) PLOC
      REAL(w2f__8) RHOLOC
      EXTERNAL write_fld_xy_rl
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              BO_SURF(I, J, BI, BJ) = 0.0D00
              RECIP_BO(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      IF(BUOYANCYRELATION .EQ. 'OCEANIC') THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                BO_SURF(I, J, BI, BJ) = GBARO
                RECIP_BO(I, J, BI, BJ) = 1D00 / GBARO
              END DO
            END DO
          END DO
        END DO
      ELSE
        IF(UNIFORMLIN_PHISURF) THEN
          DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
            DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  BO_SURF(I, J, BI, BJ) = RECIP_RHOCONST
                  RECIP_BO(I, J, BI, BJ) = RHOCONST
                END DO
              END DO
            END DO
          END DO
        ELSE
          IF(BUOYANCYRELATION .EQ. 'OCEANICP') THEN
            DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
              DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
                DO J = -2, 43, 1
                  DO I = -2, 93, 1
                    IF((KSURFC(I, J, BI, BJ) .LE. 15) .AND.(RO_SURF(I,
     >  J, BI, BJ) .GT. 0.0D00)) THEN
                      PLOC = RO_SURF(I, J, BI, BJ)
                      CALL find_rho_scalar(TREF(KSURFC(I, J, BI, BJ)),
     >  SREF(KSURFC(I, J, BI, BJ)), PLOC, RHOLOC, MYTHID)
                      IF(RHOLOC .eq. 0.0D00) THEN
                        BO_SURF(I, J, BI, BJ) = 0.0D00
                      ELSE
                        BO_SURF(I, J, BI, BJ) = 1D00 / RHOLOC
                      ENDIF
                      RECIP_BO(I, J, BI, BJ) = RHOLOC
                    ELSE
                      BO_SURF(I, J, BI, BJ) = 0.0D00
                      RECIP_BO(I, J, BI, BJ) = 0.0D00
                    ENDIF
                  END DO
                END DO
              END DO
            END DO
          ELSE
            IF(BUOYANCYRELATION .EQ. 'ATMOSPHERIC') THEN
              DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
                DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
                  DO J = -2, 43, 1
                    DO I = -2, 93, 1
                      IF((KSURFC(I, J, BI, BJ) .LE. 15) .AND.(RO_SURF(I
     > , J, BI, BJ) .GT. 0.0D00)) THEN
                        DPIDP = ((RO_SURF(I, J, BI, BJ) / ATM_PO) **(
     > ATM_KAPPA +(-1.0D00))) *((ATM_CP * ATM_KAPPA) / ATM_PO)
                        BO_SURF(I, J, BI, BJ) = (TREF(KSURFC(I, J, BI,
     >  BJ)) * DPIDP)
                        RECIP_BO(I, J, BI, BJ) = 1D00 / (BO_SURF(I, J,
     >  BI, BJ))
                      ELSE
                        BO_SURF(I, J, BI, BJ) = 0.0D00
                        RECIP_BO(I, J, BI, BJ) = 0.0D00
                      ENDIF
                    END DO
                  END DO
                END DO
              END DO
            ELSE
              WRITE(*, *)
     >  'INI_LINEAR_PHISURF: We should never reach this p' // 'oint!'
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      CALL exch_xy_rl(BO_SURF, MYTHID)
      CALL exch_xy_rl(RECIP_BO, MYTHID)
      IF(((BUOYANCYRELATION .EQ. 'OCEANICP') .OR.(BUOYANCYRELATION .EQ.
     >  'ATMOSPHERIC')) .AND.(.NOT. UNIFORMLIN_PHISURF)) THEN
        CALL write_fld_xy_rl('Bo_surf', ' ', BO_SURF, (0), MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              PHI0SURF(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      IF((BUOYANCYRELATION .EQ. 'ATMOSPHERIC') .AND.(TOPOFILE .NE. ' ')
     > ) THEN
        WRITE(*, *) 'CANNOT PRESENTLY USE THIS OPTION WITH ADJOINT'
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_masks_etc(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Global Variables & Derived Type Definitions ****
C
      SAVE /local_ini_masks_etc/
      COMMON /local_ini_masks_etc/ TILEAREA
      REAL(w2f__8) TILEAREA(1 : 1, 1 : 1)
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_uv_xyz_rs
      EXTERNAL global_sum_r8
      REAL(w2f__8) HFACCTMP
      REAL(w2f__8) HFACMNSZ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      CHARACTER(512) MSGBUF
      EXTERNAL plot_field_xyrs
      EXTERNAL plot_field_xyzrs
      EXTERNAL print_message
      REAL(w2f__8) THREADAREA
      REAL(w2f__8) TMPFLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            HFACMNSZ = MAX(HFACMIN, MIN(RECIP_DRF(K) * HFACMINDR,
     >  1.0D00))
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                HFACCTMP = RECIP_DRF(K) *(RF(K) - R_LOW(I, J, BI, BJ))
                HFACCTMP = MIN(MAX(HFACCTMP, 0.0D00), 1.0D00)
                IF(HFACCTMP .LT. HFACMNSZ) THEN
                  IF(HFACCTMP .LT.(HFACMNSZ * 5.0D-01)) THEN
                    HFACC(I, J, K, BI, BJ) = 0.0D00
                  ELSE
                    HFACC(I, J, K, BI, BJ) = HFACMNSZ
                  ENDIF
                ELSE
                  HFACC(I, J, K, BI, BJ) = HFACCTMP
                ENDIF
              END DO
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              R_LOW(I, J, BI, BJ) = RF(1)
              DO K = 15, 1, (-1)
                R_LOW(I, J, BI, BJ) = (R_LOW(I, J, BI, BJ) - DRF(K) *
     >  HFACC(I, J, K, BI, BJ))
              END DO
            END DO
          END DO
        END DO
      END DO
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            HFACMNSZ = MAX(HFACMIN, MIN(RECIP_DRF(K) * HFACMINDR,
     >  1.0D00))
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                HFACCTMP = RECIP_DRF(K) *(RF(K) - RO_SURF(I, J, BI, BJ)
     > )
                HFACCTMP = HFACC(I, J, K, BI, BJ) - MAX(HFACCTMP,
     >  0.0D00)
                HFACCTMP = MAX(HFACCTMP, 0.0D00)
                IF(HFACCTMP .LT. HFACMNSZ) THEN
                  IF(HFACCTMP .LT.(HFACMNSZ * 5.0D-01)) THEN
                    HFACC(I, J, K, BI, BJ) = 0.0D00
                  ELSE
                    HFACC(I, J, K, BI, BJ) = HFACMNSZ
                  ENDIF
                ELSE
                  HFACC(I, J, K, BI, BJ) = HFACCTMP
                ENDIF
              END DO
            END DO
          END DO
        END DO
      END DO
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              TMPFLD(I, J, BI, BJ) = 0.0D00
              KSURFC(I, J, BI, BJ) = 16
              MASKH(I, J, BI, BJ) = 0.0D00
              RO_SURF(I, J, BI, BJ) = R_LOW(I, J, BI, BJ)
              DO K = 15, 1, (-1)
                RO_SURF(I, J, BI, BJ) = (RO_SURF(I, J, BI, BJ) + DRF(K)
     >  * HFACC(I, J, K, BI, BJ))
                IF(HFACC(I, J, K, BI, BJ) .ne. 0.0D00) THEN
                  KSURFC(I, J, BI, BJ) = K
                  MASKH(I, J, BI, BJ) = 1.0D00
                  TMPFLD(I, J, BI, BJ) = (TMPFLD(I, J, BI, BJ) + 1.0D00
     > )
                ENDIF
              END DO
              KLOWC(I, J, BI, BJ) = 0
              DO K = 1, 15, 1
                IF(HFACC(I, J, K, BI, BJ) .ne. 0.0D00) THEN
                  KLOWC(I, J, BI, BJ) = K
                ENDIF
              END DO
            END DO
          END DO
        END DO
      END DO
      CALL plot_field_xyrs(R_LOW, 'Model R_low (ini_masks_etc)', (1),
     >  MYTHID)
      CALL plot_field_xyrs(RO_SURF, 'Model Ro_surf (ini_masks_etc)', (1
     > ), MYTHID)
      THREADAREA = 0.0D00
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              TMPFLD(I, J, BI, BJ) = (RO_SURF(I, J, BI, BJ) - R_LOW(I,
     >  J, BI, BJ))
              IF(TMPFLD(I, J, BI, BJ) .LE. 0.0D00) THEN
                RECIP_RCOL(I, J, BI, BJ) = 0.0D00
              ELSE
                RECIP_RCOL(I, J, BI, BJ) = 1D00 / (TMPFLD(I, J, BI, BJ)
     > )
              ENDIF
            END DO
          END DO
          TILEAREA(BI, BJ) = 0.0D00
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              TILEAREA(BI, BJ) = (TILEAREA(BI, BJ) + MASKH(I, J, BI, BJ
     > ) * RA(I, J, BI, BJ))
            END DO
          END DO
          THREADAREA = TILEAREA(BI, BJ) + THREADAREA
        END DO
      END DO
      CALL global_sum_r8(THREADAREA, MYTHID)
      IF(MYTHID .eq. 1) THEN
        GLOBALAREA = THREADAREA
        MSGBUF(1_w2f__i8 : 1) = ' '
        DO BJ = 1, 1, 1
          DO BI = 1, 1, 1
            IF(TILEAREA(BI, BJ) .eq. 0.0D00) THEN
              WRITE(MSGBUF, '(A,I6,I6)') 'Empty tile bi,bj=', BI, BJ
              CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R',
     >  MYTHID)
            ENDIF
          END DO
        END DO
        IF(MSGBUF(1_w2f__i8 : 1) .NE. ' ') THEN
          WRITE(MSGBUF, '(A)') ' '
          CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
        ENDIF
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              HFACW((-2), J, K, BI, BJ) = 0.0D00
              DO I = -1, 93, 1
                HFACW(I, J, K, BI, BJ) = MIN(HFACC(I, J, K, BI, BJ),
     >  HFACC(I + (-1), J, K, BI, BJ))
              END DO
            END DO
            DO I = -2, 93, 1
              HFACS(I, (-2), K, BI, BJ) = 0.0D00
            END DO
            DO J = -1, 43, 1
              DO I = -2, 93, 1
                HFACS(I, J, K, BI, BJ) = MIN(HFACC(I, J, K, BI, BJ),
     >  HFACC(I, J + (-1), K, BI, BJ))
              END DO
            END DO
          END DO
        END DO
      END DO
      CALL exch_uv_xyz_rs(HFACW, HFACS, (.FALSE.), MYTHID)
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IF(DYG(I, J, BI, BJ) .eq. 0.0D00) THEN
                  HFACW(I, J, K, BI, BJ) = 0.0D00
                ENDIF
                IF(DXG(I, J, BI, BJ) .eq. 0.0D00) THEN
                  HFACS(I, J, K, BI, BJ) = 0.0D00
                ENDIF
              END DO
            END DO
          END DO
        END DO
      END DO
      CALL barrier(MYTHID)
      CALL plot_field_xyzrs(HFACC, 'hFacC', (15), (1), MYTHID)
      CALL plot_field_xyzrs(HFACW, 'hFacW', (15), (1), MYTHID)
      CALL plot_field_xyzrs(HFACS, 'hFacS', (15), (1), MYTHID)
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IF(HFACC(I, J, K, BI, BJ) .ne. 0.0D00) THEN
                  RECIP_HFACC(I, J, K, BI, BJ) = 1D00 / (HFACC(I, J, K,
     >  BI, BJ))
                  MASKC(I, J, K, BI, BJ) = 1.0D00
                ELSE
                  RECIP_HFACC(I, J, K, BI, BJ) = 0.0D00
                  MASKC(I, J, K, BI, BJ) = 0.0D00
                ENDIF
                IF(HFACW(I, J, K, BI, BJ) .ne. 0.0D00) THEN
                  RECIP_HFACW(I, J, K, BI, BJ) = 1D00 / (HFACW(I, J, K,
     >  BI, BJ))
                  MASKW(I, J, K, BI, BJ) = 1.0D00
                ELSE
                  RECIP_HFACW(I, J, K, BI, BJ) = 0.0D00
                  MASKW(I, J, K, BI, BJ) = 0.0D00
                ENDIF
                IF(HFACS(I, J, K, BI, BJ) .ne. 0.0D00) THEN
                  RECIP_HFACS(I, J, K, BI, BJ) = 1D00 / (HFACS(I, J, K,
     >  BI, BJ))
                  MASKS(I, J, K, BI, BJ) = 1.0D00
                ELSE
                  RECIP_HFACS(I, J, K, BI, BJ) = 0.0D00
                  MASKS(I, J, K, BI, BJ) = 0.0D00
                ENDIF
              END DO
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              KSURFW(I, J, BI, BJ) = 16
              KSURFS(I, J, BI, BJ) = 16
              DO K = 15, 1, (-1)
                IF(HFACW(I, J, K, BI, BJ) .ne. 0.0D00) THEN
                  KSURFW(I, J, BI, BJ) = K
                ENDIF
                IF(HFACS(I, J, K, BI, BJ) .ne. 0.0D00) THEN
                  KSURFS(I, J, BI, BJ) = K
                ENDIF
              END DO
            END DO
          END DO
        END DO
      END DO
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              IF(DXG(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DXG(I, J, BI, BJ) = 1D00 / (DXG(I, J, BI, BJ))
              ENDIF
              IF(DYG(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DYG(I, J, BI, BJ) = 1D00 / (DYG(I, J, BI, BJ))
              ENDIF
              IF(DXC(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DXC(I, J, BI, BJ) = 1D00 / (DXC(I, J, BI, BJ))
              ENDIF
              IF(DYC(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DYC(I, J, BI, BJ) = 1D00 / (DYC(I, J, BI, BJ))
              ENDIF
              IF(DXF(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DXF(I, J, BI, BJ) = 1D00 / (DXF(I, J, BI, BJ))
              ENDIF
              IF(DYF(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DYF(I, J, BI, BJ) = 1D00 / (DYF(I, J, BI, BJ))
              ENDIF
              IF(DXV(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DXV(I, J, BI, BJ) = 1D00 / (DXV(I, J, BI, BJ))
              ENDIF
              IF(DYU(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_DYU(I, J, BI, BJ) = 1D00 / (DYU(I, J, BI, BJ))
              ENDIF
              IF(RA(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_RA(I, J, BI, BJ) = 1D00 / (RA(I, J, BI, BJ))
              ENDIF
              IF(RAS(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_RAS(I, J, BI, BJ) = 1D00 / (RAS(I, J, BI, BJ))
              ENDIF
              IF(RAW(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_RAW(I, J, BI, BJ) = 1D00 / (RAW(I, J, BI, BJ))
              ENDIF
              IF(RAZ(I, J, BI, BJ) .ne. 0.0D00) THEN
                RECIP_RAZ(I, J, BI, BJ) = 1D00 / (RAZ(I, J, BI, BJ))
              ENDIF
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_mixing(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
              END DO
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_p_ground(SELECTMODE, HFLD, PFLD, MYTHID)
      use w2f__types
      use size_mod
      use grid_mod
      use eeparams_mod
      use params_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) SELECTMODE
      REAL(w2f__8) HFLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) PFLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL analylic_theta
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) DPHVR
      REAL(w2f__8) DPIHVR(1 : 60)
      REAL(w2f__8) DZLOC
      LOGICAL(w2f__i4) FINDPOSURF
      REAL(w2f__8) HREF(1 : 31)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KLEV
      INTEGER(w2f__i4) KS
      CHARACTER(512) MSGBUF
      INTEGER(w2f__i4) NLEVHVR
      PARAMETER ( NLEVHVR = 60)
      REAL(w2f__8) PHILOC
      REAL(w2f__8) PIHVR(1 : 61)
      REAL(w2f__8) PILOC
      REAL(w2f__8) PLEVHVR(1 : 61)
      REAL(w2f__8) PLOWHVR
      REAL(w2f__8) PMIDHVR(1 : 60)
      REAL(w2f__8) PO_SURF
      EXTERNAL print_error
      REAL(w2f__8) PSNORM
      REAL(w2f__8) RATIORM(1 : 15)
      REAL(w2f__8) RATIORP(1 : 15)
      REAL(w2f__8) RECIP_KAPPA
      REAL(w2f__8) RHALF(1 : 31)
      REAL(w2f__8) RMIDKP1
      REAL(w2f__8) THETAHVR(1 : 60)
      REAL(w2f__8) YLATLOC
      REAL(w2f__8) ZLOC
C
C     **** Statements ****
C
      IF((SELECTFINDROSURF .GT. 1) .OR.(SELECTFINDROSURF .LT. 0)) THEN
        WRITE(MSGBUF, '(A,I2,A)') 'INI_P_GROUND: selectFindRoSurf =',
     >  SELECTFINDROSURF, ' <== bad value !'
        CALL print_error(MSGBUF, MYTHID)
        WRITE(*, *) 'INI_P_GROUND'
      ENDIF
      DO K = 1, 15, 1
        RHALF(K * 2 + (-1)) = RF(K)
        RHALF(K * 2) = RC(K)
      END DO
      RHALF(31) = RF(16)
      DO K = 1, 31, 1
        HREF(K) = (PHIREF(K) * RECIP_GRAVITY)
      END DO
      IF((SELECTFINDROSURF .eq. 0) .AND.(SELECTMODE .GT. 0)) THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                KS = 1
                DO K = 1, 30, 1
                  IF(HREF(K) .LE. HFLD(I, J, BI, BJ)) THEN
                    KS = K
                  ENDIF
                END DO
                PO_SURF = RHALF(KS) +(((RHALF(KS + 1) - RHALF(KS)) *(
     > HFLD(I, J, BI, BJ) - HREF(KS))) /(HREF(KS + 1) - HREF(KS)))
                PFLD(I, J, BI, BJ) = PO_SURF
              END DO
            END DO
          END DO
        END DO
      ENDIF
      IF(SELECTFINDROSURF .eq. 1) THEN
        RECIP_KAPPA = 1D00 / ATM_KAPPA
        PLOWHVR = 4.00000000000000022204D-01
        DPHVR = 6.0D+01
        DPHVR = (1.0D00 - PLOWHVR) / DPHVR
        PLEVHVR(1) = (RO_SEALEVEL / ATM_PO)
        PIHVR(1) = (ATM_CP *((PLEVHVR(1) ** ATM_KAPPA)))
        DO K = 1, 60, 1
          PLEVHVR(K + 1) = (PLEVHVR(1) - DPHVR * FLOAT(K))
          PIHVR(K + 1) = (ATM_CP *((PLEVHVR(K + 1) ** ATM_KAPPA)))
          PMIDHVR(K) = ((PLEVHVR(K) + PLEVHVR(K + 1)) * 5.0D-01)
          DPIHVR(K) = (PIHVR(K) - PIHVR(K + 1))
        END DO
        DO K = 1, 15, 1
          RATIORM(K) = 1.0D00
          RATIORP(K) = 1.0D00
          IF(K .GT. 1) THEN
            RATIORM(K) = ((DRC(K) * 5.0D-01) /(RF(K) - RC(K)))
          ENDIF
          IF(K .LT. 15) THEN
            RATIORP(K) = ((DRC(K + 1) * 5.0D-01) /(RC(K) - RF(K + 1)))
          ENDIF
        END DO
      ENDIF
      IF((SELECTMODE * SELECTFINDROSURF) .GT. 0) THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                IF(HFLD(I, J, BI, BJ) .LE. 0.0D00) THEN
                  PFLD(I, J, BI, BJ) = RO_SEALEVEL
                ELSE
                  YLATLOC = YC(I, J, BI, BJ)
                  CALL analylic_theta(YLATLOC, PMIDHVR, THETAHVR, (60),
     >  MYTHID)
                  ZLOC = 0.0D00
                  DO K = 1, 60, 1
                    IF(ZLOC .GE. 0.0D00) THEN
                      DZLOC = RECIP_GRAVITY * DPIHVR(K) * THETAHVR(K)
                      IF(HFLD(I, J, BI, BJ) .LE.(DZLOC + ZLOC)) THEN
                        PILOC = PIHVR(K) -((GRAVITY *(HFLD(I, J, BI, BJ
     > ) - ZLOC)) / THETAHVR(K))
                        PSNORM = (PILOC / ATM_CP) ** RECIP_KAPPA
                        ZLOC = -1.0D00
                      ELSE
                        ZLOC = DZLOC + ZLOC
                      ENDIF
                    ENDIF
                  END DO
                  IF(ZLOC .GE. 0.0D00) THEN
                    WRITE(MSGBUF, '(2A)')
     >  'INI_P_GROUND: FAIL in trying to find Pfld:',
     >  ' selectMode,i,j,bi,bj=', SELECTMODE, I, J, BI, BJ
                    CALL print_error(MSGBUF, MYTHID)
                    WRITE(MSGBUF, '(A,F7.1,2A,F6.4,A,F8.0)')
     >  'INI_P_GROUND: Hfld=', HFLD(I, J, BI, BJ), ' exceeds',
     >  ' Zloc(lowest P=', PLEVHVR(61), ' )=', ZLOC
                    CALL print_error(MSGBUF, MYTHID)
                    WRITE(*, *) 'ABNORMAL END: S/R INI_P_GROUND'
                  ELSE
                    PFLD(I, J, BI, BJ) = (PSNORM * ATM_PO)
                  ENDIF
                ENDIF
              END DO
            END DO
            IF((SELECTMODE .eq. 2) .AND.(INTEGR_GEOPOT .ne. 1)) THEN
              DO J = 1, 40, 1
                DO I = 1, 90, 1
                  PO_SURF = PFLD(I, J, BI, BJ)
                  IF((RC(1) .GT. PO_SURF) .AND.(RC(15) .LT. PO_SURF))
     >  THEN
                    FINDPOSURF = .TRUE.
                    DO K = 1, 15, 1
                      IF(FINDPOSURF .AND.(RC(K) .LE. PO_SURF)) THEN
                        PO_SURF = RC(K) +((PO_SURF - RC(K)) / RATIORM(K
     > ))
                        FINDPOSURF = .FALSE.
                      ENDIF
                      RMIDKP1 = RF(K + 1)
                      IF(K .LT. 15) THEN
                        RMIDKP1 = (RC(K) + RC(K + 1)) * 5.0D-01
                      ENDIF
                      IF(FINDPOSURF .AND.(PO_SURF .GE. RMIDKP1)) THEN
                        PO_SURF = RC(K) +((PO_SURF - RC(K)) / RATIORP(K
     > ))
                        FINDPOSURF = .FALSE.
                      ENDIF
                    END DO
                    IF(FINDPOSURF) THEN
C                     IF ( findPoSurf )                PRINT *,'S/R INI_P_GROUND: Pb with selectMode=2'
                      WRITE(*, *)
     >  'S/R INI_P_GROUND: Pb with selectMode=2'
                    ENDIF
                  ENDIF
                  PFLD(I, J, BI, BJ) = PO_SURF
                END DO
              END DO
            ENDIF
          END DO
        END DO
      ENDIF
      IF(SELECTMODE .LT. 0) THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                KS = KSURFC(I, J, BI, BJ)
                IF(KS .LE. 15) THEN
                  IF(RC(KS) .LE. PFLD(I, J, BI, BJ)) THEN
                    PHILOC = HREF(KS * 2) +(((HREF(KS * 2 + (-1)) -
     >  HREF(KS * 2)) *(PFLD(I, J, BI, BJ) - RC(KS))) /(RHALF(KS * 2 +
     >  (-1)) - RHALF(KS * 2)))
                  ELSE
                    PHILOC = HREF(KS * 2) +(((HREF(KS * 2 + 1) - HREF(
     > KS * 2)) *(PFLD(I, J, BI, BJ) - RC(KS))) /(RHALF(KS * 2 + 1) -
     >  RHALF(KS * 2)))
                  ENDIF
                  HFLD(I, J, BI, BJ) = PHILOC
                ELSE
                  HFLD(I, J, BI, BJ) = 0.0D00
                ENDIF
              END DO
            END DO
            IF(SELECTFINDROSURF .eq. 1) THEN
              DO J = 1, 40, 1
                DO I = 1, 90, 1
                  ZLOC = 0.0D00
                  IF(PFLD(I, J, BI, BJ) .LT. RO_SEALEVEL) THEN
                    PO_SURF = PFLD(I, J, BI, BJ)
                    IF((SELECTMODE .eq.(-2)) .AND.(INTEGR_GEOPOT .ne. 1
     > )) THEN
                      IF((RC(1) .GT. PO_SURF) .AND.(RC(15) .LT. PO_SURF
     > )) THEN
                        FINDPOSURF = .TRUE.
                        DO K = 1, 15, 1
                          IF(FINDPOSURF .AND.(RC(K) .LE. PO_SURF)) THEN
                            PO_SURF = RC(K) + RATIORM(K) *(PO_SURF - RC
     > (K))
                            FINDPOSURF = .FALSE.
                          ENDIF
                          IF(FINDPOSURF .AND.(RF(K + 1) .LE. PO_SURF))
     >  THEN
                            PO_SURF = RC(K) + RATIORP(K) *(PO_SURF - RC
     > (K))
                            FINDPOSURF = .FALSE.
                          ENDIF
                        END DO
                      ENDIF
                    ENDIF
                    PSNORM = PO_SURF / ATM_PO
                    KLEV = INT((PLEVHVR(1) - PSNORM) / DPHVR) + 1
                    YLATLOC = YC(I, J, BI, BJ)
                    CALL analylic_theta(YLATLOC, PMIDHVR, THETAHVR,
     >  KLEV, MYTHID)
                    DO K = 1, (KLEV +(-1)), 1
                      DZLOC = RECIP_GRAVITY * DPIHVR(K) * THETAHVR(K)
                      ZLOC = DZLOC + ZLOC
                    END DO
                    DZLOC = RECIP_GRAVITY * THETAHVR(KLEV) *(PIHVR(KLEV
     > ) - ATM_CP *((PSNORM ** ATM_KAPPA)))
                    ZLOC = DZLOC + ZLOC
                  ENDIF
                  PHI0SURF(I, J, BI, BJ) = (GRAVITY *(ZLOC - HFLD(I, J,
     >  BI, BJ)))
                  HFLD(I, J, BI, BJ) = ZLOC
                END DO
              END DO
            ENDIF
          END DO
        END DO
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE analylic_theta(YLAT, PNLEV, THETALEV, KSIZE, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) YLAT
      INTEGER(w2f__i4) KSIZE
      INTEGER(w2f__i4) MYTHID
      REAL(w2f__8) PNLEV(1 : KSIZE)
      REAL(w2f__8) THETALEV(1 : KSIZE)
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A1TMP
      REAL(w2f__8) CATMP
      SAVE CATMP
      REAL(w2f__8) CBTMP
      SAVE CBTMP
      INTEGER(w2f__i4) K
      REAL(w2f__8) PPH
      REAL(w2f__8) PPL
      REAL(w2f__8) PPM
      REAL(w2f__8) PPN0
      SAVE PPN0
      REAL(w2f__8) PPN1
      SAVE PPN1
      REAL(w2f__8) PPN2
      SAVE PPN2
      REAL(w2f__8) PPN3A
      SAVE PPN3A
      REAL(w2f__8) PPN3B
      SAVE PPN3B
      REAL(w2f__8) PPN4
      SAVE PPN4
      REAL(w2f__8) PPR
      REAL(w2f__8) TTDC
      SAVE TTDC
      REAL(w2f__8) TTP1
      SAVE TTP1
      REAL(w2f__8) TTP2
      SAVE TTP2
      REAL(w2f__8) TTP2Y
      REAL(w2f__8) TTP3
      SAVE TTP3
      REAL(w2f__8) TTP4
      SAVE TTP4
      REAL(w2f__8) TTP4Y
      REAL(w2f__8) TTP5
      SAVE TTP5
      REAL(w2f__8) YATMP
      REAL(w2f__8) YBTMP
      REAL(w2f__8) YCTMP
      REAL(w2f__8) YDTMP
      REAL(w2f__8) YYA
      SAVE YYA
      REAL(w2f__8) YYAD
      SAVE YYAD
      REAL(w2f__8) YYB
      SAVE YYB
      REAL(w2f__8) YYBD
      SAVE YYBD
      REAL(w2f__8) YYC
      SAVE YYC
      REAL(w2f__8) YYCD
      SAVE YYCD
C
C     **** Initializers ****
C
      DATA CATMP / 2.60000000000000008882D00 /
      DATA CBTMP / 1.5D00 /
      DATA PPN0 / 1.00000000000000005551D-01 /
      DATA PPN1 / 1.9000000000000000222D-01 /
      DATA PPN2 / 2.99999999999999988898D-01 /
      DATA PPN3A / 9.00000000000000022204D-01 /
      DATA PPN3B / 6.99999999999999955591D-01 /
      DATA PPN4 / 9.25000000000000044409D-01 /
      DATA TTDC / 3.29999999999999982236D00 /
      DATA TTP1 / 3.5D+02 /
      DATA TTP2 / 3.42D+02 /
      DATA TTP3 / 3.07D+02 /
      DATA TTP4 / 3.01D+02 /
      DATA TTP5 / 2.57D+02 /
      DATA YYA / 4.5D+01 /
      DATA YYAD / 9.00000000000000022204D-01 /
      DATA YYB / 6.5D+01 /
      DATA YYBD / 9.00000000000000022204D-01 /
      DATA YYC / 6.5D+01 /
      DATA YYCD / 1.0D+01 /
C
C     **** Statements ****
C
      YATMP = ABS(YLAT) - YYA
      YATMP = YYA + MIN(YATMP / YYAD, 0.0D00) + MAX(YATMP, 0.0D00)
      YATMP = COS(MAX(YATMP, 0.0D00) * 1.74532925199432954744D-02)
      YBTMP = ABS(YLAT) - YYB
      YBTMP = YYB +(YBTMP / YYBD)
      YBTMP = COS(MAX(MIN(YBTMP, 9.0D+01), 0.0D00) *
     >  1.74532925199432954744D-02)
      YCTMP = ABS(YLAT) - YYC
      YCTMP = MAX(1.0D00 -((YCTMP / YYCD) ** 2), 0.0D00)
      YDTMP = PPN3A + YCTMP *(PPN3B - PPN3A)
      TTP2Y = TTP3 +(YATMP ** CATMP) *(TTP2 - TTP3)
      TTP4Y = TTP5 +(YBTMP ** CBTMP) *(TTP4 - TTP5)
      A1TMP = (PPN2 * PPN1 *(TTP1 - TTP2Y)) /(PPN2 - PPN1)
      DO K = 1, KSIZE, 1
        PPL = MIN(PNLEV(K), PPN1)
        PPM = MIN(PPN2, MAX(PNLEV(K), PPN1))
        PPH = MAX(PNLEV(K), PPN2)
        PPR = (PPN0 + ABS(PPL - PPN0) - PPN1) /(PPN2 - PPN1)
        THETALEV(K) = (A1TMP *(1D00 / PPM - 1D00 / PPN1) +(PPL **(-
     >  ATM_KAPPA)) *((PPN1 ** ATM_KAPPA) * TTP1 *(1.0D00 - PPR) +(PPN2
     >  ** ATM_KAPPA) * PPR * TTP2Y) +(((PPH - PPN2) *(TTP4Y - TTP2Y))
     >  /(PPN4 - PPN2)) +((MAX(PNLEV(K) - YDTMP, 0.0D00) *(TTDC + YCTMP
     > )) /(1.0D00 - YDTMP)))
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_pressure(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) K
      CHARACTER(512) MSGBUF
      EXTERNAL print_message
C
C     **** Statements ****
C
      IMIN = -2
      IMAX = 93
      JMIN = -2
      JMAX = 43
      IF(MYTHID .eq. 1) THEN
        WRITE(MSGBUF, '(a)')
     >  'Start initial hydrostatic pressure computation'
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                TOTPHIHYD(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
        END DO
      END DO
      IF(USEDYNP_INEOS_ZC) THEN
      ELSE
        IF(MYTHID .eq. 1) THEN
          WRITE(MSGBUF, '(A,A)')
     >  'Pressure is predetermined for buoyancyRelation ',
     >  BUOYANCYRELATION(1_w2f__i8 : 11)
          CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
        ENDIF
      ENDIF
      IF(MYTHID .eq. 1) THEN
        WRITE(MSGBUF, '(A)') ' '
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_pnh(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_psurf(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use surface_mod
      use cd_code_vars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_xy_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      EXTERNAL read_fld_xy_rl
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ETAN(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      IF(PSURFINITFILE .NE. ' ') THEN
        CALL barrier(MYTHID)
        CALL read_fld_xy_rl(PSURFINITFILE, ' ', ETAN, (0), MYTHID)
        CALL exch_xy_rl(ETAN, MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ETANM1(I, J, BI, BJ) = ETAN(I, J, BI, BJ)
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_r_star(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_salt(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_xyz_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) LOCALWARNINGS
      CHARACTER(512) MSGBUF
      EXTERNAL plot_field_xyzrl
      EXTERNAL print_error
      EXTERNAL read_fld_xyz_rl
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                SALT(I, J, K, BI, BJ) = SREF(K)
              END DO
            END DO
          END DO
        END DO
      END DO
      CALL barrier(MYTHID)
      IF(HYDROGSALTFILE .NE. ' ') THEN
        CALL read_fld_xyz_rl(HYDROGSALTFILE, ' ', SALT, (0), MYTHID)
        CALL exch_xyz_rl(SALT, MYTHID)
      ENDIF
      LOCALWARNINGS = 0
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IF(MASKC(I, J, K, BI, BJ) .eq. 0.0D00) THEN
                  SALT(I, J, K, BI, BJ) = 0.0D00
                ENDIF
              END DO
            END DO
            IF(SREF(K) .ne. 0.0D00) THEN
              DO J = 1, 40, 1
                DO I = 1, 90, 1
                  IF((SALT(I, J, K, BI, BJ) .eq. 0.0D00) .AND.(MASKC(I,
     >  J, K, BI, BJ) .ne. 0.0D00)) THEN
                    LOCALWARNINGS = LOCALWARNINGS + 1
                  ENDIF
                END DO
              END DO
            ENDIF
          END DO
        END DO
      END DO
      IF(LOCALWARNINGS .ne. 0) THEN
        WRITE(MSGBUF, '(A,A)')
     >  'S/R INI_SALT: salt = 0 identically. If this is i' //
     >  'ntentional',
     >  'you will need to edit ini_salt.F to avoid this s' //
     >  'afety check'
        CALL print_error(MSGBUF, MYTHID)
        WRITE(*, *) 'ABNORMAL END: S/R INI_SALT'
      ENDIF
      CALL plot_field_xyzrl(SALT, 'Initial Salinity', (15), (1), MYTHID
     > )
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_spherical_polar_grid(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL calc_angles
      REAL(w2f__8) DLAT
      REAL(w2f__8) DLON
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IG
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JG
      REAL(w2f__8) LAT
      EXTERNAL rotate_spherical_polar_grid
      REAL(w2f__8) XG0
      REAL(w2f__8) XGLOC(-2 : 94, -2 : 44)
      REAL(w2f__8) YG0
      REAL(w2f__8) YGLOC(-2 : 94, -2 : 44)
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          JG = MYYGLOBALLO + BJ * 40 +(-40)
          IG = MYXGLOBALLO + BI * 90 +(-90)
          XG0 = XGORIGIN
          DO I = 1, (IG +(-1)), 1
            XG0 = DELX(I) + XG0
          END DO
          DO I = 1, 3, 1
            XG0 = XG0 - DELX(MOD(IG - I + 269, 90) + 1)
          END DO
          YG0 = YGORIGIN
          DO J = 1, (JG +(-1)), 1
            YG0 = DELY(J) + YG0
          END DO
          DO J = 1, 3, 1
            YG0 = YG0 - DELY(MOD(JG - J + 119, 40) + 1)
          END DO
          DO J = -2, 44, 1
            XGLOC((-2), J) = XG0
            DO I = -2, 93, 1
              XGLOC(I + 1, J) = (DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) *
     >  90 + 268, 90) + 1) + XGLOC(I, J))
            END DO
          END DO
          DO I = -2, 94, 1
            YGLOC(I, (-2)) = YG0
            DO J = -2, 43, 1
              YGLOC(I, J + 1) = (DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) *
     >  40 + 118, 40) + 1) + YGLOC(I, J))
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XG(I, J, BI, BJ) = XGLOC(I, J)
              YG(I, J, BI, BJ) = YGLOC(I, J)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XC(I, J, BI, BJ) = ((XGLOC(I + 1, J + 1) + XGLOC(I, J + 1
     > ) + XGLOC(I, J) + XGLOC(I + 1, J)) * 2.5D-01)
              YC(I, J, BI, BJ) = ((YGLOC(I + 1, J + 1) + YGLOC(I, J + 1
     > ) + YGLOC(I, J) + YGLOC(I + 1, J)) * 2.5D-01)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LAT = YC(I, J, BI, BJ)
              DLON = DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) * 90 + 268,
     >  90) + 1)
              DLAT = DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) * 40 + 118,
     >  40) + 1)
              DXF(I, J, BI, BJ) = (DLON * RSPHERE * COS(LAT *
     >  1.74532925199432954744D-02) * 1.74532925199432954744D-02)
              DYF(I, J, BI, BJ) = (DLAT * RSPHERE *
     >  1.74532925199432954744D-02)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LAT = (YGLOC(I, J) + YGLOC(I + 1, J)) * 5.0D-01
              DLON = DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) * 90 + 268,
     >  90) + 1)
              DLAT = DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) * 40 + 118,
     >  40) + 1)
              DXG(I, J, BI, BJ) = (DLON * RSPHERE * COS(LAT *
     >  1.74532925199432954744D-02) * 1.74532925199432954744D-02)
              IF(DXG(I, J, BI, BJ) .LT. 1.0D00) THEN
                DXG(I, J, BI, BJ) = 0.0D00
              ENDIF
              DYG(I, J, BI, BJ) = (DLAT * RSPHERE *
     >  1.74532925199432954744D-02)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              DXC(I, J, BI, BJ) = 0.0D00
              DYC(I, J, BI, BJ) = 0.0D00
              DXV(I, J, BI, BJ) = 0.0D00
              DYU(I, J, BI, BJ) = 0.0D00
              RAW(I, J, BI, BJ) = 0.0D00
              RAS(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              DXC(I, J, BI, BJ) = ((DXF(I, J, BI, BJ) + DXF(I + (-1), J
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -2, 93, 1
              DYC(I, J, BI, BJ) = ((DYF(I, J, BI, BJ) + DYF(I, J + (-1)
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -1, 43, 1
            DO I = -1, 93, 1
              DXV(I, J, BI, BJ) = ((DXG(I, J, BI, BJ) + DXG(I + (-1), J
     > , BI, BJ)) * 5.0D-01)
              DYU(I, J, BI, BJ) = ((DYG(I, J, BI, BJ) + DYG(I, J + (-1)
     > , BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LAT = (YGLOC(I, J) + YGLOC(I + 1, J)) * 5.0D-01
              DLON = DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) * 90 + 268,
     >  90) + 1)
              DLAT = DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) * 40 + 118,
     >  40) + 1)
              RA(I, J, BI, BJ) = (ABS(SIN((DLAT + LAT) *
     >  1.74532925199432954744D-02) - SIN(LAT *
     >  1.74532925199432954744D-02)) * DLON * RSPHERE * RSPHERE *
     >  1.74532925199432954744D-02)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -1, 93, 1
              RAW(I, J, BI, BJ) = ((RA(I, J, BI, BJ) + RA(I + (-1), J,
     >  BI, BJ)) * 5.0D-01)
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LAT = YC(I, J, BI, BJ)
              DLON = DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) * 90 + 268,
     >  90) + 1)
              DLAT = (DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) * 40 + 118,
     >  40) + 1) + DELY(MOD(MYYGLOBALLO +(BJ +(-1)) * 40 +(J +(-1)) +
     >  118, 40) + 1)) * 5.0D-01
              RAS(I, J, BI, BJ) = (ABS(SIN(LAT *
     >  1.74532925199432954744D-02) - SIN((LAT - DLAT) *
     >  1.74532925199432954744D-02)) * DLON * RSPHERE * RSPHERE *
     >  1.74532925199432954744D-02)
              IF((ABS(LAT) .GT. 9.0D+01) .OR.(ABS(LAT - DLAT) .GT.
     >  9.0D+01)) THEN
                RAS(I, J, BI, BJ) = 0.0D00
              ENDIF
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LAT = (YGLOC(I, J) + YGLOC(I, J + 1)) * 5.0D-01
              DLON = (DELX(MOD(I + MYXGLOBALLO +(BI +(-1)) * 90 + 268,
     >  90) + 1) + DELX(MOD(MYXGLOBALLO +(BI +(-1)) * 90 +(I +(-1)) +
     >  268, 90) + 1)) * 5.0D-01
              DLAT = (DELY(MOD(J + MYYGLOBALLO +(BJ +(-1)) * 40 + 118,
     >  40) + 1) + DELY(MOD(MYYGLOBALLO +(BJ +(-1)) * 40 +(J +(-1)) +
     >  118, 40) + 1)) * 5.0D-01
              RAZ(I, J, BI, BJ) = (ABS(SIN(LAT *
     >  1.74532925199432954744D-02) - SIN((LAT - DLAT) *
     >  1.74532925199432954744D-02)) * DLON * RSPHERE * RSPHERE *
     >  1.74532925199432954744D-02)
              IF((ABS(LAT) .GT. 9.0D+01) .OR.(ABS(LAT - DLAT) .GT.
     >  9.0D+01)) THEN
                RAZ(I, J, BI, BJ) = 0.0D00
              ENDIF
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LAT = (YGLOC(I, J) + YGLOC(I, J + 1)) * 5.0D-01
              TANPHIATU(I, J, BI, BJ) = TAN(LAT *
     >  1.74532925199432954744D-02)
              LAT = (YGLOC(I, J) + YGLOC(I + 1, J)) * 5.0D-01
              TANPHIATV(I, J, BI, BJ) = TAN(LAT *
     >  1.74532925199432954744D-02)
              ANGLECOSC(I, J, BI, BJ) = 1.0D00
              ANGLESINC(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          DO J = -2, 43, 1
            JG = J + MYYGLOBALLO + BJ * 40 +(-41)
            JG = MIN(MAX(JG, 1), 40)
            IF(COSPOWER .ne. 0.0D00) THEN
              COSFACU(J, BI, BJ) = (COS(YC(1, J, BI, BJ) *
     >  1.74532925199432954744D-02) ** COSPOWER)
              COSFACV(J, BI, BJ) = (COS((YC(1, J, BI, BJ) - DELY(JG) *
     >  5.0D-01) * 1.74532925199432954744D-02) ** COSPOWER)
              COSFACU(J, BI, BJ) = ABS(COSFACU(J, BI, BJ))
              COSFACV(J, BI, BJ) = ABS(COSFACV(J, BI, BJ))
              SQCOSFACU(J, BI, BJ) = SQRT(COSFACU(J, BI, BJ))
              SQCOSFACV(J, BI, BJ) = SQRT(COSFACV(J, BI, BJ))
            ELSE
              COSFACU(J, BI, BJ) = 1.0D00
              COSFACV(J, BI, BJ) = 1.0D00
              SQCOSFACU(J, BI, BJ) = 1.0D00
              SQCOSFACV(J, BI, BJ) = 1.0D00
            ENDIF
          END DO
        END DO
      END DO
      IF(ROTATEGRID) THEN
        CALL rotate_spherical_polar_grid(XC, YC, MYTHID)
        CALL rotate_spherical_polar_grid(XG, YG, MYTHID)
        CALL calc_angles(MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_surf_dr(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_theta(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_xyz_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) LOCALWARNINGS
      CHARACTER(512) MSGBUF
      EXTERNAL plot_field_xyzrl
      EXTERNAL print_error
      EXTERNAL read_fld_xyz_rl
      REAL(w2f__8) TFREEZING
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                THETA(I, J, K, BI, BJ) = TREF(K)
              END DO
            END DO
          END DO
        END DO
      END DO
      CALL barrier(MYTHID)
      IF(HYDROGTHETAFILE .NE. ' ') THEN
        CALL read_fld_xyz_rl(HYDROGTHETAFILE, ' ', THETA, (0), MYTHID)
        CALL exch_xyz_rl(THETA, MYTHID)
      ENDIF
      LOCALWARNINGS = 0
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                IF(MASKC(I, J, K, BI, BJ) .eq. 0.0D00) THEN
                  THETA(I, J, K, BI, BJ) = 0.0D00
                ENDIF
              END DO
            END DO
            IF(TREF(K) .ne. 0.0D00) THEN
              DO J = 1, 40, 1
                DO I = 1, 90, 1
                  IF((THETA(I, J, K, BI, BJ) .eq. 0.0D00) .AND.(MASKC(I
     > , J, K, BI, BJ) .ne. 0.0D00)) THEN
                    LOCALWARNINGS = LOCALWARNINGS + 1
                  ENDIF
                END DO
              END DO
            ENDIF
          END DO
        END DO
      END DO
      IF(LOCALWARNINGS .ne. 0) THEN
        WRITE(MSGBUF, '(A,A)')
     >  'S/R INI_THETA: theta = 0 identically. If this is' //
     >  ' intentional',
     >  'you will need to edit ini_theta.F to avoid this ' //
     >  'safety check'
        CALL print_error(MSGBUF, MYTHID)
        WRITE(*, *) 'ABNORMAL END: S/R INI_THETA'
      ENDIF
      TFREEZING = -1.89999999999999991118D00
      IF(ALLOWFREEZING) THEN
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            DO K = 1, 15, 1
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  IF(THETA(I, J, K, BI, BJ) .LT. TFREEZING) THEN
                    THETA(I, J, K, BI, BJ) = TFREEZING
                  ENDIF
                END DO
              END DO
            END DO
          END DO
        END DO
      ENDIF
      CALL plot_field_xyzrl(THETA, 'Initial Temperature', (15), (1),
     >  MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_dynvars(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                UVEL(I, J, K, BI, BJ) = 0.0D00
                VVEL(I, J, K, BI, BJ) = 0.0D00
                WVEL(I, J, K, BI, BJ) = 0.0D00
                THETA(I, J, K, BI, BJ) = 0.0D00
                SALT(I, J, K, BI, BJ) = 0.0D00
                GU(I, J, K, BI, BJ) = 0.0D00
                GV(I, J, K, BI, BJ) = 0.0D00
                GT(I, J, K, BI, BJ) = 0.0D00
                GS(I, J, K, BI, BJ) = 0.0D00
                GUNM1(I, J, K, BI, BJ) = 0.0D00
                GVNM1(I, J, K, BI, BJ) = 0.0D00
                GTNM1(I, J, K, BI, BJ) = 0.0D00
                GSNM1(I, J, K, BI, BJ) = 0.0D00
                TOTPHIHYD(I, J, K, BI, BJ) = 0.0D00
                RHOINSITU(I, J, K, BI, BJ) = 0.0D00
                IVDCONVCOUNT(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ETAN(I, J, BI, BJ) = 0.0D00
              ETAH(I, J, BI, BJ) = 0.0D00
              PHIHYDLOW(I, J, BI, BJ) = 0.0D00
              HMIXLAYER(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_vel(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL exch_uv_xyz_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      EXTERNAL read_fld_xyz_rl
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                UVEL(I, J, K, BI, BJ) = 0.0D00
                VVEL(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
        END DO
      END DO
      IF((UVELINITFILE .NE. ' ') .OR.(VVELINITFILE .NE. ' ')) THEN
        CALL barrier(MYTHID)
        IF(UVELINITFILE .NE. ' ') THEN
          CALL read_fld_xyz_rl(UVELINITFILE, ' ', UVEL, (0), MYTHID)
        ENDIF
        IF(VVELINITFILE .NE. ' ') THEN
          CALL read_fld_xyz_rl(VVELINITFILE, ' ', VVEL, (0), MYTHID)
        ENDIF
        CALL exch_uv_xyz_rl(UVEL, VVEL, (.TRUE.), MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                UVEL(I, J, K, BI, BJ) = (UVEL(I, J, K, BI, BJ) * MASKW(
     > I, J, K, BI, BJ))
                VVEL(I, J, K, BI, BJ) = (VVEL(I, J, K, BI, BJ) * MASKS(
     > I, J, K, BI, BJ))
              END DO
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE ini_vertical_grid(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      REAL(w2f__8) CHECKRATIO1
      REAL(w2f__8) CHECKRATIO2
      INTEGER(w2f__i4) K
      CHARACTER(512) MSGBUF
      EXTERNAL print_error
      EXTERNAL print_message
      REAL(w2f__8) TMPRATIO
C
C     **** Statements ****
C
      IF(MYTHID .eq. 1) THEN
        WRITE(MSGBUF, '(A,2(A,L5))') 'Enter INI_VERTICAL_GRID:',
     >  ' setInterFDr=', SETINTERFDR, ' ; setCenterDr=', SETCENTERDR
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
        RKSIGN = -1.0D00
        GRAVITYSIGN = -1.0D00
        IF(USINGPCOORDS) THEN
          GRAVITYSIGN = 1.0D00
        ENDIF
        IF(.NOT.(SETCENTERDR .OR. SETINTERFDR)) THEN
          WRITE(MSGBUF, '(A)')
     >  'S/R INI_VERTICAL_GRID: neither delR nor delRc ar' //
     >  'e defined'
          CALL print_error(MSGBUF, MYTHID)
          WRITE(MSGBUF, '(A)')
     >  'S/R INI_VERTICAL_GRID: Need at least 1 of the 2 ' //
     >  '(delR,delRc)'
          CALL print_error(MSGBUF, MYTHID)
          WRITE(*, *) 'ABNORMAL END: S/R INI_VERTICAL_GRID'
        ENDIF
        IF(SETINTERFDR) THEN
          DO K = 1, 15, 1
            DRF(K) = DELR(K)
          END DO
          DO K = 1, 15, 1
            IF(DELR(K) .LE. 0.0D00) THEN
              WRITE(MSGBUF, '(A,I4,A,E16.8)')
     >  'S/R INI_VERTICAL_GRID: delR(k=', K, ' )=', DELR(K)
              CALL print_error(MSGBUF, MYTHID)
              WRITE(MSGBUF, '(A)')
     >  'S/R INI_VERTICAL_GRID: Vert. grid spacing MUST B' // 'E > 0'
              CALL print_error(MSGBUF, MYTHID)
              WRITE(*, *) 'ABNORMAL END: S/R INI_VERTICAL_GRID'
            ENDIF
          END DO
        ELSE
          DRF(1) = DELRC(1)
          DO K = 2, 15, 1
            DRF(K + (-1)) = (DRF(K + (-1)) + DELRC(K) * 5.0D-01)
            DRF(K) = (DELRC(K) * 5.0D-01)
          END DO
          DRF(15) = (DELRC(16) + DRF(15))
        ENDIF
        IF(SETCENTERDR) THEN
          DO K = 1, 15, 1
            DRC(K) = DELRC(K)
          END DO
          DO K = 1, 16, 1
            IF(DELRC(K) .LE. 0.0D00) THEN
              WRITE(MSGBUF, '(A,I4,A,E16.8)')
     >  'S/R INI_VERTICAL_GRID: delRc(k=', K, ' )=', DELRC(K)
              CALL print_error(MSGBUF, MYTHID)
              WRITE(MSGBUF, '(A)')
     >  'S/R INI_VERTICAL_GRID: Vert. grid spacing MUST B' // 'E > 0'
              CALL print_error(MSGBUF, MYTHID)
              WRITE(*, *) 'ABNORMAL END: S/R INI_VERTICAL_GRID'
            ENDIF
          END DO
        ELSE
          DRC(1) = (DELR(1) * 5.0D-01)
          DO K = 2, 15, 1
            DRC(K) = ((DELR(K) + DELR(K + (-1))) * 5.0D-01)
          END DO
        ENDIF
        RF(1) = RO_SEALEVEL
        DO K = 1, 15, 1
          RF(K + 1) = (RF(K) + DRF(K) * RKSIGN)
        END DO
        RC(1) = (RF(1) + DRC(1) * RKSIGN)
        DO K = 2, 15, 1
          RC(K) = (RC(K + (-1)) + DRC(K) * RKSIGN)
        END DO
        CHECKRATIO2 = 1.0D+02
        CHECKRATIO1 = 1D00 / CHECKRATIO2
        DO K = 1, 15, 1
          TMPRATIO = 0.0D00
          IF((RC(K) - RF(K + 1)) .ne. 0.0D00) THEN
            TMPRATIO = (RF(K) - RC(K)) /(RC(K) - RF(K + 1))
          ENDIF
          IF((CHECKRATIO1 .GT. TMPRATIO) .OR.(CHECKRATIO2 .LT. TMPRATIO
     > )) THEN
            WRITE(MSGBUF, '(A,I4,A,E16.8)')
     >  'S/R INI_VERTICAL_GRID: Invalid relative position' //
     >  ', level k=', K, ' :', TMPRATIO
            CALL print_error(MSGBUF, MYTHID)
            WRITE(MSGBUF, '(A,1PE14.6,A,2E14.6)')
     >  'S/R INI_VERTICAL_GRID: rC=', RC(K), ' , rF(k,k+1)=', RF(K), RF
     > (K + 1)
            CALL print_error(MSGBUF, MYTHID)
            WRITE(*, *) 'ABNORMAL END: S/R INI_VERTICAL_GRID'
          ENDIF
        END DO
        DO K = 1, 15, 1
          RECIP_DRC(K) = 1D00 / (DRC(K))
          RECIP_DRF(K) = 1D00 / (DRF(K))
        END DO
      ENDIF
      CALL barrier(MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE initialise_varia(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      EXTERNAL bar_check
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL convective_adjustment_ini
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL do_the_model_io
      EXTERNAL exch_xyz_rl
      EXTERNAL ini_autodiff
      EXTERNAL ini_cg2d
      EXTERNAL ini_cori
      EXTERNAL ini_depths
      EXTERNAL ini_dynvars
      EXTERNAL ini_fields
      EXTERNAL ini_forcing
      EXTERNAL ini_hfac
      EXTERNAL ini_linear_phisurf
      EXTERNAL ini_masks_etc
      EXTERNAL ini_mixing
      EXTERNAL integr_continuity
      EXTERNAL packages_init_variables
      EXTERNAL state_summary
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('INITIALISE_VARIA', MYTHID)
      ENDIF
      NITER0 = NINT((STARTTIME - BASETIME) / DELTATCLOCK)
      CALL ini_hfac(MYTHID)
      CALL ini_depths(MYTHID)
      CALL ini_masks_etc(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('INI_LINEAR_PHISURF', MYTHID)
      ENDIF
      CALL ini_linear_phisurf(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('INI_CORI', MYTHID)
      ENDIF
      CALL ini_cori(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('INI_CG2D', MYTHID)
      ENDIF
      CALL ini_cg2d(MYTHID)
      CALL barrier(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('INI_MIXING', MYTHID)
      ENDIF
      CALL ini_mixing(MYTHID)
      CALL barrier(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('INI_DYNVARS', MYTHID)
      ENDIF
      CALL ini_dynvars(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('INI_FIELDS', MYTHID)
      ENDIF
      CALL ini_fields(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('INI_FORCING', MYTHID)
      ENDIF
      CALL ini_forcing(MYTHID)
      CALL barrier(MYTHID)
      CALL ini_autodiff(MYTHID)
      CALL barrier(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('PACKAGES_INIT_VARIABLES', MYTHID)
      ENDIF
      CALL packages_init_variables(MYTHID)
      IF((BASETIME .eq. STARTTIME) .AND.(CADJFREQ .ne. 0.0D00)) THEN
        IF(DEBUGMODE) THEN
          CALL debug_call('CONVECTIVE_ADJUSTMENT_INI', MYTHID)
        ENDIF
        DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
          DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
            CALL convective_adjustment_ini((BI), (BJ), STARTTIME,
     >  NITER0, MYTHID)
          END DO
        END DO
      ENDIF
      IF(DEBUGMODE) THEN
        CALL debug_call('INTEGR_CONTINUITY', MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          CALL integr_continuity((BI), (BJ), UVEL, VVEL, STARTTIME,
     >  NITER0, MYTHID)
        END DO
      END DO
      CALL exch_xyz_rl(WVEL, MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('STATE_SUMMARY', MYTHID)
      ENDIF
      CALL state_summary(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('DO_THE_MODEL_IO', MYTHID)
      ENDIF
      CALL do_the_model_io(STARTTIME, NITER0, MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_leave('INITIALISE_VARIA', MYTHID)
      ENDIF
      CALL bar_check((4), MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE integrate_for_w(BI, BJ, K, UFLD, VFLD, MFLD, WFLD,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) K
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) CONV2D(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      DO J = 1, 41, 1
        DO I = 1, 91, 1
          UTRANS(I, J) = (HFACW(I, J, K, BI, BJ) * DRF(K) * RHOFACC(K)
     >  * DEEPFACC(K) * DYG(I, J, BI, BJ) * UFLD(I, J, K, BI, BJ))
          VTRANS(I, J) = (HFACS(I, J, K, BI, BJ) * DRF(K) * RHOFACC(K)
     >  * DEEPFACC(K) * DXG(I, J, BI, BJ) * VFLD(I, J, K, BI, BJ))
        END DO
      END DO
      DO J = 1, 40, 1
        DO I = 1, 90, 1
          CONV2D(I, J) = (-(VTRANS(I, J + 1) + UTRANS(I + 1, J) -
     >  UTRANS(I, J) - VTRANS(I, J)))
        END DO
      END DO
      IF(RIGIDLID) THEN
        IF(K .eq. 1) THEN
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              WFLD(I, J, K, BI, BJ) = 0.0D00
            END DO
          END DO
        ELSE
          IF(K .eq. 15) THEN
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                WFLD(I, J, K, BI, BJ) = (RECIP_RHOFACF(K) *
     >  RECIP_DEEPFAC2F(K) * MASKC(I, J, K + (-1), BI, BJ) * MASKC(I, J
     > , K, BI, BJ) * CONV2D(I, J) * RECIP_RA(I, J, BI, BJ))
              END DO
            END DO
          ELSE
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                WFLD(I, J, K, BI, BJ) = (RECIP_RHOFACF(K) *
     >  RECIP_DEEPFAC2F(K) * MASKC(I, J, K + (-1), BI, BJ) * MASKC(I, J
     > , K, BI, BJ) *(RHOFACF(K + 1) * DEEPFAC2F(K + 1) * WFLD(I, J, K
     >  + 1, BI, BJ) + CONV2D(I, J) * RECIP_RA(I, J, BI, BJ)))
              END DO
            END DO
          ENDIF
        ENDIF
      ELSE
        IF(K .eq. 15) THEN
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              WFLD(I, J, K, BI, BJ) = (RECIP_RHOFACF(K) *
     >  RECIP_DEEPFAC2F(K) * MASKC(I, J, K, BI, BJ) * CONV2D(I, J) *
     >  RECIP_RA(I, J, BI, BJ))
            END DO
          END DO
        ELSE
          DO J = 1, 40, 1
            DO I = 1, 90, 1
              WFLD(I, J, K, BI, BJ) = (RECIP_RHOFACF(K) *
     >  RECIP_DEEPFAC2F(K) * MASKC(I, J, K, BI, BJ) *(RHOFACF(K + 1) *
     >  DEEPFAC2F(K + 1) * WFLD(I, J, K + 1, BI, BJ) + CONV2D(I, J) *
     >  RECIP_RA(I, J, BI, BJ)))
            END DO
          END DO
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE integr_continuity(BI, BJ, UFLD, VFLD, MYTIME, MYITER,
     >  MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use surface_mod
      use ffields_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) ADDMASS(1 : 1)
      EXTERNAL integrate_for_w
      INTEGER(w2f__i4) K
C
C     **** Statements ****
C
      DO K = 15, 1, (-1)
        CALL integrate_for_w(BI, BJ, (K), UFLD, VFLD, ADDMASS, WVEL,
     >  MYTHID)
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE load_fields_driver(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use tamc_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      use ffields_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL external_fields_load
      EXTERNAL timer_start
      EXTERNAL timer_stop
C
C     **** Statements ****
C
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_enter('LOAD_FIELDS_DRIVER', MYTHID)
      ENDIF
      IF(.NOT.(USEEBM .OR. USEEXF)) THEN
        IF(DEBUGLEVEL .GE. 2) THEN
          CALL debug_call('EXTERNAL_FIELDS_LOAD', MYTHID)
        ENDIF
        CALL timer_start('EXTERNAL_FLDS_LOAD [LOAD_FLDS_DRIVER]',
     >  MYTHID)
        CALL external_fields_load(MYTIME, MYITER, MYTHID)
        CALL timer_stop('EXTERNAL_FLDS_LOAD [LOAD_FLDS_DRIVER]', MYTHID
     > )
      ENDIF
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_leave('LOAD_FIELDS_DRIVER', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE load_grid_spacing(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) ILEN
      EXTERNAL ilnblnk
      INTEGER(w2f__i4) ilnblnk
      INTEGER(w2f__i4) IUNIT
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      EXTERNAL mdsfindunit
      CHARACTER(512) MSGBUF
      EXTERNAL print_message
      INTEGER(w2f__i4) RCLEN1
      REAL(w2f__4) TMP4DELR(1 : 15)
      REAL(w2f__4) TMP4DELRC(1 : 16)
      REAL(w2f__4) TMP4DELX(1 : 90)
      REAL(w2f__4) TMP4DELY(1 : 40)
      REAL(w2f__8) TMP8DELR(1 : 15)
      REAL(w2f__8) TMP8DELRC(1 : 16)
      REAL(w2f__8) TMP8DELX(1 : 90)
      REAL(w2f__8) TMP8DELY(1 : 40)
      CHARACTER(4) t__1932
      CHARACTER(4) t__1933
      CHARACTER(4) t__1934
      CHARACTER(4) t__1935
      CHARACTER(4) t__1936
      CHARACTER(4) t__1937
      CHARACTER(4) t__1938
      CHARACTER(4) t__1939
C
C     **** Statements ****
C
      IF(MYTHID .eq. 1) THEN
        RCLEN1 = 4
        IF(READBINARYPREC .eq. 64) THEN
          RCLEN1 = 8
        ENDIF
        IF(DELXFILE .NE. ' ') THEN
          CALL mdsfindunit(IUNIT, MYTHID)
          ILEN = ilnblnk(DELXFILE)
          IF(READBINARYPREC .eq. 32) THEN
C           OPEN(iUnit, FILE=delXFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*Nx)
            t__1932 = 'OLD '
            OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 90), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1932(1_w2f__i8 :
     >  3), FILE = DELXFILE(1_w2f__i8 : ILEN))
            READ(IUNIT, REC = 1) TMP4DELX
C           CLOSE(iUnit)
            CLOSE(UNIT = IUNIT)
            DO I = 1, 90, 1
              DELX(I) = TMP4DELX(I)
            END DO
          ELSE
            IF(READBINARYPREC .eq. 64) THEN
C             OPEN(iUnit, FILE=delXFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*Nx)
              t__1933 = 'OLD '
              OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 90), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1933(1_w2f__i8 :
     >  3), FILE = DELXFILE(1_w2f__i8 : ILEN))
              READ(IUNIT, REC = 1) TMP8DELX
C             CLOSE(iUnit)
              CLOSE(UNIT = IUNIT)
              DO I = 1, 90, 1
                DELX(I) = TMP8DELX(I)
              END DO
            ENDIF
          ENDIF
          WRITE(MSGBUF, '(3A)') 'S/R LOAD_GRID_SPACING:',
     >  ' delX loaded from file: ', DELXFILE(1_w2f__i8 : ILEN)
          CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
        ENDIF
        IF(DELYFILE .NE. ' ') THEN
          CALL mdsfindunit(IUNIT, MYTHID)
          ILEN = ilnblnk(DELYFILE)
          IF(READBINARYPREC .eq. 32) THEN
C           OPEN(iUnit, FILE=delYFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*Ny)
            t__1934 = 'OLD '
            OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 40), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1934(1_w2f__i8 :
     >  3), FILE = DELYFILE(1_w2f__i8 : ILEN))
            READ(IUNIT, REC = 1) TMP4DELY
C           CLOSE(iUnit)
            CLOSE(UNIT = IUNIT)
            DO J = 1, 40, 1
              DELY(J) = TMP4DELY(J)
            END DO
          ELSE
            IF(READBINARYPREC .eq. 64) THEN
C             OPEN(iUnit, FILE=delYFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*Ny)
              t__1935 = 'OLD '
              OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 40), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1935(1_w2f__i8 :
     >  3), FILE = DELYFILE(1_w2f__i8 : ILEN))
              READ(IUNIT, REC = 1) TMP8DELY
C             CLOSE(iUnit)
              CLOSE(UNIT = IUNIT)
              DO J = 1, 40, 1
                DELY(J) = TMP8DELY(J)
              END DO
            ENDIF
          ENDIF
          WRITE(MSGBUF, '(3A)') 'S/R LOAD_GRID_SPACING:',
     >  ' delY loaded from file: ', DELYFILE(1_w2f__i8 : ILEN)
          CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
        ENDIF
        IF(DELRFILE .NE. ' ') THEN
          CALL mdsfindunit(IUNIT, MYTHID)
          ILEN = ilnblnk(DELRFILE)
          IF(READBINARYPREC .eq. 32) THEN
C           OPEN(iUnit, FILE=delRFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*Nr)
            t__1936 = 'OLD '
            OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 15), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1936(1_w2f__i8 :
     >  3), FILE = DELRFILE(1_w2f__i8 : ILEN))
            READ(IUNIT, REC = 1) TMP4DELR
C           CLOSE(iUnit)
            CLOSE(UNIT = IUNIT)
            DO K = 1, 15, 1
              DELR(K) = TMP4DELR(K)
            END DO
          ELSE
            IF(READBINARYPREC .eq. 64) THEN
C             OPEN(iUnit, FILE=delRFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*Nr)
              t__1937 = 'OLD '
              OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 15), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1937(1_w2f__i8 :
     >  3), FILE = DELRFILE(1_w2f__i8 : ILEN))
              READ(IUNIT, REC = 1) TMP8DELR
C             CLOSE(iUnit)
              CLOSE(UNIT = IUNIT)
              DO K = 1, 15, 1
                DELR(K) = TMP8DELR(K)
              END DO
            ENDIF
          ENDIF
          WRITE(MSGBUF, '(3A)') 'S/R LOAD_GRID_SPACING:',
     >  ' delR loaded from file: ', DELRFILE(1_w2f__i8 : ILEN)
          CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
        ENDIF
        IF(DELRCFILE .NE. ' ') THEN
          CALL mdsfindunit(IUNIT, MYTHID)
          ILEN = ilnblnk(DELRCFILE)
          IF(READBINARYPREC .eq. 32) THEN
C           OPEN(iUnit, FILE=delRcFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*(Nr+1))
            t__1938 = 'OLD '
            OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 16), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1938(1_w2f__i8 :
     >  3), FILE = DELRCFILE(1_w2f__i8 : ILEN))
            READ(IUNIT, REC = 1) TMP4DELRC
C           CLOSE(iUnit)
            CLOSE(UNIT = IUNIT)
            DO K = 1, 16, 1
              DELRC(K) = TMP4DELRC(K)
            END DO
          ELSE
            IF(READBINARYPREC .eq. 64) THEN
C             OPEN(iUnit, FILE=delRcFile(1:iLen), STATUS='OLD',        FORM='UNFORMATTED',ACCESS='DIRECT',RECL=rcLen1*(Nr+1))
              t__1939 = 'OLD '
              OPEN(UNIT = IUNIT, RECL = (RCLEN1 * 16), FORM =
     >  'UNFORMATTED', ACCESS = 'DIRECT', STATUS = t__1939(1_w2f__i8 :
     >  3), FILE = DELRCFILE(1_w2f__i8 : ILEN))
              READ(IUNIT, REC = 1) TMP8DELRC
C             CLOSE(iUnit)
              CLOSE(UNIT = IUNIT)
              DO K = 1, 16, 1
                DELRC(K) = TMP8DELRC(K)
              END DO
            ENDIF
          ENDIF
          WRITE(MSGBUF, '(3A)') 'S/R LOAD_GRID_SPACING:',
     >  ' delRc loaded from file: ', DELRCFILE(1_w2f__i8 : ILEN)
          CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', MYTHID)
        ENDIF
      ENDIF
      CALL barrier(MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE momentum_correction_step(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL calc_grad_phi_surf
      EXTERNAL correction_step
      EXTERNAL exch_xyz_rl
      EXTERNAL exch_xy_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      EXTERNAL integr_continuity
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) K
      REAL(w2f__8) PHISURFX(-2 : 93, -2 : 43)
      REAL(w2f__8) PHISURFY(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              PHISURFX(I, J) = 0.0D00
              PHISURFY(I, J) = 0.0D00
            END DO
          END DO
          IMIN = -1
          IMAX = 93
          JMIN = -1
          JMAX = 43
          CALL calc_grad_phi_surf((BI), (BJ), IMIN, IMAX, JMIN, JMAX,
     >  ETAN, PHISURFX, PHISURFY, MYTHID)
          DO K = 1, 15, 1
            IF(MOMSTEPPING) THEN
              CALL correction_step((BI), (BJ), IMIN, IMAX, JMIN, JMAX,
     >  (K), PHISURFX, PHISURFY, MYTIME, MYTHID)
            ENDIF
          END DO
        END DO
      END DO
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          ACT1 = BI - MYBXLO(MYTHID)
          MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
          ACT2 = BJ - MYBYLO(MYTHID)
          MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
          ACT3 = MYTHID +(-1)
          MAX3 = NTX * NTY
          ACT4 = IKEY_DYNAMICS +(-1)
          IDYNKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 *
     >  MAX2 * ACT4 * MAX1 + 1
          CALL integr_continuity((BI), (BJ), UVEL, VVEL, MYTIME, MYITER
     > , MYTHID)
        END DO
      END DO
      IF(EXACTCONSERV .AND.(IMPLICDIV2DFLOW .ne. 0.0D00)) THEN
        CALL exch_xy_rl(ETAN, MYTHID)
      ENDIF
      IF(IMPLICITINTGRAVWAVE) THEN
        CALL exch_xyz_rl(WVEL, MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE packages_init_variables(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      EXTERNAL cd_code_ini_vars
      EXTERNAL cost_init_varia
      EXTERNAL ctrl_init_variables
      EXTERNAL ctrl_map_ini
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL gad_init_varia
      EXTERNAL gmredi_init
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('PACKAGES_INIT_VARIABLES', MYTHID)
      ENDIF
      IF(USEGAD) THEN
        IF(DEBUGMODE) THEN
          CALL debug_call('GAD_INIT_VARIA', MYTHID)
        ENDIF
        CALL gad_init_varia(MYTHID)
      ENDIF
      IF(USECDSCHEME) THEN
        IF(DEBUGMODE) THEN
          CALL debug_call('CD_CODE_INI_VARS', MYTHID)
        ENDIF
        CALL cd_code_ini_vars(MYTHID)
      ENDIF
      IF(USEGMREDI) THEN
        IF(DEBUGMODE) THEN
          CALL debug_call('GMREDI_INIT', MYTHID)
        ENDIF
        CALL gmredi_init(MYTHID)
      ENDIF
      IF(DEBUGMODE) THEN
        CALL debug_call('CTRL_INIT_VARIABLES', MYTHID)
      ENDIF
      CALL ctrl_init_variables(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_call('CTRL_MAP_INI', MYTHID)
      ENDIF
      CALL ctrl_map_ini(MYTHID)
      CALL barrier(MYTHID)
      CALL cost_init_varia(MYTHID)
      CALL barrier(MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_leave('PACKAGES_INIT_VARIABLES', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE pressure_for_eos(BI, BJ, IMIN, IMAX, JMIN, JMAX, K,
     >  LOCPRES, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) LOCPRES(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      IF(USINGZCOORDS) THEN
        IF(USEDYNP_INEOS_ZC) THEN
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LOCPRES(I, J) = (RHOCONST *(TOTPHIHYD(I, J, K, BI, BJ) -
     >  RC(K) * GRAVITY))
            END DO
          END DO
        ELSE
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LOCPRES(I, J) = (-(GRAVITY * RC(K) * RHOCONST))
            END DO
          END DO
        ENDIF
      ELSE
        IF(USINGPCOORDS) THEN
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              LOCPRES(I, J) = RC(K)
            END DO
          END DO
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE read_pickup(MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use restart_mod
      use dynvars_mod
      use surface_mod
      use gad_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      EXTERNAL check_pickup
      EXTERNAL exch_3d_rl
      EXTERNAL exch_uv_3d_rl
      EXTERNAL exch_xy_rl
      INTEGER(w2f__i4) FILEPREC
      CHARACTER(512) FN
      INTEGER(w2f__i4) FP
      INTEGER(w2f__i4) IOUNIT
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) MISSFLDDIM
      PARAMETER ( MISSFLDDIM = 20)
      CHARACTER(8) MISSFLDLIST(1 : 20)
      CHARACTER(512) MSGBUF
      INTEGER(w2f__i4) NBFIELDS
      INTEGER(w2f__i4) NJ
      INTEGER(w2f__i4) NMISSING
      EXTERNAL print_error
      EXTERNAL print_message
      EXTERNAL read_mflds_3d_rl
      EXTERNAL read_mflds_check
      EXTERNAL read_mflds_set
      EXTERNAL read_rec_3d_rl
      CHARACTER(10) SUFF
C
C     **** Statements ****
C
      DO J = 1, 512, 1
        FN((J) : ((J) - 1_w2f__i8) + 1) = ' '
      END DO
      IF(PICKUPSUFF .EQ. ' ') THEN
        WRITE(SUFF, '(I10.10)') MYITER
      ELSE
        WRITE(SUFF, '(A10)') PICKUPSUFF
      ENDIF
      WRITE(FN, '(A,A10)') 'pickup.', SUFF
      CALL barrier(MYTHID)
      IF(PICKUP_READ_MDSIO) THEN
        FP = 64
        CALL read_mflds_set(FN, NBFIELDS, FILEPREC, (15), MYITER,
     >  MYTHID)
        IF(MYTHID .eq. 1) THEN
          IF((NBFIELDS .GE. 0) .AND.(FILEPREC .ne. FP)) THEN
            WRITE(MSGBUF, '(2A,I4)') 'READ_PICKUP: ',
     >  'pickup-file binary precision do not match !'
            CALL print_error(MSGBUF, MYTHID)
            WRITE(MSGBUF, '(A,2(A,I4))') 'READ_PICKUP: ', 'file prec.='
     > , FILEPREC, ' but expecting prec.=', FP
            CALL print_error(MSGBUF, MYTHID)
            WRITE(*, *) 'ABNORMAL END: S/R READ_PICKUP (data-prec Pb)'
          ENDIF
        ENDIF
        IF(NBFIELDS .LE. 0) THEN
          IOUNIT = ERRORMESSAGEUNIT
          IF(PICKUPSTRICTLYMATCH) THEN
            WRITE(MSGBUF, '(4A)') 'READ_PICKUP: ',
     >  'no field-list found in meta-file',
     >  ' => cannot check for strick-matching'
            CALL print_error(MSGBUF, MYTHID)
            WRITE(MSGBUF, '(4A)') 'READ_PICKUP: ',
     >  'try with " pickupStrictlyMatch=.FALSE.,"',
     >  ' in file: "data", NameList: "PARM03"'
            CALL print_message(MSGBUF, IOUNIT, 'R', MYTHID)
            WRITE(*, *) 'ABNORMAL END: S/R READ_PICKUP'
          ELSE
            WRITE(MSGBUF, '(4A)') 'WARNING >> READ_PICKUP: ',
     >  ' no field-list found'
            CALL print_message(MSGBUF, IOUNIT, 'R', MYTHID)
            IF(NBFIELDS .eq.(-1)) THEN
              WRITE(MSGBUF, '(4A)') 'WARNING >> ',
     >  ' try to read pickup as currently written'
              CALL print_message(MSGBUF, IOUNIT, 'R', MYTHID)
            ELSE
              WRITE(MSGBUF, '(4A)') 'WARNING >> ',
     >  ' try to read pickup as it used to be written'
              CALL print_message(MSGBUF, IOUNIT, 'R', MYTHID)
              WRITE(MSGBUF, '(4A)') 'WARNING >> ',
     >  ' until checkpoint59i (2007 Oct 22)'
              CALL print_message(MSGBUF, IOUNIT, 'R', MYTHID)
            ENDIF
          ENDIF
        ENDIF
        IF(NBFIELDS .eq. 0) THEN
          IF(USEPICKUPBEFOREC54) THEN
            CALL read_rec_3d_rl(FN, FP, (15), UVEL, (1), MYITER, MYTHID
     > )
            CALL read_rec_3d_rl(FN, FP, (15), GU, (2), MYITER, MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), GUNM1, (3), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), VVEL, (4), MYITER, MYTHID
     > )
            CALL read_rec_3d_rl(FN, FP, (15), GV, (5), MYITER, MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), GVNM1, (6), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), THETA, (7), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), GT, (8), MYITER, MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), GTNM1, (9), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), SALT, (10), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), GS, (11), MYITER, MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), GSNM1, (12), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (1), ETAN, (181), MYITER,
     >  MYTHID)
          ELSE
            CALL read_rec_3d_rl(FN, FP, (15), UVEL, (1), MYITER, MYTHID
     > )
            CALL read_rec_3d_rl(FN, FP, (15), GUNM1, (2), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), VVEL, (3), MYITER, MYTHID
     > )
            CALL read_rec_3d_rl(FN, FP, (15), GVNM1, (4), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), THETA, (5), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), GTNM1, (6), MYITER,
     >  MYTHID)
            CALL read_rec_3d_rl(FN, FP, (15), SALT, (7), MYITER, MYTHID
     > )
            CALL read_rec_3d_rl(FN, FP, (15), GSNM1, (8), MYITER,
     >  MYTHID)
            NJ = 8
            CALL read_rec_3d_rl(FN, FP, (1), ETAN, (NJ * 15 + 1),
     >  MYITER, MYTHID)
          ENDIF
          IF(USEDYNP_INEOS_ZC) THEN
            WRITE(FN, '(A,A10)') 'pickup_ph.', SUFF
            CALL read_rec_3d_rl(FN, FP, (15), TOTPHIHYD, (1), MYITER,
     >  MYTHID)
          ENDIF
        ELSE
          NJ = 0
          CALL read_mflds_3d_rl('Uvel    ', UVEL, NJ, FP, (15), MYITER,
     >  MYTHID)
          CALL read_mflds_3d_rl('Vvel    ', VVEL, NJ, FP, (15), MYITER,
     >  MYTHID)
          CALL read_mflds_3d_rl('Theta   ', THETA, NJ, FP, (15), MYITER
     > , MYTHID)
          CALL read_mflds_3d_rl('Salt    ', SALT, NJ, FP, (15), MYITER,
     >  MYTHID)
          IF(MOMSTEPPING) THEN
            CALL read_mflds_3d_rl('GuNm1   ', GUNM1, NJ, FP, (15),
     >  MYITER, MYTHID)
            CALL read_mflds_3d_rl('GvNm1   ', GVNM1, NJ, FP, (15),
     >  MYITER, MYTHID)
          ENDIF
          IF(ADAMSBASHFORTHGT) THEN
            CALL read_mflds_3d_rl('GtNm1   ', GTNM1, NJ, FP, (15),
     >  MYITER, MYTHID)
          ENDIF
          IF(ADAMSBASHFORTHGS) THEN
            CALL read_mflds_3d_rl('GsNm1   ', GSNM1, NJ, FP, (15),
     >  MYITER, MYTHID)
          ENDIF
          IF(USEDYNP_INEOS_ZC) THEN
            CALL read_mflds_3d_rl('PhiHyd  ', TOTPHIHYD, NJ, FP, (15),
     >  MYITER, MYTHID)
          ENDIF
          NJ = NJ * 15
          CALL read_mflds_3d_rl('EtaN    ', ETAN, NJ, FP, (1), MYITER,
     >  MYTHID)
        ENDIF
        NMISSING = 20
        CALL read_mflds_check(MISSFLDLIST, NMISSING, MYITER, MYTHID)
        IF(NMISSING .GT. 20) THEN
          WRITE(MSGBUF, '(2A,I4)') 'READ_PICKUP: ',
     >  'missing fields list has been truncated to', 20
          CALL print_error(MSGBUF, MYTHID)
          WRITE(*, *) 'ABNORMAL END: S/R READ_PICKUP (list-size Pb)'
        ENDIF
        CALL check_pickup(MISSFLDLIST, NMISSING, NBFIELDS, MYITER,
     >  MYTHID)
      ENDIF
      CALL barrier(MYTHID)
      CALL exch_uv_3d_rl(UVEL, VVEL, (.TRUE.), (15), MYTHID)
      CALL exch_3d_rl(THETA, (15), MYTHID)
      CALL exch_3d_rl(SALT, (15), MYTHID)
      CALL exch_uv_3d_rl(GUNM1, GVNM1, (.TRUE.), (15), MYTHID)
      CALL exch_3d_rl(GTNM1, (15), MYTHID)
      CALL exch_3d_rl(GSNM1, (15), MYTHID)
      CALL exch_xy_rl(ETAN, MYTHID)
      CALL exch_xy_rl(ETAH, MYTHID)
      IF(USEDYNP_INEOS_ZC) THEN
        CALL exch_3d_rl(TOTPHIHYD, (15), MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE find_rho_scalar(TLOC, SLOC, PLOC, RHOLOC, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use eos_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) TLOC
      REAL(w2f__8) SLOC
      REAL(w2f__8) PLOC
      REAL(w2f__8) RHOLOC
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) BMFRESH
      REAL(w2f__8) BMPRES
      REAL(w2f__8) BMSALT
      REAL(w2f__8) BULKMOD
      REAL(w2f__8) DEN
      REAL(w2f__8) EPSLN
      PARAMETER ( EPSLN = 0.0D00)
      CHARACTER(512) MSGBUF
      REAL(w2f__8) P1
      REAL(w2f__8) P1T1
      REAL(w2f__8) P2
      EXTERNAL print_error
      EXTERNAL print_message
      REAL(w2f__8) RFRESH
      REAL(w2f__8) RHODEN
      REAL(w2f__8) RHONUM
      REAL(w2f__8) RHOP0
      REAL(w2f__8) RSALT
      REAL(w2f__8) S1
      REAL(w2f__8) S3O2
      REAL(w2f__8) SP5
      REAL(w2f__8) T1
      REAL(w2f__8) T2
      REAL(w2f__8) T3
      REAL(w2f__8) T4
C
C     **** Statements ****
C
      RHOLOC = 0.0D00
      RHOP0 = 0.0D00
      BULKMOD = 0.0D00
      RFRESH = 0.0D00
      RSALT = 0.0D00
      BMFRESH = 0.0D00
      BMSALT = 0.0D00
      BMPRES = 0.0D00
      RHONUM = 0.0D00
      RHODEN = 0.0D00
      DEN = 0.0D00
      T1 = TLOC
      T2 = T1 * T1
      T3 = T1 * T2
      T4 = T1 * T3
      S1 = SLOC
      IF(S1 .LT. 0.0D00) THEN
        WRITE(MSGBUF, '(A,E13.5)')
     >  ' FIND_RHO_SCALAR:   WARNING, salinity = ', S1
        CALL print_message(MSGBUF, ERRORMESSAGEUNIT, 'R', MYTHID)
        S1 = 0.0D00
      ENDIF
      IF(EQUATIONOFSTATE .EQ. 'LINEAR') THEN
        RHOLOC = RHONIL + RHONIL *(SBETA *(SLOC - SREF(1)) - TALPHA *(
     > TLOC - TREF(1)))
      ELSE
        IF(EQUATIONOFSTATE .EQ. 'POLY3') THEN
          WRITE(MSGBUF, '(A)')
     >  ' FIND_RHO_SCALAR: for POLY3, the density is not'
          CALL print_message(MSGBUF, ERRORMESSAGEUNIT, 'R', MYTHID)
          WRITE(MSGBUF, '(A)')
     >  '                 computed correctly in this rout' // 'ine'
          CALL print_message(MSGBUF, ERRORMESSAGEUNIT, 'R', MYTHID)
          RHOLOC = 0.0D00
        ELSE
          IF((EQUATIONOFSTATE(1_w2f__i8 : 5) .EQ. 'JMD95') .OR.(
     > EQUATIONOFSTATE .EQ. 'UNESCO')) THEN
            S3O2 = S1 * SQRT(S1)
            P1 = PLOC * 1.0000000000000000818D-05
            P2 = P1 * P1
            RFRESH = EOSJMDCFW(1) + EOSJMDCFW(2) * T1 + EOSJMDCFW(3) *
     >  T2 + EOSJMDCFW(4) * T3 + EOSJMDCFW(5) * T4 + T1 * EOSJMDCFW(6)
     >  * T4
            RSALT = S1 *(EOSJMDCSW(1) + EOSJMDCSW(2) * T1 + EOSJMDCSW(3
     > ) * T2 + EOSJMDCSW(4) * T3 + EOSJMDCSW(5) * T4) + S3O2 *(
     > EOSJMDCSW(6) + EOSJMDCSW(7) * T1 + EOSJMDCSW(8) * T2) + S1 *
     >  EOSJMDCSW(9) * S1
            RHOP0 = RFRESH + RSALT
            BMFRESH = EOSJMDCKFW(1) + EOSJMDCKFW(2) * T1 + EOSJMDCKFW(3
     > ) * T2 + EOSJMDCKFW(4) * T3 + EOSJMDCKFW(5) * T4
            BMSALT = S1 *(EOSJMDCKSW(1) + EOSJMDCKSW(2) * T1 +
     >  EOSJMDCKSW(3) * T2 + EOSJMDCKSW(4) * T3) + S3O2 *(EOSJMDCKSW(5)
     >  + EOSJMDCKSW(6) * T1 + EOSJMDCKSW(7) * T2)
            BMPRES = P1 *(EOSJMDCKP(1) + EOSJMDCKP(2) * T1 + EOSJMDCKP(
     > 3) * T2 + EOSJMDCKP(4) * T3) + P1 * S1 *(EOSJMDCKP(5) +
     >  EOSJMDCKP(6) * T1 + EOSJMDCKP(7) * T2) + EOSJMDCKP(8) * P1 *
     >  S3O2 + P2 *(EOSJMDCKP(9) + EOSJMDCKP(10) * T1 + EOSJMDCKP(11) *
     >  T2) + P2 * S1 *(EOSJMDCKP(12) + EOSJMDCKP(13) * T1 + EOSJMDCKP(
     > 14) * T2)
            BULKMOD = BMPRES + BMFRESH + BMSALT
            RHOLOC = RHOP0 /(1.0D00 -(P1 / BULKMOD))
          ELSE
            IF(EQUATIONOFSTATE .EQ. 'MDJWF') THEN
              SP5 = SQRT(S1)
              P1 = PLOC * 1.00000000000000004792D-04
              P1T1 = P1 * T1
              RHONUM = EOSMDJWFNUM(0) + T1 *(EOSMDJWFNUM(1) + T1 *(
     > EOSMDJWFNUM(2) + EOSMDJWFNUM(3) * T1)) + S1 *(EOSMDJWFNUM(4) +
     >  EOSMDJWFNUM(5) * T1 + EOSMDJWFNUM(6) * S1) + P1 *(EOSMDJWFNUM(7
     > ) + EOSMDJWFNUM(8) * T2 + EOSMDJWFNUM(9) * S1 + P1 *(EOSMDJWFNUM
     > (10) + EOSMDJWFNUM(11) * T2))
              DEN = EOSMDJWFDEN(0) + T1 *(EOSMDJWFDEN(1) + T1 *(
     > EOSMDJWFDEN(2) + T1 *(EOSMDJWFDEN(3) + EOSMDJWFDEN(4) * T1))) +
     >  S1 *(EOSMDJWFDEN(5) + T1 *(EOSMDJWFDEN(6) + EOSMDJWFDEN(7) * T2
     > ) + SP5 *(EOSMDJWFDEN(8) + EOSMDJWFDEN(9) * T2)) + P1 *(
     > EOSMDJWFDEN(10) + P1T1 *(EOSMDJWFDEN(11) * T2 + EOSMDJWFDEN(12)
     >  * P1))
              RHODEN = 1D00 / (DEN)
              RHOLOC = RHODEN * RHONUM
            ELSE
              IF(EQUATIONOFSTATE .EQ. 'IDEALG') THEN
              ELSE
                WRITE(MSGBUF, '(3A)')
     >  ' FIND_RHO_SCALAR : equationOfState = "', EQUATIONOFSTATE, '"'
                CALL print_error(MSGBUF, MYTHID)
                WRITE(*, *) 'ABNORMAL END: S/R FIND_RHO_SCALAR'
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE sw_ptmp(S, T, P, PR, RV)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) S
      REAL(w2f__8) T
      REAL(w2f__8) P
      REAL(w2f__8) PR
      REAL(w2f__8) RV
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) ADTG_VAL
      REAL(w2f__8) DEL_P
      REAL(w2f__8) DEL_TH
      REAL(w2f__8) ONEHALF
      PARAMETER ( ONEHALF = 5.0D-01)
      REAL(w2f__8) Q
      EXTERNAL sw_adtg
      REAL(w2f__8) TH
      REAL(w2f__8) THREE
      PARAMETER ( THREE = 3.0D00)
      REAL(w2f__8) TWO
      PARAMETER ( TWO = 2.0D00)
C
C     **** Statements ****
C
      DEL_P = PR - P
      CALL sw_adtg(S, T, P, ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      TH = T + DEL_TH * 5.0D-01
      Q = DEL_TH
      CALL sw_adtg(S, TH, (P + DEL_P * 5.0D-01), ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      TH = TH +(DEL_TH - Q) *(1.0D00 - 1D00 / (SQRT(2.0D00)))
      Q = DEL_TH *(2.0D00 - SQRT(2.0D00)) + Q *((3.0D00 / SQRT(2.0D00))
     >  +(-2.0D00))
      CALL sw_adtg(S, TH, (P + DEL_P * 5.0D-01), ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      TH = TH +(1D00 / (SQRT(2.0D00)) + 1.0D00) *(DEL_TH - Q)
      Q = DEL_TH *(SQRT(2.0D00) + 2.0D00) + Q *((-2.0D00) -(3.0D00 /
     >  SQRT(2.0D00)))
      CALL sw_adtg(S, TH, (P + DEL_P), ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      RV = TH +((DEL_TH - Q * 2.0D00) / 6.0D00)
      RETURN
      END SUBROUTINE

      SUBROUTINE sw_temp(S, T, P, PR, RV)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) S
      REAL(w2f__8) T
      REAL(w2f__8) P
      REAL(w2f__8) PR
      REAL(w2f__8) RV
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) ADTG_VAL
      REAL(w2f__8) DEL_P
      REAL(w2f__8) DEL_TH
      REAL(w2f__8) ONEHALF
      PARAMETER ( ONEHALF = 5.0D-01)
      REAL(w2f__8) Q
      EXTERNAL sw_adtg
      REAL(w2f__8) TH
      REAL(w2f__8) THREE
      PARAMETER ( THREE = 3.0D00)
      REAL(w2f__8) TWO
      PARAMETER ( TWO = 2.0D00)
C
C     **** Statements ****
C
      DEL_P = P - PR
      CALL sw_adtg(S, T, P, ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      TH = T + DEL_TH * 5.0D-01
      Q = DEL_TH
      CALL sw_adtg(S, TH, (P + DEL_P * 5.0D-01), ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      TH = TH +(DEL_TH - Q) *(1.0D00 - 1D00 / (SQRT(2.0D00)))
      Q = DEL_TH *(2.0D00 - SQRT(2.0D00)) + Q *((3.0D00 / SQRT(2.0D00))
     >  +(-2.0D00))
      CALL sw_adtg(S, TH, (P + DEL_P * 5.0D-01), ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      TH = TH +(1D00 / (SQRT(2.0D00)) + 1.0D00) *(DEL_TH - Q)
      Q = DEL_TH *(SQRT(2.0D00) + 2.0D00) + Q *((-2.0D00) -(3.0D00 /
     >  SQRT(2.0D00)))
      CALL sw_adtg(S, TH, (P + DEL_P), ADTG_VAL)
      DEL_TH = ADTG_VAL * DEL_P
      RV = TH +((DEL_TH - Q * 2.0D00) / 6.0D00)
      RETURN
      END SUBROUTINE

      SUBROUTINE sw_adtg(S, T, P, RV)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) S
      REAL(w2f__8) T
      REAL(w2f__8) P
      REAL(w2f__8) RV
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A0
      REAL(w2f__8) A1
      REAL(w2f__8) A2
      REAL(w2f__8) A3
      REAL(w2f__8) B0
      REAL(w2f__8) B1
      REAL(w2f__8) C0
      REAL(w2f__8) C1
      REAL(w2f__8) C2
      REAL(w2f__8) C3
      REAL(w2f__8) D0
      REAL(w2f__8) D1
      REAL(w2f__8) E0
      REAL(w2f__8) E1
      REAL(w2f__8) E2
      REAL(w2f__8) SREF
C
C     **** Statements ****
C
      SREF = 3.5D+01
      A0 = 3.58030000000000026288D-05
      A1 = 8.52580000000000060077D-06
      A2 = -6.83599999999999980289D-08
      A3 = 6.62280000000000012553D-10
      B0 = 1.89319999999999993254D-06
      B1 = -4.23930000000000011553D-08
      C0 = 1.87409999999999988724D-08
      C1 = -6.77950000000000021513D-10
      C2 = 8.73300000000000004791D-12
      C3 = -5.44810000000000015596D-14
      D0 = -1.13510000000000004036D-10
      D1 = 2.77589999999999991511D-12
      E0 = -4.62059999999999951678D-13
      E1 = 1.86759999999999997615D-14
      E2 = -2.16870000000000011594D-16
      RV = A0 + T *(A1 + T *(A2 + T * A3)) +(B0 + T * B1) *(S - SREF) +
     >  P *((D0 + T * D1) *(S - SREF) +(C0 + T *(C1 + T *(C2 + T * C3))
     > )) + P * P *(E0 + T *(E1 + T * E2))
      END SUBROUTINE

      SUBROUTINE solve_for_pressure(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use ffields_mod
      use dynvars_mod
      use solve_for_pressure_mod
      use cd_code_vars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL calc_div_ghat
      EXTERNAL cg2d
      REAL(w2f__8) CG3D_B(1 : 1)
      EXTERNAL debug_stats_rl
      EXTERNAL different_multiple
      LOGICAL(w2f__i4) different_multiple
      EXTERNAL exch_xy_rl
      REAL(w2f__8) FIRSTRESIDUAL
      EXTERNAL global_sum_tile_rl
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) KS
      REAL(w2f__8) LASTRESIDUAL
      CHARACTER(512) MSGBUF
      INTEGER(w2f__i4) NUMITERS
      EXTERNAL print_message
      LOGICAL(w2f__i4) PUTPMEINXVECTOR
      CHARACTER(10) SUFX
      REAL(w2f__8) SUMEMP
      REAL(w2f__8) TILEEMP(1 : 1, 1 : 1)
      REAL(w2f__8) TMPFAC
      EXTERNAL write_fld_xy_rl
C
C     **** Statements ****
C
      CG3D_B(1) = 0.0D00
      PUTPMEINXVECTOR = .FALSE.
      SUMEMP = 0.0D00
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ETANM1(I, J, BI, BJ) = ETAN(I, J, BI, BJ)
              CG2D_X(I, J, BI, BJ) = (ETAN(I, J, BI, BJ) * BO_SURF(I, J
     > , BI, BJ))
              CG2D_B(I, J, BI, BJ) = 0.0D00
            END DO
          END DO
          IF(FLUIDISWATER .AND. USEREALFRESHWATERFLUX) THEN
            TMPFAC = FREESURFFAC * MASS2RUNIT
            IF(EXACTCONSERV) THEN
              TMPFAC = IMPLICDIV2DFLOW * FREESURFFAC * MASS2RUNIT
            ENDIF
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                CG2D_B(I, J, BI, BJ) = ((EMPMR(I, J, BI, BJ) * RA(I, J,
     >  BI, BJ) * TMPFAC) / DELTATMOM)
              END DO
            END DO
          ENDIF
          IF(PUTPMEINXVECTOR) THEN
            TILEEMP(BI, BJ) = 0.0D00
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                TILEEMP(BI, BJ) = (TILEEMP(BI, BJ) + MASKH(I, J, BI, BJ
     > ) * EMPMR(I, J, BI, BJ) * RA(I, J, BI, BJ))
              END DO
            END DO
          ENDIF
        END DO
      END DO
      IF(PUTPMEINXVECTOR) THEN
        CALL global_sum_tile_rl(TILEEMP, SUMEMP, MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          IF(PUTPMEINXVECTOR) THEN
            TMPFAC = 0.0D00
            IF(GLOBALAREA .GT. 0.0D00) THEN
              TMPFAC = (SUMEMP * MASS2RUNIT * DELTATFREESURF *
     >  FREESURFFAC) / GLOBALAREA
            ENDIF
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                CG2D_X(I, J, BI, BJ) = (CG2D_X(I, J, BI, BJ) - BO_SURF(
     > I, J, BI, BJ) * TMPFAC)
              END DO
            END DO
          ENDIF
          DO K = 15, 1, (-1)
            CALL calc_div_ghat((BI), (BJ), (K), CG2D_B, CG3D_B, MYTHID)
          END DO
        END DO
      END DO
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          IF(EXACTCONSERV) THEN
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                KS = KSURFC(I, J, BI, BJ)
                CG2D_B(I, J, BI, BJ) = (CG2D_B(I, J, BI, BJ) - ETAH(I,
     >  J, BI, BJ) *(((DEEPFAC2F(KS) * RA(I, J, BI, BJ) * FREESURFFAC)
     >  / DELTATMOM) / DELTATFREESURF))
              END DO
            END DO
          ELSE
            DO J = 1, 40, 1
              DO I = 1, 90, 1
                KS = KSURFC(I, J, BI, BJ)
                CG2D_B(I, J, BI, BJ) = (CG2D_B(I, J, BI, BJ) - ETAN(I,
     >  J, BI, BJ) *(((DEEPFAC2F(KS) * RA(I, J, BI, BJ) * FREESURFFAC)
     >  / DELTATMOM) / DELTATFREESURF))
              END DO
            END DO
          ENDIF
        END DO
      END DO
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_stats_rl((1), CG2D_B, 'cg2d_b (SOLVE_FOR_PRESSURE)',
     >  MYTHID)
      ENDIF
      IF(different_multiple(DIAGFREQ, MYTIME, DELTATCLOCK)) THEN
        WRITE(SUFX, '(I10.10)') MYITER
        CALL write_fld_xy_rl('cg2d_b.', SUFX, CG2D_B, MYITER, MYTHID)
      ENDIF
      FIRSTRESIDUAL = 0.0D00
      LASTRESIDUAL = 0.0D00
      NUMITERS = CG2DMAXITERS
      CALL cg2d(CG2D_B, CG2D_X, FIRSTRESIDUAL, LASTRESIDUAL, NUMITERS,
     >  MYTHID)
      CALL exch_xy_rl(CG2D_X, MYTHID)
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_stats_rl((1), CG2D_X, 'cg2d_x (SOLVE_FOR_PRESSURE)',
     >  MYTHID)
      ENDIF
      IF(different_multiple(MONITORFREQ, MYTIME, DELTATCLOCK)) THEN
        IF(DEBUGLEVEL .GE. 1) THEN
          IF(MYTHID .eq. 1) THEN
            WRITE(MSGBUF, '(A34,1PE24.14)') 'cg2d_init_res =',
     >  FIRSTRESIDUAL
            CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
            WRITE(MSGBUF, '(A34,I6)') 'cg2d_iters =', NUMITERS
            CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
            WRITE(MSGBUF, '(A34,1PE24.14)') 'cg2d_res =', LASTRESIDUAL
            CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
          ENDIF
        ENDIF
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              ETAN(I, J, BI, BJ) = (CG2D_X(I, J, BI, BJ) * RECIP_BO(I,
     >  J, BI, BJ))
            END DO
          END DO
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE state_summary(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      CHARACTER(512) MSGBUF
      EXTERNAL print_message
C
C     **** Statements ****
C
      CALL barrier(MYTHID)
      IF(MYTHID .eq. 1) THEN
        WRITE(MSGBUF, '(A)')
     >  '// =============================================' //
     >  '=========='
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
        WRITE(MSGBUF, '(A)') '// Model current state'
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
        WRITE(MSGBUF, '(A)')
     >  '// =============================================' //
     >  '=========='
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
        WRITE(MSGBUF, '(A)') ' '
        CALL print_message(MSGBUF, STANDARDMESSAGEUNIT, 'R', (1))
      ENDIF
      CALL barrier(MYTHID)
      RETURN
      END SUBROUTINE

      SUBROUTINE taueddy_external_forcing_u(IMIN, IMAX, JMIN, JMAX, BI,
     >  BJ, KLEV, MYCURRENTTIME, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) KLEV
      REAL(w2f__8) MYCURRENTTIME
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE taueddy_external_forcing_v(IMIN, IMAX, JMIN, JMAX, BI,
     >  BJ, KLEV, MYCURRENTTIME, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use dynvars_mod
      use ffields_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) KLEV
      REAL(w2f__8) MYCURRENTTIME
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE taueddy_init_varia(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use ffields_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      END SUBROUTINE

      SUBROUTINE timestep(BI, BJ, IMIN, IMAX, JMIN, JMAX, K, DPHIHYDX,
     >  DPHIHYDY, PHISURFX, PHISURFY, GUDISSIP, GVDISSIP, MYTIME,
     >  MYITER, MYTHID)
      use w2f__types
      use size_mod
      use dynvars_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use restart_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      REAL(w2f__8) DPHIHYDX(-2 : 93, -2 : 43)
      REAL(w2f__8) DPHIHYDY(-2 : 93, -2 : 43)
      REAL(w2f__8) PHISURFX(-2 : 93, -2 : 43)
      REAL(w2f__8) PHISURFY(-2 : 93, -2 : 43)
      REAL(w2f__8) GUDISSIP(-2 : 93, -2 : 43)
      REAL(w2f__8) GVDISSIP(-2 : 93, -2 : 43)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL adams_bashforth2
      EXTERNAL cd_code_scheme
      EXTERNAL external_forcing_u
      EXTERNAL external_forcing_v
      REAL(w2f__8) GUCOR(-2 : 93, -2 : 43)
      REAL(w2f__8) GUTMP(-2 : 93, -2 : 43)
      REAL(w2f__8) GVCOR(-2 : 93, -2 : 43)
      REAL(w2f__8) GVTMP(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
      REAL(w2f__8) PHXFAC
      REAL(w2f__8) PHYFAC
      REAL(w2f__8) PSFAC
C
C     **** Statements ****
C
      PSFAC = PFFACMOM *(1.0D00 - IMPLICSURFPRESS)
      PHXFAC = PFFACMOM
      PHYFAC = PFFACMOM
      DO J = -2, 43, 1
        DO I = -2, 93, 1
          GUTMP(I, J) = 0.0D00
          GVTMP(I, J) = 0.0D00
          GUCOR(I, J) = 0.0D00
          GVCOR(I, J) = 0.0D00
        END DO
      END DO
      IF(.NOT.(IMPLICITINTGRAVWAVE .OR. STAGGERTIMESTEP)) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (GU(I, J, K, BI, BJ) - DPHIHYDX(I, J)
     >  * PHXFAC)
            GV(I, J, K, BI, BJ) = (GV(I, J, K, BI, BJ) - DPHIHYDY(I, J)
     >  * PHYFAC)
          END DO
        END DO
        PHXFAC = 0.0D00
        PHYFAC = 0.0D00
      ENDIF
      IF(MOMDISSIP_IN_AB .AND. MOMVISCOSITY) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GU(I, J, K, BI, BJ) = (GUDISSIP(I, J) + GU(I, J, K, BI, BJ)
     > )
            GV(I, J, K, BI, BJ) = (GVDISSIP(I, J) + GV(I, J, K, BI, BJ)
     > )
          END DO
        END DO
      ENDIF
      IF(MOMFORCING .AND.(MOMFORCINGOUTAB .ne. 1)) THEN
        CALL external_forcing_u(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
        CALL external_forcing_v(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
      ENDIF
      IF(USECDSCHEME) THEN
        IF(MOMVISCOSITY .AND.(.NOT. MOMDISSIP_IN_AB)) THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GUTMP(I, J) = (GUDISSIP(I, J) + GU(I, J, K, BI, BJ))
              GVTMP(I, J) = (GVDISSIP(I, J) + GV(I, J, K, BI, BJ))
            END DO
          END DO
        ELSE
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GUTMP(I, J) = GU(I, J, K, BI, BJ)
              GVTMP(I, J) = GV(I, J, K, BI, BJ)
            END DO
          END DO
        ENDIF
      ENDIF
      CALL adams_bashforth2(BI, BJ, K, GU, GUNM1, MOM_STARTAB, MYITER,
     >  MYTHID)
      CALL adams_bashforth2(BI, BJ, K, GV, GVNM1, MOM_STARTAB, MYITER,
     >  MYTHID)
      IF((MOMFORCINGOUTAB .eq. 1) .AND. MOMFORCING) THEN
        IF(USECDSCHEME) THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GUTMP(I, J) = (GUTMP(I, J) - GU(I, J, K, BI, BJ))
              GVTMP(I, J) = (GVTMP(I, J) - GV(I, J, K, BI, BJ))
            END DO
          END DO
        ENDIF
        CALL external_forcing_u(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
        CALL external_forcing_v(IMIN, IMAX, JMIN, JMAX, BI, BJ, K,
     >  MYTIME, MYTHID)
        IF(USECDSCHEME) THEN
          DO J = JMIN, JMAX, 1
            DO I = IMIN, IMAX, 1
              GUTMP(I, J) = (GUTMP(I, J) + GU(I, J, K, BI, BJ))
              GVTMP(I, J) = (GVTMP(I, J) + GV(I, J, K, BI, BJ))
            END DO
          END DO
        ENDIF
      ENDIF
      IF(USECDSCHEME) THEN
        CALL cd_code_scheme(BI, BJ, K, DPHIHYDX, DPHIHYDY, GUTMP, GVTMP
     > , GUCOR, GVCOR, MYTIME, MYITER, MYTHID)
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GUTMP(I, J) = (GUCOR(I, J) + GU(I, J, K, BI, BJ))
            GVTMP(I, J) = (GVCOR(I, J) + GV(I, J, K, BI, BJ))
          END DO
        END DO
      ELSE
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GUTMP(I, J) = GU(I, J, K, BI, BJ)
            GVTMP(I, J) = GV(I, J, K, BI, BJ)
          END DO
        END DO
      ENDIF
      IF(MOMVISCOSITY .AND.(.NOT. MOMDISSIP_IN_AB)) THEN
        DO J = JMIN, JMAX, 1
          DO I = IMIN, IMAX, 1
            GUTMP(I, J) = (GUDISSIP(I, J) + GUTMP(I, J))
            GVTMP(I, J) = (GVDISSIP(I, J) + GVTMP(I, J))
          END DO
        END DO
      ENDIF
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          GU(I, J, K, BI, BJ) = (UVEL(I, J, K, BI, BJ) + MASKW(I, J, K,
     >  BI, BJ) * DELTATMOM *(GUTMP(I, J) - PHISURFX(I, J) * PSFAC -
     >  DPHIHYDX(I, J) * PHXFAC))
        END DO
      END DO
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          GV(I, J, K, BI, BJ) = (VVEL(I, J, K, BI, BJ) + MASKS(I, J, K,
     >  BI, BJ) * DELTATMOM *(GVTMP(I, J) - PHISURFY(I, J) * PSFAC -
     >  DPHIHYDY(I, J) * PHYFAC))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE the_main_loop(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use ctrl_mod
      use ctrl_dummy_mod
      use cost_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      EXTERNAL barrier
      EXTERNAL cost_final
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      INTEGER(w2f__i4) IKEY_DYNAMICS
      INTEGER(w2f__i4) ILEV_1
      INTEGER(w2f__i4) ILEV_4
      EXTERNAL initialise_varia
      EXTERNAL openad_checkpointinit
      INTEGER(w2f__i4) THECURRENTSTEP
      EXTERNAL the_fourth_level_loop
      EXTERNAL the_fourth_level_plain
      EXTERNAL timer_start
      EXTERNAL timer_stop
      INTEGER(w2f__i4) UCHECKLEV1
      INTEGER(w2f__i4) UCHECKLEV2
      INTEGER(w2f__i4) UCHECKLEV3
      INTEGER(w2f__i4) UCHECKLEV4
C
C     **** Top Level Pragmas ****
C
C$OPENAD INDEPENDENT(XX_THETA)
C$OPENAD INDEPENDENT(XX_SALT)
C$OPENAD DEPENDENT(FC)
C
C     **** Statements ****
C
      IF(DEBUGMODE) THEN
        CALL debug_enter('THE_MAIN_LOOP', MYTHID)
      ENDIF
      NITER0 = NINT((STARTTIME - BASETIME) / DELTATCLOCK)
      IKEY_DYNAMICS = 1
      IF(DEBUGMODE) THEN
        CALL debug_call('INITIALISE_VARIA', MYTHID)
      ENDIF
      CALL timer_start('INITIALISE_VARIA    [THE_MAIN_LOOP]', MYTHID)
      CALL initialise_varia(MYTHID)
      CALL timer_stop('INITIALISE_VARIA    [THE_MAIN_LOOP]', MYTHID)
      CALL timer_start('MAIN LOOP           [THE_MAIN_LOOP]', MYTHID)
      CALL openad_checkpointinit(UCHECKLEV1, UCHECKLEV2, UCHECKLEV3,
     >  UCHECKLEV4)
      THECURRENTSTEP = 0
      IF(UCHECKLEV4 .GT. 0) THEN
        DO ILEV_4 = 1, UCHECKLEV4, 1
          NITER0 = NINT((STARTTIME - BASETIME) / DELTATCLOCK)
          IKEY_DYNAMICS = ILEV_1
          IF(DEBUGMODE) THEN
            CALL debug_call('FORWARD_STEP', MYTHID)
          ENDIF
          CALL timer_start('FORWARD_STEP        [THE_MAIN_LOOP]',
     >  MYTHID)
          CALL the_fourth_level_loop((ILEV_4), UCHECKLEV1, UCHECKLEV2,
     >  UCHECKLEV3, UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
          CALL timer_stop('FORWARD_STEP        [THE_MAIN_LOOP]', MYTHID
     > )
        END DO
      ELSE
        CALL the_fourth_level_plain(UCHECKLEV1, UCHECKLEV2, UCHECKLEV3,
     >  UCHECKLEV4, THECURRENTSTEP, MYTIME, MYITER, MYTHID)
      ENDIF
      CALL timer_start('COST_FINAL         [ADJOINT SPIN-DOWN]', MYTHID
     > )
      CALL cost_final(MYTHID)
      CALL timer_stop('COST_FINAL         [ADJOINT SPIN-DOWN]', MYTHID)
      CALL barrier(MYTHID)
      CALL timer_stop('MAIN LOOP           [THE_MAIN_LOOP]', MYTHID)
      IF(DEBUGMODE) THEN
        CALL debug_leave('THE_MAIN_LOOP', MYTHID)
      ENDIF
      END SUBROUTINE

      SUBROUTINE thermodynamics(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use restart_mod
      use dynvars_mod
      use grid_mod
      use gad_mod
      use tamc_mod
      use tamc_keys_mod
      use ffields_mod
      use surface_mod
      use eos_mod
      use gmredi_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL calc_3d_diffusivity
      EXTERNAL calc_common_factors
      EXTERNAL calc_diffusivity
      EXTERNAL calc_gs
      EXTERNAL calc_gt
      EXTERNAL calc_wsurf_tr
      EXTERNAL debug_call
      EXTERNAL debug_enter
      EXTERNAL debug_leave
      EXTERNAL debug_msg
      EXTERNAL debug_stats_rl
      EXTERNAL freeze
      REAL(w2f__8) FVERS(-2 : 93, -2 : 43, 1 : 2)
      REAL(w2f__8) FVERT(-2 : 93, -2 : 43, 1 : 2)
      EXTERNAL gad_advection
      EXTERNAL gmredi_calc_uvflow
      EXTERNAL gmredi_calc_wflow
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      EXTERNAL impldiff
      INTEGER(w2f__i4) J
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) K
      REAL(w2f__8) KAPPARK(-2 : 93, -2 : 43, 1 : 15)
      REAL(w2f__8) KAPPARS(-2 : 93, -2 : 43)
      REAL(w2f__8) KAPPART(-2 : 93, -2 : 43)
      INTEGER(w2f__i4) KDOWN
      INTEGER(w2f__i4) KM1
      INTEGER(w2f__i4) KUP
      REAL(w2f__8) MASKUP(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) RTRANSKP1(-2 : 93, -2 : 43)
      EXTERNAL timestep_tracer
      REAL(w2f__8) UFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) UTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) VFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) VTRANS(-2 : 93, -2 : 43)
      REAL(w2f__8) WFLD(-2 : 93, -2 : 43)
      REAL(w2f__8) XA(-2 : 93, -2 : 43)
      REAL(w2f__8) YA(-2 : 93, -2 : 43)
C
C     **** Statements ****
C
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_enter('THERMODYNAMICS', MYTHID)
      ENDIF
      IKEY = 1
      ITDKEY = 1
      TSURFCOR = 0.0D00
      SSURFCOR = 0.0D00
      IF(LINFSCONSERVETR) THEN
        CALL calc_wsurf_tr(THETA, SALT, WVEL, MYTIME, MYITER, MYTHID)
      ENDIF
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          ACT1 = BI - MYBXLO(MYTHID)
          MAX1 = MYBXHI(MYTHID) - MYBXLO(MYTHID) + 1
          ACT2 = BJ - MYBYLO(MYTHID)
          MAX2 = MYBYHI(MYTHID) - MYBYLO(MYTHID) + 1
          ACT3 = MYTHID +(-1)
          MAX3 = NTX * NTY
          ACT4 = IKEY_DYNAMICS +(-1)
          ITDKEY = ACT1 + ACT2 * MAX1 + MAX2 * ACT3 * MAX1 + MAX3 *
     >  MAX2 * ACT4 * MAX1 + 1
          DO J = -2, 43, 1
            DO I = -2, 93, 1
              XA(I, J) = 0.0D00
              YA(I, J) = 0.0D00
              UTRANS(I, J) = 0.0D00
              VTRANS(I, J) = 0.0D00
              RTRANS(I, J) = 0.0D00
              RTRANSKP1(I, J) = 0.0D00
              FVERT(I, J, 1) = 0.0D00
              FVERT(I, J, 2) = 0.0D00
              FVERS(I, J, 1) = 0.0D00
              FVERS(I, J, 2) = 0.0D00
              KAPPART(I, J) = 0.0D00
              KAPPARS(I, J) = 0.0D00
            END DO
          END DO
          DO K = 1, 15, 1
            DO J = -2, 43, 1
              DO I = -2, 93, 1
                KAPPARK(I, J, K) = 0.0D00
                GT(I, J, K, BI, BJ) = 0.0D00
                GS(I, J, K, BI, BJ) = 0.0D00
              END DO
            END DO
          END DO
          IF(TEMPMULTIDIMADVEC) THEN
            IF(DEBUGLEVEL .GE. 2) THEN
              CALL debug_call('GAD_ADVECTION', MYTHID)
            ENDIF
            CALL gad_advection(TEMPIMPLVERTADV, TEMPADVSCHEME,
     >  TEMPVERTADVSCHEME, (1), UVEL, VVEL, WVEL, THETA, GT, (BI), (BJ)
     > , MYTIME, MYITER, MYTHID)
          ENDIF
          IF(SALTMULTIDIMADVEC) THEN
            IF(DEBUGLEVEL .GE. 2) THEN
              CALL debug_call('GAD_ADVECTION', MYTHID)
            ENDIF
            CALL gad_advection(SALTIMPLVERTADV, SALTADVSCHEME,
     >  SALTVERTADVSCHEME, (2), UVEL, VVEL, WVEL, SALT, GS, (BI), (BJ),
     >  MYTIME, MYITER, MYTHID)
          ENDIF
          IF(DEBUGLEVEL .GE. 2) THEN
            CALL debug_msg('ENTERING DOWNWARD K LOOP', MYTHID)
          ENDIF
          DO K = 15, 1, (-1)
            KKEY = K + ITDKEY * 15 +(-15)
            KM1 = MAX(K +(-1), 1)
            KUP = MOD(K + 1, 2) + 1
            KDOWN = MOD(K, 2) + 1
            IMIN = -2
            IMAX = 93
            JMIN = -2
            JMAX = 43
            IF(K .eq. 15) THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  RTRANSKP1(I, J) = 0.0D00
                END DO
              END DO
            ELSE
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  RTRANSKP1(I, J) = RTRANS(I, J)
                END DO
              END DO
            ENDIF
            CALL calc_common_factors(UVEL, VVEL, UFLD, VFLD, UTRANS,
     >  VTRANS, XA, YA, (K), (BI), (BJ), MYTHID)
            IF(K .eq. 1) THEN
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  WFLD(I, J) = 0.0D00
                  MASKUP(I, J) = 0.0D00
                  RTRANS(I, J) = 0.0D00
                END DO
              END DO
            ELSE
              DO J = -2, 43, 1
                DO I = -2, 93, 1
                  WFLD(I, J) = WVEL(I, J, K, BI, BJ)
                  MASKUP(I, J) = (MASKC(I, J, K, BI, BJ) * MASKC(I, J,
     >  K + (-1), BI, BJ))
                  RTRANS(I, J) = (RHOFACF(K) * DEEPFAC2F(K) * MASKUP(I,
     >  J) * WFLD(I, J) * RA(I, J, BI, BJ))
                END DO
              END DO
            ENDIF
            IF(USEGMREDI) THEN
              CALL gmredi_calc_uvflow(UFLD, VFLD, UTRANS, VTRANS, (K),
     >  (BI), (BJ), MYTHID)
              IF(K .GE. 2) THEN
                CALL gmredi_calc_wflow(WFLD, RTRANS, (K), (BI), (BJ),
     >  MYTHID)
              ENDIF
            ENDIF
            IF(.NOT. IMPLICITDIFFUSION) THEN
              CALL calc_diffusivity((BI), (BJ), IMIN, IMAX, JMIN, JMAX,
     >  (K), MASKUP, KAPPART, KAPPARS, MYTHID)
            ENDIF
            IMIN = 0
            IMAX = 92
            JMIN = 0
            JMAX = 42
            IF(TEMPSTEPPING) THEN
              CALL calc_gt((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K), KM1
     > , KUP, KDOWN, XA, YA, MASKUP, UFLD, VFLD, WFLD, UTRANS, VTRANS,
     >  RTRANS, RTRANSKP1, KAPPART, FVERT, MYTIME, MYITER, MYTHID)
              CALL timestep_tracer((BI), (BJ), IMIN, IMAX, JMIN, JMAX,
     >  (K), TEMPADVSCHEME, THETA, GT, MYITER, MYTHID)
            ENDIF
            IF(SALTSTEPPING) THEN
              CALL calc_gs((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K), KM1
     > , KUP, KDOWN, XA, YA, MASKUP, UFLD, VFLD, WFLD, UTRANS, VTRANS,
     >  RTRANS, RTRANSKP1, KAPPARS, FVERS, MYTIME, MYITER, MYTHID)
              CALL timestep_tracer((BI), (BJ), IMIN, IMAX, JMIN, JMAX,
     >  (K), SALTADVSCHEME, SALT, GS, MYITER, MYTHID)
            ENDIF
            IF((USEOLDFREEZING .AND.(.NOT. USESEAICE)) .AND.(.NOT.((K
     >  .eq. 1) .AND. USETHSICE))) THEN
              CALL freeze((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (K),
     >  MYTHID)
            ENDIF
          END DO
          IMIN = 1
          IMAX = 90
          JMIN = 1
          JMAX = 40
          IF(IMPLICITDIFFUSION .AND. TEMPSTEPPING) THEN
            CALL calc_3d_diffusivity((BI), (BJ), IMIN, IMAX, JMIN, JMAX
     > , (1), USEGMREDI, USEKPP, KAPPARK, MYTHID)
          ENDIF
          IF(IMPLICITDIFFUSION .AND. TEMPSTEPPING) THEN
            CALL impldiff((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (1),
     >  KAPPARK, RECIP_HFACC, GT, MYTHID)
          ENDIF
          IF(IMPLICITDIFFUSION .AND. SALTSTEPPING) THEN
            CALL calc_3d_diffusivity((BI), (BJ), IMIN, IMAX, JMIN, JMAX
     > , (2), USEGMREDI, USEKPP, KAPPARK, MYTHID)
          ENDIF
          IF(IMPLICITDIFFUSION .AND. SALTSTEPPING) THEN
            CALL impldiff((BI), (BJ), IMIN, IMAX, JMIN, JMAX, (2),
     >  KAPPARK, RECIP_HFACC, GS, MYTHID)
          ENDIF
        END DO
      END DO
      IF(DEBUGMODE) THEN
        CALL debug_stats_rl((15), UVEL, 'Uvel (THERMODYNAMICS)', MYTHID
     > )
        CALL debug_stats_rl((15), VVEL, 'Vvel (THERMODYNAMICS)', MYTHID
     > )
        CALL debug_stats_rl((15), WVEL, 'Wvel (THERMODYNAMICS)', MYTHID
     > )
        CALL debug_stats_rl((15), THETA, 'Theta (THERMODYNAMICS)',
     >  MYTHID)
        CALL debug_stats_rl((15), SALT, 'Salt (THERMODYNAMICS)', MYTHID
     > )
        CALL debug_stats_rl((15), GT, 'Gt (THERMODYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GS, 'Gs (THERMODYNAMICS)', MYTHID)
        CALL debug_stats_rl((15), GTNM1, 'GtNm1 (THERMODYNAMICS)',
     >  MYTHID)
        CALL debug_stats_rl((15), GSNM1, 'GsNm1 (THERMODYNAMICS)',
     >  MYTHID)
      ENDIF
      IF(DEBUGLEVEL .GE. 2) THEN
        CALL debug_leave('THERMODYNAMICS', MYTHID)
      ENDIF
      RETURN
      END SUBROUTINE

      SUBROUTINE timestep_tracer(BI, BJ, IMIN, IMAX, JMIN, JMAX, K,
     >  ADVECTION_SCHEME, TRACER, GTRACER, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) JMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) K
      INTEGER(w2f__i4) ADVECTION_SCHEME
      REAL(w2f__8) TRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      REAL(w2f__8) GTRACER(-2 : 93, -2 : 43, 1 : 15, 1 : 1, 1 : 1)
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) J
C
C     **** Statements ****
C
      DO J = JMIN, JMAX, 1
        DO I = IMIN, IMAX, 1
          GTRACER(I, J, K, BI, BJ) = (TRACER(I, J, K, BI, BJ) +
     >  DTTRACERLEV(K) * GTRACER(I, J, K, BI, BJ))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE tracers_correction_step(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      INTEGER(w2f__i4) BI
      INTEGER(w2f__i4) BJ
      EXTERNAL convective_adjustment
      EXTERNAL cycle_tracer
      INTEGER(w2f__i4) IMAX
      INTEGER(w2f__i4) IMIN
      INTEGER(w2f__i4) JMAX
      INTEGER(w2f__i4) JMIN
C
C     **** Statements ****
C
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          IF(TEMPSTEPPING) THEN
            CALL cycle_tracer((BI), (BJ), THETA, GT, MYTIME, MYITER,
     >  MYTHID)
          ENDIF
          IF(SALTSTEPPING) THEN
            CALL cycle_tracer((BI), (BJ), SALT, GS, MYTIME, MYITER,
     >  MYTHID)
          ENDIF
        END DO
      END DO
      DO BJ = MYBYLO(MYTHID), MYBYHI(MYTHID), 1
        DO BI = MYBXLO(MYTHID), MYBXHI(MYTHID), 1
          IMIN = 1
          IMAX = 90
          JMIN = 1
          JMAX = 40
          IF(CADJFREQ .ne. 0.0D00) THEN
            CALL convective_adjustment((BI), (BJ), MYTIME, MYITER,
     >  MYTHID)
          ENDIF
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE update_cg2d(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use cg2d_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE update_etah(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use dynvars_mod
      use grid_mod
      use surface_mod
      use ffields_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE update_masks_etc(MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use optim_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE update_surf_dr(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE swfrac(IMAX, FACT, SWDK, MYTIME, MYITER, MYTHID)
      use w2f__types
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      INTEGER(w2f__i4) IMAX
      REAL(w2f__8) FACT
      REAL(w2f__8) SWDK(1 : IMAX)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Local Variables and Functions ****
C
      REAL(w2f__8) A1(1 : 5)
      SAVE A1
      REAL(w2f__8) A2(1 : 5)
      SAVE A2
      REAL(w2f__8) FACZ
      INTEGER(w2f__i4) I
      INTEGER(w2f__i4) JWTYPE
      INTEGER(w2f__i4) NWTYPE
      PARAMETER ( NWTYPE = 5)
      REAL(w2f__8) RFAC(1 : 5)
      SAVE RFAC
C
C     **** Temporary Variables ****
C
      INTEGER(w2f__i8) tmp0
C
C     **** Initializers ****
C
      DATA(A1(tmp0), tmp0 = 1, 5, 1) / 3.49999999999999977796D-01,
     >  5.99999999999999977796D-01, 1.0D00, 1.5D00,
     >  1.39999999999999991118D00 /
      DATA(A2(tmp0), tmp0 = 1, 5, 1) / 2.3D+01, 2.0D+01, 1.7D+01,
     >  1.4D+01, 7.90000000000000035527D00 /
      DATA(RFAC(tmp0), tmp0 = 1, 5, 1) / 5.79999999999999960032D-01,
     >  6.19999999999999995559D-01, 6.70000000000000039968D-01,
     >  7.70000000000000017764D-01, 7.80000000000000026645D-01 /
C
C     **** Statements ****
C
      JWTYPE = 2
      DO I = 1, IMAX, 1
        FACZ = SWDK(I) * FACT
        IF(FACZ .LT.(-2.0D+02)) THEN
          SWDK(I) = 0.0D00
        ELSE
          SWDK(I) = (RFAC(JWTYPE) * EXP(FACZ / A1(JWTYPE)) + EXP(FACZ /
     >  A2(JWTYPE)) *(1.0D00 - RFAC(JWTYPE)))
        ENDIF
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE calc_r_star(ETAFLD, MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) ETAFLD(-2 : 93, -2 : 43, 1 : 1, 1 : 1)
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE

      SUBROUTINE update_r_star(MYTIME, MYITER, MYTHID)
      use w2f__types
      use size_mod
      use eeparams_mod
      use params_mod
      use grid_mod
      use surface_mod
      use tamc_mod
      use tamc_keys_mod
      IMPLICIT NONE
C
C     **** Parameters and Result ****
C
      REAL(w2f__8) MYTIME
      INTEGER(w2f__i4) MYITER
      INTEGER(w2f__i4) MYTHID
C
C     **** Statements ****
C
      RETURN
      END SUBROUTINE
